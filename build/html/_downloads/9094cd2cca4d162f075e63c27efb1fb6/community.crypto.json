{
  "community.crypto.acme_account": {
    "doc": {
      "description": "Allows to create, modify or delete accounts with a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).\nThis module only works with the ACME v2 protocol.",
      "has_action": false,
      "notes": "The M(community.crypto.acme_certificate) module also allows to do basic account management. When using both modules, it is recommended to disable account management for M(community.crypto.acme_certificate). For that, use the C(modify_account) option of M(community.crypto.acme_certificate).\nIf a new enough version of the C(cryptography) library is available (see Requirements for details), it will be used instead of the C(openssl) binary. This can be explicitly disabled or enabled with the C(select_crypto_backend) option. Note that using the C(openssl) binary will be slower and less secure, as private key contents always have to be stored on disk (see C(account_key_content)).\nAlthough the defaults are chosen so that the module can be used with the L(Let's Encrypt,https://letsencrypt.org/) CA, the module can in principle be used with any CA providing an ACME endpoint, such as L(Buypass Go SSL,https://www.buypass.com/ssl/products/acme).",
      "options": {
        "account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key.\nMutually exclusive with C(account_key_src).\nRequired if C(account_key_src) is not used.\nB(Warning:) the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "account_key_src": {
          "aliases": [
            "account_key"
          ],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key.\nPrivate keys can be created with the M(community.crypto.openssl_privatekey) or M(community.crypto.openssl_privatekey_pipe) modules. If the requisite (cryptography) is not available, keys can also be created directly with the C(openssl) command line tool: RSA keys can be created with C(openssl genrsa ...). Elliptic curve keys can be created with C(openssl ecparam -genkey ...). Any other tool creating private keys in PEM format can be used as well.\nMutually exclusive with C(account_key_content).\nRequired if C(account_key_content) is not used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "account_uri": {
          "aliases": [],
          "description": "If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. This is the entry point URL to access the ACME CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server (for the ACME v1 protocol). This will create technically correct, but untrusted certificates.\nFor Let's Encrypt, all staging endpoints can be found here: U(https://letsencrypt.org/docs/staging-environment/). For Buypass, all endpoints can be found here: U(https://community.buypass.com/t/63d4ay/buypass-go-ssl-endpoints)\nFor B(Let's Encrypt), the production directory URL for ACME v2 is U(https://acme-v02.api.letsencrypt.org/directory).\nFor B(Buypass), the production directory URL for ACME v2 and v1 is U(https://api.buypass.com/acme/directory).\nFor B(ZeroSSL), the production directory URL for ACME v2 is U(https://acme.zerossl.com/v2/DV90).\nB(Warning:) So far, the ACME modules have only been tested against Let's Encrypt (staging and production), Buypass (staging and production), ZeroSSL (production), and L(Pebble testing server,https://github.com/letsencrypt/Pebble). If you experience problems with another ACME server, please L(create an issue,https://github.com/ansible-collections/community.crypto/issues/new/choose) to help us supporting it. Feedback that an ACME server not mentioned does work is also appreciated.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "acme_version": {
          "aliases": [],
          "description": "The ACME version of the endpoint.\nMust be C(1) for the classic Let's Encrypt and Buypass ACME endpoints, or C(2) for standardized ACME v2 endpoints.\nThe value C(1) is deprecated since community.crypto 2.0.0 and will be removed from community.crypto 3.0.0.",
          "type": "int",
          "required": true,
          "choices": [
            "1",
            "2"
          ],
          "suboptions": {}
        },
        "allow_creation": {
          "aliases": [],
          "description": "Whether account creation is allowed (when state is C(present)).",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "contact": {
          "aliases": [],
          "description": "A list of contact URLs.\nEmail addresses must be prefixed with C(mailto:).\nSee U(https://tools.ietf.org/html/rfc8555#section-7.3) for what is allowed.\nMust be specified when state is C(present). Will be ignored if state is C(absent) or C(changed_key).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "external_account_binding": {
          "aliases": [],
          "description": "Allows to provide external account binding data during account creation.\nThis is used by CAs like Sectigo to bind a new ACME account to an existing CA-specific account, to be able to properly identify a customer.\nOnly used when creating a new account. Can not be specified for ACME v1.",
          "type": "dict",
          "required": false,
          "version_added": "1.1.0",
          "suboptions": {
            "alg": {
              "aliases": [],
              "description": "The MAC algorithm provided by the CA.\nIf not specified by the CA, this is probably C(HS256).",
              "type": "str",
              "required": true,
              "choices": [
                "HS256",
                "HS384",
                "HS512"
              ],
              "suboptions": {}
            },
            "key": {
              "aliases": [],
              "description": "Base64 URL encoded value of the MAC key provided by the CA.\nPadding (C(=) symbols at the end) can be omitted.",
              "type": "str",
              "required": true,
              "suboptions": {}
            },
            "kid": {
              "aliases": [],
              "description": "The key identifier provided by the CA.",
              "type": "str",
              "required": true,
              "suboptions": {}
            }
          }
        },
        "new_account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key to change to.\nSame restrictions apply as to C(account_key_content).\nMutually exclusive with C(new_account_key_src).\nRequired if C(new_account_key_src) is not used and state is C(changed_key).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "new_account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the new account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "new_account_key_src": {
          "aliases": [],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key to change to.\nSame restrictions apply as to C(account_key_src).\nMutually exclusive with C(new_account_key_content).\nRequired if C(new_account_key_content) is not used and state is C(changed_key).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the C(openssl) binary.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The state of the account, to be identified by its account key.\nIf the state is C(absent), the account will either not exist or be deactivated.\nIf the state is C(changed_key), the account must exist. The account key will be changed; no other information will be touched.",
          "type": "str",
          "required": true,
          "choices": [
            "present",
            "absent",
            "changed_key"
          ],
          "suboptions": {}
        },
        "terms_agreed": {
          "aliases": [],
          "description": "Boolean indicating whether you agree to the terms of service document.\nACME servers can require this to be true.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "Whether calls to the ACME directory will validate TLS certificates.\nB(Warning:) Should B(only ever) be set to C(no) for testing purposes, for example when testing against a local Pebble server.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "either openssl or L(cryptography,https://cryptography.io/) >= 1.5",
        "ipaddress"
      ],
      "short_description": "Create, modify or delete ACME accounts"
    },
    "examples": "\n- name: Make sure account exists and has given contacts. We agree to TOS.\n  community.crypto.acme_account:\n    account_key_src: /etc/pki/cert/private/account.key\n    state: present\n    terms_agreed: yes\n    contact:\n    - mailto:me@example.com\n    - mailto:myself@example.org\n\n- name: Make sure account has given email address. Don't create account if it doesn't exist\n  community.crypto.acme_account:\n    account_key_src: /etc/pki/cert/private/account.key\n    state: present\n    allow_creation: no\n    contact:\n    - mailto:me@example.com\n\n- name: Change account's key to the one stored in the variable new_account_key\n  community.crypto.acme_account:\n    account_key_src: /etc/pki/cert/private/account.key\n    new_account_key_content: '{{ new_account_key }}'\n    state: changed_key\n\n- name: Delete account (we have to use the new key)\n  community.crypto.acme_account:\n    account_key_content: '{{ new_account_key }}'\n    state: absent\n"
  },
  "community.crypto.acme_account_info": {
    "doc": {
      "description": "Allows to retrieve information on accounts a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).\nThis module only works with the ACME v2 protocol.",
      "has_action": false,
      "notes": "The M(community.crypto.acme_account) module allows to modify, create and delete ACME accounts.\nThis module was called C(acme_account_facts) before Ansible 2.8. The usage did not change.\nSupports C(check_mode).\nIf a new enough version of the C(cryptography) library is available (see Requirements for details), it will be used instead of the C(openssl) binary. This can be explicitly disabled or enabled with the C(select_crypto_backend) option. Note that using the C(openssl) binary will be slower and less secure, as private key contents always have to be stored on disk (see C(account_key_content)).\nAlthough the defaults are chosen so that the module can be used with the L(Let's Encrypt,https://letsencrypt.org/) CA, the module can in principle be used with any CA providing an ACME endpoint, such as L(Buypass Go SSL,https://www.buypass.com/ssl/products/acme).",
      "options": {
        "account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key.\nMutually exclusive with C(account_key_src).\nRequired if C(account_key_src) is not used.\nB(Warning:) the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "account_key_src": {
          "aliases": [
            "account_key"
          ],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key.\nPrivate keys can be created with the M(community.crypto.openssl_privatekey) or M(community.crypto.openssl_privatekey_pipe) modules. If the requisite (cryptography) is not available, keys can also be created directly with the C(openssl) command line tool: RSA keys can be created with C(openssl genrsa ...). Elliptic curve keys can be created with C(openssl ecparam -genkey ...). Any other tool creating private keys in PEM format can be used as well.\nMutually exclusive with C(account_key_content).\nRequired if C(account_key_content) is not used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "account_uri": {
          "aliases": [],
          "description": "If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. This is the entry point URL to access the ACME CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server (for the ACME v1 protocol). This will create technically correct, but untrusted certificates.\nFor Let's Encrypt, all staging endpoints can be found here: U(https://letsencrypt.org/docs/staging-environment/). For Buypass, all endpoints can be found here: U(https://community.buypass.com/t/63d4ay/buypass-go-ssl-endpoints)\nFor B(Let's Encrypt), the production directory URL for ACME v2 is U(https://acme-v02.api.letsencrypt.org/directory).\nFor B(Buypass), the production directory URL for ACME v2 and v1 is U(https://api.buypass.com/acme/directory).\nFor B(ZeroSSL), the production directory URL for ACME v2 is U(https://acme.zerossl.com/v2/DV90).\nB(Warning:) So far, the ACME modules have only been tested against Let's Encrypt (staging and production), Buypass (staging and production), ZeroSSL (production), and L(Pebble testing server,https://github.com/letsencrypt/Pebble). If you experience problems with another ACME server, please L(create an issue,https://github.com/ansible-collections/community.crypto/issues/new/choose) to help us supporting it. Feedback that an ACME server not mentioned does work is also appreciated.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "acme_version": {
          "aliases": [],
          "description": "The ACME version of the endpoint.\nMust be C(1) for the classic Let's Encrypt and Buypass ACME endpoints, or C(2) for standardized ACME v2 endpoints.\nThe value C(1) is deprecated since community.crypto 2.0.0 and will be removed from community.crypto 3.0.0.",
          "type": "int",
          "required": true,
          "choices": [
            "1",
            "2"
          ],
          "suboptions": {}
        },
        "retrieve_orders": {
          "aliases": [],
          "description": "Whether to retrieve the list of order URLs or order objects, if provided by the ACME server.\nA value of C(ignore) will not fetch the list of orders.\nIf the value is not C(ignore) and the ACME server supports orders, the C(order_uris) return value is always populated. The C(orders) return value is only returned if this option is set to C(object_list).\nCurrently, Let's Encrypt does not return orders, so the C(orders) result will always be empty.",
          "default": "ignore",
          "type": "str",
          "required": false,
          "choices": [
            "ignore",
            "url_list",
            "object_list"
          ],
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the C(openssl) binary.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "Whether calls to the ACME directory will validate TLS certificates.\nB(Warning:) Should B(only ever) be set to C(no) for testing purposes, for example when testing against a local Pebble server.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "either openssl or L(cryptography,https://cryptography.io/) >= 1.5",
        "ipaddress"
      ],
      "short_description": "Retrieves information on ACME accounts"
    },
    "examples": "\n- name: Check whether an account with the given account key exists\n  community.crypto.acme_account_info:\n    account_key_src: /etc/pki/cert/private/account.key\n    register: account_data\n- name: Verify that account exists\n  assert:\n    that:\n      - account_data.exists\n- name: Print account URI\n  ansible.builtin.debug:\n    var: account_data.account_uri\n- name: Print account contacts\n  ansible.builtin.debug:\n    var: account_data.account.contact\n\n- name: Check whether the account exists and is accessible with the given account key\n  acme_account_info:\n    account_key_content: \"{{ acme_account_key }}\"\n    account_uri: \"{{ acme_account_uri }}\"\n    register: account_data\n- name: Verify that account exists\n  assert:\n    that:\n      - account_data.exists\n- name: Print account contacts\n  ansible.builtin.debug:\n    var: account_data.account.contact\n"
  },
  "community.crypto.acme_certificate": {
    "doc": {
      "description": "Create and renew SSL/TLS certificates with a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/) or L(Buypass,https://www.buypass.com/). The current implementation supports the C(http-01), C(dns-01) and C(tls-alpn-01) challenges.\nTo use this module, it has to be executed twice. Either as two different tasks in the same run or during two runs. Note that the output of the first run needs to be recorded and passed to the second run as the module argument C(data).\nBetween these two tasks you have to fulfill the required steps for the chosen challenge by whatever means necessary. For C(http-01) that means creating the necessary challenge file on the destination webserver. For C(dns-01) the necessary dns record has to be created. For C(tls-alpn-01) the necessary certificate has to be created and served. It is I(not) the responsibility of this module to perform these steps.\nFor details on how to fulfill these challenges, you might have to read through L(the main ACME specification,https://tools.ietf.org/html/rfc8555#section-8) and the L(TLS-ALPN-01 specification,https://www.rfc-editor.org/rfc/rfc8737.html#section-3). Also, consider the examples provided for this module.\nThe module includes experimental support for IP identifiers according to the L(RFC 8738,https://www.rfc-editor.org/rfc/rfc8738.html).",
      "has_action": false,
      "notes": "At least one of C(dest) and C(fullchain_dest) must be specified.\nThis module includes basic account management functionality. If you want to have more control over your ACME account, use the M(community.crypto.acme_account) module and disable account management for this module using the C(modify_account) option.\nThis module was called C(letsencrypt) before Ansible 2.6. The usage did not change.\nIf a new enough version of the C(cryptography) library is available (see Requirements for details), it will be used instead of the C(openssl) binary. This can be explicitly disabled or enabled with the C(select_crypto_backend) option. Note that using the C(openssl) binary will be slower and less secure, as private key contents always have to be stored on disk (see C(account_key_content)).\nAlthough the defaults are chosen so that the module can be used with the L(Let's Encrypt,https://letsencrypt.org/) CA, the module can in principle be used with any CA providing an ACME endpoint, such as L(Buypass Go SSL,https://www.buypass.com/ssl/products/acme).",
      "options": {
        "account_email": {
          "aliases": [],
          "description": "The email address associated with this account.\nIt will be used for certificate expiration warnings.\nNote that when C(modify_account) is not set to C(no) and you also used the M(community.crypto.acme_account) module to specify more than one contact for your account, this module will update your account and restrict it to the (at most one) contact email address specified here.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key.\nMutually exclusive with C(account_key_src).\nRequired if C(account_key_src) is not used.\nB(Warning:) the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "account_key_src": {
          "aliases": [
            "account_key"
          ],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key.\nPrivate keys can be created with the M(community.crypto.openssl_privatekey) or M(community.crypto.openssl_privatekey_pipe) modules. If the requisite (cryptography) is not available, keys can also be created directly with the C(openssl) command line tool: RSA keys can be created with C(openssl genrsa ...). Elliptic curve keys can be created with C(openssl ecparam -genkey ...). Any other tool creating private keys in PEM format can be used as well.\nMutually exclusive with C(account_key_content).\nRequired if C(account_key_content) is not used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "account_uri": {
          "aliases": [],
          "description": "If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. This is the entry point URL to access the ACME CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server (for the ACME v1 protocol). This will create technically correct, but untrusted certificates.\nFor Let's Encrypt, all staging endpoints can be found here: U(https://letsencrypt.org/docs/staging-environment/). For Buypass, all endpoints can be found here: U(https://community.buypass.com/t/63d4ay/buypass-go-ssl-endpoints)\nFor B(Let's Encrypt), the production directory URL for ACME v2 is U(https://acme-v02.api.letsencrypt.org/directory).\nFor B(Buypass), the production directory URL for ACME v2 and v1 is U(https://api.buypass.com/acme/directory).\nFor B(ZeroSSL), the production directory URL for ACME v2 is U(https://acme.zerossl.com/v2/DV90).\nB(Warning:) So far, the ACME modules have only been tested against Let's Encrypt (staging and production), Buypass (staging and production), ZeroSSL (production), and L(Pebble testing server,https://github.com/letsencrypt/Pebble). If you experience problems with another ACME server, please L(create an issue,https://github.com/ansible-collections/community.crypto/issues/new/choose) to help us supporting it. Feedback that an ACME server not mentioned does work is also appreciated.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "acme_version": {
          "aliases": [],
          "description": "The ACME version of the endpoint.\nMust be C(1) for the classic Let's Encrypt and Buypass ACME endpoints, or C(2) for standardized ACME v2 endpoints.\nThe value C(1) is deprecated since community.crypto 2.0.0 and will be removed from community.crypto 3.0.0.",
          "type": "int",
          "required": true,
          "choices": [
            "1",
            "2"
          ],
          "suboptions": {}
        },
        "agreement": {
          "aliases": [],
          "description": "URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).\nDefault is latest gathered from C(acme_directory) URL.\nThis option will only be used when C(acme_version) is 1.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "chain_dest": {
          "aliases": [
            "chain"
          ],
          "description": "If specified, the intermediate certificate will be written to this file.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "challenge": {
          "aliases": [],
          "description": "The challenge to be performed.",
          "default": "http-01",
          "type": "str",
          "required": false,
          "choices": [
            "http-01",
            "dns-01",
            "tls-alpn-01"
          ],
          "suboptions": {}
        },
        "csr": {
          "aliases": [
            "src"
          ],
          "description": "File containing the CSR for the new certificate.\nCan be created with M(community.crypto.openssl_csr) or C(openssl req ...).\nThe CSR may contain multiple Subject Alternate Names, but each one will lead to an individual challenge that must be fulfilled for the CSR to be signed.\nI(Note): the private key used to create the CSR I(must not) be the account key. This is a bad idea from a security point of view, and the CA should not accept the CSR. The ACME server should return an error in this case.\nPrecisely one of I(csr) or I(csr_content) must be specified.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "csr_content": {
          "aliases": [],
          "description": "Content of the CSR for the new certificate.\nCan be created with M(community.crypto.openssl_csr_pipe) or C(openssl req ...).\nThe CSR may contain multiple Subject Alternate Names, but each one will lead to an individual challenge that must be fulfilled for the CSR to be signed.\nI(Note): the private key used to create the CSR I(must not) be the account key. This is a bad idea from a security point of view, and the CA should not accept the CSR. The ACME server should return an error in this case.\nPrecisely one of I(csr) or I(csr_content) must be specified.",
          "type": "str",
          "required": false,
          "version_added": "1.2.0",
          "suboptions": {}
        },
        "data": {
          "aliases": [],
          "description": "The data to validate ongoing challenges. This must be specified for the second run of the module only.\nThe value that must be used here will be provided by a previous use of this module. See the examples for more details.\nNote that for ACME v2, only the C(order_uri) entry of C(data) will be used. For ACME v1, C(data) must be non-empty to indicate the second stage is active; all needed data will be taken from the CSR.\nI(Note): the C(data) option was marked as C(no_log) up to Ansible 2.5. From Ansible 2.6 on, it is no longer marked this way as it causes error messages to be come unusable, and C(data) does not contain any information which can be used without having access to the account key or which are not public anyway.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "deactivate_authzs": {
          "aliases": [],
          "description": "Deactivate authentication objects (authz) after issuing a certificate, or when issuing the certificate failed.\nAuthentication objects are bound to an account key and remain valid for a certain amount of time, and can be used to issue certificates without having to re-authenticate the domain. This can be a security concern.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [
            "cert"
          ],
          "description": "The destination file for the certificate.\nRequired if C(fullchain_dest) is not specified.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Enforces the execution of the challenge and validation, even if an existing certificate is still valid for more than C(remaining_days).\nThis is especially helpful when having an updated CSR e.g. with additional domains for which a new certificate is desired.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "fullchain_dest": {
          "aliases": [
            "fullchain"
          ],
          "description": "The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).\nRequired if C(dest) is not specified.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "modify_account": {
          "aliases": [],
          "description": "Boolean indicating whether the module should create the account if necessary, and update its contact data.\nSet to C(no) if you want to use the M(community.crypto.acme_account) module to manage your account instead, and to avoid accidental creation of a new account using an old key if you changed the account key with M(community.crypto.acme_account).\nIf set to C(no), C(terms_agreed) and C(account_email) are ignored.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "remaining_days": {
          "aliases": [],
          "description": "The number of days the certificate must have left being valid. If C(cert_days < remaining_days), then it will be renewed. If the certificate is not renewed, module return values will not include C(challenge_data).\nTo make sure that the certificate is renewed in any case, you can use the C(force) option.",
          "default": "10",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "retrieve_all_alternates": {
          "aliases": [],
          "description": "When set to C(yes), will retrieve all alternate trust chains offered by the ACME CA. These will not be written to disk, but will be returned together with the main chain as C(all_chains). See the documentation for the C(all_chains) return value for details.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "select_chain": {
          "aliases": [],
          "description": "Allows to specify criteria by which an (alternate) trust chain can be selected.\nThe list of criteria will be processed one by one until a chain is found matching a criterium. If such a chain is found, it will be used by the module instead of the default chain.\nIf a criterium matches multiple chains, the first one matching will be returned. The order is determined by the ordering of the C(Link) headers returned by the ACME server and might not be deterministic.\nEvery criterium can consist of multiple different conditions, like I(issuer) and I(subject). For the criterium to match a chain, all conditions must apply to the same certificate in the chain.\nThis option can only be used with the C(cryptography) backend.",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "1.0.0",
          "suboptions": {
            "authority_key_identifier": {
              "aliases": [],
              "description": "Checks for the AuthorityKeyIdentifier extension. This is an identifier based on the private key of the issuer of the intermediate certificate.\nThe identifier must be of the form C(C4:A7:B1:A4:7B:2C:71:FA:DB:E1:4B:90:75:FF:C4:15:60:85:89:10).",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "issuer": {
              "aliases": [],
              "description": "Allows to specify parts of the issuer of a certificate in the chain must have to be selected.\nIf I(issuer) is empty, any certificate will match.\nAn example value would be C({\"commonName\": \"My Preferred CA Root\"}).",
              "type": "dict",
              "required": false,
              "suboptions": {}
            },
            "subject": {
              "aliases": [],
              "description": "Allows to specify parts of the subject of a certificate in the chain must have to be selected.\nIf I(subject) is empty, any certificate will match.\nAn example value would be C({\"CN\": \"My Preferred CA Intermediate\"})",
              "type": "dict",
              "required": false,
              "suboptions": {}
            },
            "subject_key_identifier": {
              "aliases": [],
              "description": "Checks for the SubjectKeyIdentifier extension. This is an identifier based on the private key of the intermediate certificate.\nThe identifier must be of the form C(A8:4A:6A:63:04:7D:DD:BA:E6:D1:39:B7:A6:45:65:EF:F3:A8:EC:A1).",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "test_certificates": {
              "aliases": [],
              "description": "Determines which certificates in the chain will be tested.\nI(all) tests all certificates in the chain (excluding the leaf, which is identical in all chains).\nI(first) only tests the first certificate in the chain, i.e. the one which signed the leaf.\nI(last) only tests the last certificate in the chain, i.e. the one furthest away from the leaf. Its issuer is the root certificate of this chain.",
              "default": "all",
              "type": "str",
              "required": false,
              "choices": [
                "first",
                "last",
                "all"
              ],
              "suboptions": {}
            }
          }
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the C(openssl) binary.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "suboptions": {}
        },
        "terms_agreed": {
          "aliases": [],
          "description": "Boolean indicating whether you agree to the terms of service document.\nACME servers can require this to be true.\nThis option will only be used when C(acme_version) is not 1.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "Whether calls to the ACME directory will validate TLS certificates.\nB(Warning:) Should B(only ever) be set to C(no) for testing purposes, for example when testing against a local Pebble server.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "either openssl or L(cryptography,https://cryptography.io/) >= 1.5",
        "ipaddress"
      ],
      "short_description": "Create SSL/TLS certificates with the ACME protocol"
    },
    "examples": "\n### Example with HTTP challenge ###\n\n- name: Create a challenge for sample.com using a account key from a variable.\n  community.crypto.acme_certificate:\n    account_key_content: \"{{ account_private_key }}\"\n    csr: /etc/pki/cert/csr/sample.com.csr\n    dest: /etc/httpd/ssl/sample.com.crt\n  register: sample_com_challenge\n\n# Alternative first step:\n- name: Create a challenge for sample.com using a account key from hashi vault.\n  community.crypto.acme_certificate:\n    account_key_content: \"{{ lookup('hashi_vault', 'secret=secret/account_private_key:value') }}\"\n    csr: /etc/pki/cert/csr/sample.com.csr\n    fullchain_dest: /etc/httpd/ssl/sample.com-fullchain.crt\n  register: sample_com_challenge\n\n# Alternative first step:\n- name: Create a challenge for sample.com using a account key file.\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    csr_content: \"{{ lookup('file', '/etc/pki/cert/csr/sample.com.csr') }}\"\n    dest: /etc/httpd/ssl/sample.com.crt\n    fullchain_dest: /etc/httpd/ssl/sample.com-fullchain.crt\n  register: sample_com_challenge\n\n# perform the necessary steps to fulfill the challenge\n# for example:\n#\n# - copy:\n#     dest: /var/www/html/{{ sample_com_challenge['challenge_data']['sample.com']['http-01']['resource'] }}\n#     content: \"{{ sample_com_challenge['challenge_data']['sample.com']['http-01']['resource_value'] }}\"\n#     when: sample_com_challenge is changed and 'sample.com' in sample_com_challenge['challenge_data']\n#\n# Alternative way:\n#\n# - copy:\n#     dest: /var/www/{{ item.key }}/{{ item.value['http-01']['resource'] }}\n#     content: \"{{ item.value['http-01']['resource_value'] }}\"\n#   loop: \"{{ sample_com_challenge.challenge_data | dict2items }}\"\n#   when: sample_com_challenge is changed\n\n- name: Let the challenge be validated and retrieve the cert and intermediate certificate\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    csr: /etc/pki/cert/csr/sample.com.csr\n    dest: /etc/httpd/ssl/sample.com.crt\n    fullchain_dest: /etc/httpd/ssl/sample.com-fullchain.crt\n    chain_dest: /etc/httpd/ssl/sample.com-intermediate.crt\n    data: \"{{ sample_com_challenge }}\"\n\n### Example with DNS challenge against production ACME server ###\n\n- name: Create a challenge for sample.com using a account key file.\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    account_email: myself@sample.com\n    src: /etc/pki/cert/csr/sample.com.csr\n    cert: /etc/httpd/ssl/sample.com.crt\n    challenge: dns-01\n    acme_directory: https://acme-v01.api.letsencrypt.org/directory\n    # Renew if the certificate is at least 30 days old\n    remaining_days: 60\n  register: sample_com_challenge\n\n# perform the necessary steps to fulfill the challenge\n# for example:\n#\n# - community.aws.route53:\n#     zone: sample.com\n#     record: \"{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].record }}\"\n#     type: TXT\n#     ttl: 60\n#     state: present\n#     wait: yes\n#     # Note: route53 requires TXT entries to be enclosed in quotes\n#     value: \"{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].resource_value | regex_replace('^(.*)$', '\\\"\\\\1\\\"') }}\"\n#   when: sample_com_challenge is changed and 'sample.com' in sample_com_challenge.challenge_data\n#\n# Alternative way:\n#\n# - community.aws.route53:\n#     zone: sample.com\n#     record: \"{{ item.key }}\"\n#     type: TXT\n#     ttl: 60\n#     state: present\n#     wait: yes\n#     # Note: item.value is a list of TXT entries, and route53\n#     # requires every entry to be enclosed in quotes\n#     value: \"{{ item.value | map('regex_replace', '^(.*)$', '\\\"\\\\1\\\"' ) | list }}\"\n#   loop: \"{{ sample_com_challenge.challenge_data_dns | dict2items }}\"\n#   when: sample_com_challenge is changed\n\n- name: Let the challenge be validated and retrieve the cert and intermediate certificate\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    account_email: myself@sample.com\n    src: /etc/pki/cert/csr/sample.com.csr\n    cert: /etc/httpd/ssl/sample.com.crt\n    fullchain: /etc/httpd/ssl/sample.com-fullchain.crt\n    chain: /etc/httpd/ssl/sample.com-intermediate.crt\n    challenge: dns-01\n    acme_directory: https://acme-v01.api.letsencrypt.org/directory\n    remaining_days: 60\n    data: \"{{ sample_com_challenge }}\"\n  when: sample_com_challenge is changed\n\n# Alternative second step:\n- name: Let the challenge be validated and retrieve the cert and intermediate certificate\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    account_email: myself@sample.com\n    src: /etc/pki/cert/csr/sample.com.csr\n    cert: /etc/httpd/ssl/sample.com.crt\n    fullchain: /etc/httpd/ssl/sample.com-fullchain.crt\n    chain: /etc/httpd/ssl/sample.com-intermediate.crt\n    challenge: tls-alpn-01\n    remaining_days: 60\n    data: \"{{ sample_com_challenge }}\"\n    # We use Let's Encrypt's ACME v2 endpoint\n    acme_directory: https://acme-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    # The following makes sure that if a chain with /CN=DST Root CA X3 in its issuer is provided\n    # as an alternative, it will be selected. These are the roots cross-signed by IdenTrust.\n    # As long as Let's Encrypt provides alternate chains with the cross-signed root(s) when\n    # switching to their own ISRG Root X1 root, this will use the chain ending with a cross-signed\n    # root. This chain is more compatible with older TLS clients.\n    select_chain:\n      - test_certificates: last\n        issuer:\n          CN: DST Root CA X3\n          O: Digital Signature Trust Co.\n  when: sample_com_challenge is changed\n"
  },
  "community.crypto.acme_certificate_revoke": {
    "doc": {
      "description": "Allows to revoke certificates issued by a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).",
      "has_action": false,
      "notes": "Exactly one of C(account_key_src), C(account_key_content), C(private_key_src) or C(private_key_content) must be specified.\nTrying to revoke an already revoked certificate should result in an unchanged status, even if the revocation reason was different than the one specified here. Also, depending on the server, it can happen that some other error is returned if the certificate has already been revoked.\nDoes not support C(check_mode).\nIf a new enough version of the C(cryptography) library is available (see Requirements for details), it will be used instead of the C(openssl) binary. This can be explicitly disabled or enabled with the C(select_crypto_backend) option. Note that using the C(openssl) binary will be slower and less secure, as private key contents always have to be stored on disk (see C(account_key_content)).\nAlthough the defaults are chosen so that the module can be used with the L(Let's Encrypt,https://letsencrypt.org/) CA, the module can in principle be used with any CA providing an ACME endpoint, such as L(Buypass Go SSL,https://www.buypass.com/ssl/products/acme).",
      "options": {
        "account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key.\nNote that exactly one of C(account_key_src), C(account_key_content), C(private_key_src) or C(private_key_content) must be specified.\nI(Warning): the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "account_key_src": {
          "aliases": [
            "account_key"
          ],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key.\nRSA keys can be created with C(openssl rsa ...). Elliptic curve keys can be created with C(openssl ecparam -genkey ...). Any other tool creating private keys in PEM format can be used as well.\nMutually exclusive with C(account_key_content).\nRequired if C(account_key_content) is not used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "account_uri": {
          "aliases": [],
          "description": "If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. This is the entry point URL to access the ACME CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server (for the ACME v1 protocol). This will create technically correct, but untrusted certificates.\nFor Let's Encrypt, all staging endpoints can be found here: U(https://letsencrypt.org/docs/staging-environment/). For Buypass, all endpoints can be found here: U(https://community.buypass.com/t/63d4ay/buypass-go-ssl-endpoints)\nFor B(Let's Encrypt), the production directory URL for ACME v2 is U(https://acme-v02.api.letsencrypt.org/directory).\nFor B(Buypass), the production directory URL for ACME v2 and v1 is U(https://api.buypass.com/acme/directory).\nFor B(ZeroSSL), the production directory URL for ACME v2 is U(https://acme.zerossl.com/v2/DV90).\nB(Warning:) So far, the ACME modules have only been tested against Let's Encrypt (staging and production), Buypass (staging and production), ZeroSSL (production), and L(Pebble testing server,https://github.com/letsencrypt/Pebble). If you experience problems with another ACME server, please L(create an issue,https://github.com/ansible-collections/community.crypto/issues/new/choose) to help us supporting it. Feedback that an ACME server not mentioned does work is also appreciated.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "acme_version": {
          "aliases": [],
          "description": "The ACME version of the endpoint.\nMust be C(1) for the classic Let's Encrypt and Buypass ACME endpoints, or C(2) for standardized ACME v2 endpoints.\nThe value C(1) is deprecated since community.crypto 2.0.0 and will be removed from community.crypto 3.0.0.",
          "type": "int",
          "required": true,
          "choices": [
            "1",
            "2"
          ],
          "suboptions": {}
        },
        "certificate": {
          "aliases": [],
          "description": "Path to the certificate to revoke.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "private_key_content": {
          "aliases": [],
          "description": "Content of the certificate's private key.\nNote that exactly one of C(account_key_src), C(account_key_content), C(private_key_src) or C(private_key_content) must be specified.\nI(Warning): the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "private_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the certificate's private key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "private_key_src": {
          "aliases": [],
          "description": "Path to the certificate's private key.\nNote that exactly one of C(account_key_src), C(account_key_content), C(private_key_src) or C(private_key_content) must be specified.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "revoke_reason": {
          "aliases": [],
          "description": "One of the revocation reasonCodes defined in L(Section 5.3.1 of RFC5280,https://tools.ietf.org/html/rfc5280#section-5.3.1).\nPossible values are C(0) (unspecified), C(1) (keyCompromise), C(2) (cACompromise), C(3) (affiliationChanged), C(4) (superseded), C(5) (cessationOfOperation), C(6) (certificateHold), C(8) (removeFromCRL), C(9) (privilegeWithdrawn), C(10) (aACompromise).",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the C(openssl) binary.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "Whether calls to the ACME directory will validate TLS certificates.\nB(Warning:) Should B(only ever) be set to C(no) for testing purposes, for example when testing against a local Pebble server.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "either openssl or L(cryptography,https://cryptography.io/) >= 1.5",
        "ipaddress"
      ],
      "short_description": "Revoke certificates with the ACME protocol"
    },
    "examples": "\n- name: Revoke certificate with account key\n  community.crypto.acme_certificate_revoke:\n    account_key_src: /etc/pki/cert/private/account.key\n    certificate: /etc/httpd/ssl/sample.com.crt\n\n- name: Revoke certificate with certificate's private key\n  community.crypto.acme_certificate_revoke:\n    private_key_src: /etc/httpd/ssl/sample.com.key\n    certificate: /etc/httpd/ssl/sample.com.crt\n"
  },
  "community.crypto.acme_challenge_cert_helper": {
    "doc": {
      "description": "Prepares certificates for ACME challenges such as C(tls-alpn-01).\nThe raw data is provided by the M(community.crypto.acme_certificate) module, and needs to be converted to a certificate to be used for challenge validation. This module provides a simple way to generate the required certificates.",
      "has_action": false,
      "notes": "Does not support C(check_mode).",
      "options": {
        "challenge": {
          "aliases": [],
          "description": "The challenge type.",
          "type": "str",
          "required": true,
          "choices": [
            "tls-alpn-01"
          ],
          "suboptions": {}
        },
        "challenge_data": {
          "aliases": [],
          "description": "The C(challenge_data) entry provided by M(community.crypto.acme_certificate) for the challenge.",
          "type": "dict",
          "required": true,
          "suboptions": {}
        },
        "private_key_content": {
          "aliases": [],
          "description": "Content of the private key to use for this challenge certificate.\nMutually exclusive with C(private_key_src).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "private_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the private key.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "private_key_src": {
          "aliases": [],
          "description": "Path to a file containing the private key file to use for this challenge certificate.\nMutually exclusive with C(private_key_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.3"
      ],
      "short_description": "Prepare certificates required for ACME challenges such as C(tls-alpn-01)"
    },
    "examples": "\n- name: Create challenges for a given CRT for sample.com\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    challenge: tls-alpn-01\n    csr: /etc/pki/cert/csr/sample.com.csr\n    dest: /etc/httpd/ssl/sample.com.crt\n  register: sample_com_challenge\n\n- name: Create certificates for challenges\n  community.crypto.acme_challenge_cert_helper:\n    challenge: tls-alpn-01\n    challenge_data: \"{{ item.value['tls-alpn-01'] }}\"\n    private_key_src: /etc/pki/cert/key/sample.com.key\n  loop: \"{{ sample_com_challenge.challenge_data | dictsort }}\"\n  register: sample_com_challenge_certs\n\n- name: Install challenge certificates\n  # We need to set up HTTPS such that for the domain,\n  # regular_certificate is delivered for regular connections,\n  # except if ALPN selects the \"acme-tls/1\"; then, the\n  # challenge_certificate must be delivered.\n  # This can for example be achieved with very new versions\n  # of NGINX; search for ssl_preread and\n  # ssl_preread_alpn_protocols for information on how to\n  # route by ALPN protocol.\n  ...:\n    domain: \"{{ item.domain }}\"\n    challenge_certificate: \"{{ item.challenge_certificate }}\"\n    regular_certificate: \"{{ item.regular_certificate }}\"\n    private_key: /etc/pki/cert/key/sample.com.key\n  loop: \"{{ sample_com_challenge_certs.results }}\"\n\n- name: Create certificate for a given CSR for sample.com\n  community.crypto.acme_certificate:\n    account_key_src: /etc/pki/cert/private/account.key\n    challenge: tls-alpn-01\n    csr: /etc/pki/cert/csr/sample.com.csr\n    dest: /etc/httpd/ssl/sample.com.crt\n    data: \"{{ sample_com_challenge }}\"\n"
  },
  "community.crypto.acme_inspect": {
    "doc": {
      "description": "Allows to send direct requests to an ACME server with the L(ACME protocol,https://tools.ietf.org/html/rfc8555), which is supported by CAs such as L(Let's Encrypt,https://letsencrypt.org/).\nThis module can be used to debug failed certificate request attempts, for example when M(community.crypto.acme_certificate) fails or encounters a problem which you wish to investigate.\nThe module can also be used to directly access features of an ACME servers which are not yet supported by the Ansible ACME modules.",
      "has_action": false,
      "notes": "The I(account_uri) option must be specified for properly authenticated ACME v2 requests (except a C(new-account) request).\nUsing the C(ansible) tool, M(community.crypto.acme_inspect) can be used to directly execute ACME requests without the need of writing a playbook. For example, the following command retrieves the ACME account with ID 1 from Let's Encrypt (assuming C(/path/to/key) is the correct private account key): C(ansible localhost -m acme_inspect -a \"account_key_src=/path/to/key acme_directory=https://acme-v02.api.letsencrypt.org/directory acme_version=2 account_uri=https://acme-v02.api.letsencrypt.org/acme/acct/1 method=get url=https://acme-v02.api.letsencrypt.org/acme/acct/1\")\nIf a new enough version of the C(cryptography) library is available (see Requirements for details), it will be used instead of the C(openssl) binary. This can be explicitly disabled or enabled with the C(select_crypto_backend) option. Note that using the C(openssl) binary will be slower and less secure, as private key contents always have to be stored on disk (see C(account_key_content)).\nAlthough the defaults are chosen so that the module can be used with the L(Let's Encrypt,https://letsencrypt.org/) CA, the module can in principle be used with any CA providing an ACME endpoint, such as L(Buypass Go SSL,https://www.buypass.com/ssl/products/acme).",
      "options": {
        "account_key_content": {
          "aliases": [],
          "description": "Content of the ACME account RSA or Elliptic Curve key.\nMutually exclusive with C(account_key_src).\nRequired if C(account_key_src) is not used.\nB(Warning:) the content will be written into a temporary file, which will be deleted by Ansible when the module completes. Since this is an important private key — it can be used to change the account key, or to revoke your certificates without knowing their private keys —, this might not be acceptable.\nIn case C(cryptography) is used, the content is not written into a temporary file. It can still happen that it is written to disk by Ansible in the process of moving the module with its argument to the node where it is executed.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "account_key_passphrase": {
          "aliases": [],
          "description": "Phassphrase to use to decode the account key.\nB(Note:) this is not supported by the C(openssl) backend, only by the C(cryptography) backend.",
          "type": "str",
          "required": false,
          "version_added": "1.6.0",
          "suboptions": {}
        },
        "account_key_src": {
          "aliases": [
            "account_key"
          ],
          "description": "Path to a file containing the ACME account RSA or Elliptic Curve key.\nPrivate keys can be created with the M(community.crypto.openssl_privatekey) or M(community.crypto.openssl_privatekey_pipe) modules. If the requisite (cryptography) is not available, keys can also be created directly with the C(openssl) command line tool: RSA keys can be created with C(openssl genrsa ...). Elliptic curve keys can be created with C(openssl ecparam -genkey ...). Any other tool creating private keys in PEM format can be used as well.\nMutually exclusive with C(account_key_content).\nRequired if C(account_key_content) is not used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "account_uri": {
          "aliases": [],
          "description": "If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. This is the entry point URL to access the ACME CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server (for the ACME v1 protocol). This will create technically correct, but untrusted certificates.\nFor Let's Encrypt, all staging endpoints can be found here: U(https://letsencrypt.org/docs/staging-environment/). For Buypass, all endpoints can be found here: U(https://community.buypass.com/t/63d4ay/buypass-go-ssl-endpoints)\nFor B(Let's Encrypt), the production directory URL for ACME v2 is U(https://acme-v02.api.letsencrypt.org/directory).\nFor B(Buypass), the production directory URL for ACME v2 and v1 is U(https://api.buypass.com/acme/directory).\nFor B(ZeroSSL), the production directory URL for ACME v2 is U(https://acme.zerossl.com/v2/DV90).\nB(Warning:) So far, the ACME modules have only been tested against Let's Encrypt (staging and production), Buypass (staging and production), ZeroSSL (production), and L(Pebble testing server,https://github.com/letsencrypt/Pebble). If you experience problems with another ACME server, please L(create an issue,https://github.com/ansible-collections/community.crypto/issues/new/choose) to help us supporting it. Feedback that an ACME server not mentioned does work is also appreciated.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "acme_version": {
          "aliases": [],
          "description": "The ACME version of the endpoint.\nMust be C(1) for the classic Let's Encrypt and Buypass ACME endpoints, or C(2) for standardized ACME v2 endpoints.\nThe value C(1) is deprecated since community.crypto 2.0.0 and will be removed from community.crypto 3.0.0.",
          "type": "int",
          "required": true,
          "choices": [
            "1",
            "2"
          ],
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "An encoded JSON object which will be sent as the content if I(method) is C(post).\nRequired when I(method) is C(post), and not allowed otherwise.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "fail_on_acme_error": {
          "aliases": [],
          "description": "If I(method) is C(post) or C(get), make the module fail in case an ACME error is returned.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "method": {
          "aliases": [],
          "description": "The method to use to access the given URL on the ACME server.\nThe value C(post) executes an authenticated POST request. The content must be specified in the I(content) option.\nThe value C(get) executes an authenticated POST-as-GET request for ACME v2, and a regular GET request for ACME v1.\nThe value C(directory-only) only retrieves the directory, without doing a request.",
          "default": "get",
          "type": "str",
          "required": false,
          "choices": [
            "get",
            "post",
            "directory-only"
          ],
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the C(openssl) binary.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "The URL to send the request to.\nMust be specified if I(method) is not C(directory-only).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "Whether calls to the ACME directory will validate TLS certificates.\nB(Warning:) Should B(only ever) be set to C(no) for testing purposes, for example when testing against a local Pebble server.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "either openssl or L(cryptography,https://cryptography.io/) >= 1.5",
        "ipaddress"
      ],
      "short_description": "Send direct requests to an ACME server"
    },
    "examples": "\n- name: Get directory\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    method: directory-only\n  register: directory\n\n- name: Create an account\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    url: \"{{ directory.newAccount}}\"\n    method: post\n    content: '{\"termsOfServiceAgreed\":true}'\n  register: account_creation\n  # account_creation.headers.location contains the account URI\n  # if creation was successful\n\n- name: Get account information\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ account_creation.headers.location }}\"\n    method: get\n\n- name: Update account contacts\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ account_creation.headers.location }}\"\n    method: post\n    content: '{{ account_info | to_json }}'\n  vars:\n    account_info:\n      # For valid values, see\n      # https://tools.ietf.org/html/rfc8555#section-7.3\n      contact:\n      - mailto:me@example.com\n\n- name: Create certificate order\n  community.crypto.acme_certificate:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    csr: /etc/pki/cert/csr/sample.com.csr\n    fullchain_dest: /etc/httpd/ssl/sample.com-fullchain.crt\n    challenge: http-01\n  register: certificate_request\n\n# Assume something went wrong. certificate_request.order_uri contains\n# the order URI.\n\n- name: Get order information\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ certificate_request.order_uri }}\"\n    method: get\n  register: order\n\n- name: Get first authz for order\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ order.output_json.authorizations[0] }}\"\n    method: get\n  register: authz\n\n- name: Get HTTP-01 challenge for authz\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ authz.output_json.challenges | selectattr('type', 'equalto', 'http-01') }}\"\n    method: get\n  register: http01challenge\n\n- name: Activate HTTP-01 challenge manually\n  community.crypto.acme_inspect:\n    acme_directory: https://acme-staging-v02.api.letsencrypt.org/directory\n    acme_version: 2\n    account_key_src: /etc/pki/cert/private/account.key\n    account_uri: \"{{ account_creation.headers.location }}\"\n    url: \"{{ http01challenge.url }}\"\n    method: post\n    content: '{}'\n"
  },
  "community.crypto.certificate_complete_chain": {
    "doc": {
      "description": "This module completes a given chain of certificates in PEM format by finding intermediate certificates from a given set of certificates, until it finds a root certificate in another given set of certificates.\nThis can for example be used to find the root certificate for a certificate chain returned by M(community.crypto.acme_certificate).\nNote that this module does I(not) check for validity of the chains. It only checks that issuer and subject match, and that the signature is correct. It ignores validity dates and key usage completely. If you need to verify that a generated chain is valid, please use C(openssl verify ...).",
      "has_action": false,
      "options": {
        "input_chain": {
          "aliases": [],
          "description": "A concatenated set of certificates in PEM format forming a chain.\nThe module will try to complete this chain.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "intermediate_certificates": {
          "aliases": [],
          "description": "A list of filenames or directories.\nA filename is assumed to point to a file containing one or more certificates in PEM format. All certificates in this file will be added to the set of root certificates.\nIf a directory name is given, all files in the directory and its subdirectories will be scanned and tried to be parsed as concatenated certificates in PEM format.\nSymbolic links will be followed.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "path",
          "suboptions": {}
        },
        "root_certificates": {
          "aliases": [],
          "description": "A list of filenames or directories.\nA filename is assumed to point to a file containing one or more certificates in PEM format. All certificates in this file will be added to the set of root certificates.\nIf a directory name is given, all files in the directory and its subdirectories will be scanned and tried to be parsed as concatenated certificates in PEM format.\nSymbolic links will be followed.",
          "type": "list",
          "required": true,
          "elements": "path",
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.5"
      ],
      "short_description": "Complete certificate chain given a set of untrusted and root certificates"
    },
    "examples": "\n# Given a leaf certificate for www.ansible.com and one or more intermediate\n# certificates, finds the associated root certificate.\n- name: Find root certificate\n  community.crypto.certificate_complete_chain:\n    input_chain: \"{{ lookup('file', '/etc/ssl/csr/www.ansible.com-fullchain.pem') }}\"\n    root_certificates:\n    - /etc/ca-certificates/\n  register: www_ansible_com\n- name: Write root certificate to disk\n  copy:\n    dest: /etc/ssl/csr/www.ansible.com-root.pem\n    content: \"{{ www_ansible_com.root }}\"\n\n# Given a leaf certificate for www.ansible.com, and a list of intermediate\n# certificates, finds the associated root certificate.\n- name: Find root certificate\n  community.crypto.certificate_complete_chain:\n    input_chain: \"{{ lookup('file', '/etc/ssl/csr/www.ansible.com.pem') }}\"\n    intermediate_certificates:\n    - /etc/ssl/csr/www.ansible.com-chain.pem\n    root_certificates:\n    - /etc/ca-certificates/\n  register: www_ansible_com\n- name: Write complete chain to disk\n  copy:\n    dest: /etc/ssl/csr/www.ansible.com-completechain.pem\n    content: \"{{ ''.join(www_ansible_com.complete_chain) }}\"\n- name: Write root chain (intermediates and root) to disk\n  copy:\n    dest: /etc/ssl/csr/www.ansible.com-rootchain.pem\n    content: \"{{ ''.join(www_ansible_com.chain) }}\"\n"
  },
  "community.crypto.ecs_certificate": {
    "doc": {
      "description": "Create, reissue, and renew certificates with the Entrust Certificate Services (ECS) API.\nRequires credentials for the L(Entrust Certificate Services,https://www.entrustdatacard.com/products/categories/ssl-certificates) (ECS) API.\nIn order to request a certificate, the domain and organization used in the certificate signing request must be already validated in the ECS system. It is I(not) the responsibility of this module to perform those steps.",
      "has_action": false,
      "notes": "C(path) must be specified as the output location of the certificate.",
      "options": {
        "additional_emails": {
          "aliases": [],
          "description": "A list of additional email addresses to receive the delivery notice and expiry notification for the certificate.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Whether a backup should be made for the certificate in I(path).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "cert_expiry": {
          "aliases": [],
          "description": "The date the certificate should be set to expire, in RFC3339 compliant date or date-time format. For example, C(2020-02-23), C(2020-02-23T15:00:00.05Z).\nI(cert_expiry) is only supported for requests of C(request_type=new) or C(request_type=renew). If C(request_type=reissue), I(cert_expiry) will be used for the first certificate issuance, but subsequent issuances will have the same expiry as the initial certificate.\nA reissued certificate will always have the same expiry as the original certificate.\nNote that only the date (day, month, year) is supported for specifying the expiry date. If you choose to specify an expiry time with the expiry date, the time will be adjusted to Eastern Standard Time (EST). This could have the unintended effect of moving your expiry date to the previous day.\nApplies only to accounts with a pooling inventory model.\nOnly one of I(cert_expiry) or I(cert_lifetime) may be specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "cert_lifetime": {
          "aliases": [],
          "description": "The lifetime of the certificate.\nApplies to all certificates for accounts with a non-pooling inventory model.\nI(cert_lifetime) is only supported for requests of C(request_type=new) or C(request_type=renew). If C(request_type=reissue), I(cert_lifetime) will be used for the first certificate issuance, but subsequent issuances will have the same expiry as the initial certificate.\nApplies to certificates of I(cert_type)=C(CDS_INDIVIDUAL, CDS_GROUP, CDS_ENT_LITE, CDS_ENT_PRO, SMIME_ENT) for accounts with a pooling inventory model.\nC(P1Y) is a certificate with a 1 year lifetime.\nC(P2Y) is a certificate with a 2 year lifetime.\nC(P3Y) is a certificate with a 3 year lifetime.\nOnly one of I(cert_expiry) or I(cert_lifetime) may be specified.",
          "type": "str",
          "required": false,
          "choices": [
            "P1Y",
            "P2Y",
            "P3Y"
          ],
          "suboptions": {}
        },
        "cert_type": {
          "aliases": [],
          "description": "Specify the type of certificate requested.\nIf a certificate is being reissued or renewed, this parameter is ignored, and the C(cert_type) of the initial certificate is used.",
          "type": "str",
          "required": false,
          "choices": [
            "STANDARD_SSL",
            "ADVANTAGE_SSL",
            "UC_SSL",
            "EV_SSL",
            "WILDCARD_SSL",
            "PRIVATE_SSL",
            "PD_SSL",
            "CODE_SIGNING",
            "EV_CODE_SIGNING",
            "CDS_INDIVIDUAL",
            "CDS_GROUP",
            "CDS_ENT_LITE",
            "CDS_ENT_PRO",
            "SMIME_ENT"
          ],
          "suboptions": {}
        },
        "client_id": {
          "aliases": [],
          "description": "The client ID to submit the Certificate Signing Request under.\nIf no client ID is specified, the certificate will be submitted under the primary client with ID of 1.\nWhen using a client other than the primary client, the I(org) parameter cannot be specified.\nThe issued certificate will have an organization value in the subject distinguished name represented by the client.",
          "default": "1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "csr": {
          "aliases": [],
          "description": "Base-64 encoded Certificate Signing Request (CSR). I(csr) is accepted with or without PEM formatting around the Base-64 string.\nIf no I(csr) is provided when C(request_type=reissue) or C(request_type=renew), the certificate will be generated with the same public key as the certificate being renewed or reissued.\nIf I(subject_alt_name) is specified, it will override the subject alternate names in the CSR.\nIf I(eku) is specified, it will override the extended key usage in the CSR.\nIf I(ou) is specified, it will override the organizational units \"ou=\" present in the subject distinguished name of the CSR, if any.\nThe organization \"O=\" field from the CSR will not be used. It will be replaced in the issued certificate by I(org) if present, and if not present, the organization tied to I(client_id).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ct_log": {
          "aliases": [],
          "description": "In compliance with browser requirements, this certificate may be posted to the Certificate Transparency (CT) logs. This is a best practice technique that helps domain owners monitor certificates issued to their domains. Note that not all certificates are eligible for CT logging.\nIf I(ct_log) is not specified, the certificate uses the account default.\nIf I(ct_log) is specified and the account settings allow it, I(ct_log) overrides the account default.\nIf I(ct_log) is set to C(false), but the account settings are set to \"always log\", the certificate generation will fail.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "custom_fields": {
          "aliases": [],
          "description": "Mapping of custom fields to associate with the certificate request and certificate.\nOnly supported if custom fields are enabled for your account.\nEach custom field specified must be a custom field you have defined for your account.",
          "type": "dict",
          "required": false,
          "suboptions": {
            "date1": {
              "aliases": [],
              "description": "Custom date field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "date2": {
              "aliases": [],
              "description": "Custom date field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "date3": {
              "aliases": [],
              "description": "Custom date field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "date4": {
              "aliases": [],
              "description": "Custom date field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "date5": {
              "aliases": [],
              "description": "Custom date field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "dropdown1": {
              "aliases": [],
              "description": "Custom dropdown field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "dropdown2": {
              "aliases": [],
              "description": "Custom dropdown field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "dropdown3": {
              "aliases": [],
              "description": "Custom dropdown field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "dropdown4": {
              "aliases": [],
              "description": "Custom dropdown field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "dropdown5": {
              "aliases": [],
              "description": "Custom dropdown field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "email1": {
              "aliases": [],
              "description": "Custom email field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "email2": {
              "aliases": [],
              "description": "Custom email field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "email3": {
              "aliases": [],
              "description": "Custom email field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "email4": {
              "aliases": [],
              "description": "Custom email field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "email5": {
              "aliases": [],
              "description": "Custom email field.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "number1": {
              "aliases": [],
              "description": "Custom number field.",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "number2": {
              "aliases": [],
              "description": "Custom number field.",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "number3": {
              "aliases": [],
              "description": "Custom number field.",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "number4": {
              "aliases": [],
              "description": "Custom number field.",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "number5": {
              "aliases": [],
              "description": "Custom number field.",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "text1": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text10": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text11": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text12": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text13": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text14": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text15": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text2": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text3": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text4": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text5": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text6": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text7": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text8": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "text9": {
              "aliases": [],
              "description": "Custom text field (maximum 500 characters)",
              "type": "str",
              "required": false,
              "suboptions": {}
            }
          }
        },
        "eku": {
          "aliases": [],
          "description": "If specified, overrides the key usage in the I(csr).",
          "type": "str",
          "required": false,
          "choices": [
            "SERVER_AUTH",
            "CLIENT_AUTH",
            "SERVER_AND_CLIENT_AUTH"
          ],
          "suboptions": {}
        },
        "end_user_key_storage_agreement": {
          "aliases": [],
          "description": "The end user of the Code Signing certificate must generate and store the private key for this request on cryptographically secure hardware to be compliant with the Entrust CSP and Subscription agreement. If requesting a certificate of type C(CODE_SIGNING) or C(EV_CODE_SIGNING), you must set I(end_user_key_storage_agreement) to true if and only if you acknowledge that you will inform the user of this requirement.\nApplicable only to I(cert_type) of values C(CODE_SIGNING) and C(EV_CODE_SIGNING).",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_client_cert_key_path": {
          "aliases": [],
          "description": "The path to the key for the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_client_cert_path": {
          "aliases": [],
          "description": "The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_key": {
          "aliases": [],
          "description": "The key (password) for authentication to the Entrust Certificate Services (ECS) API.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_specification_path": {
          "aliases": [],
          "description": "The path to the specification file defining the Entrust Certificate Services (ECS) API configuration.\nYou can use this to keep a local copy of the specification to avoid downloading it every time the module is used.",
          "default": "https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_user": {
          "aliases": [],
          "description": "The username for authentication to the Entrust Certificate Services (ECS) API.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "If force is used, a certificate is requested regardless of whether I(path) points to an existing valid certificate.\nIf C(request_type=renew), a forced renew will fail if the certificate being renewed has been issued within the past 30 days, regardless of the value of I(remaining_days) or the return value of I(cert_days) - the ECS API does not support the \"renew\" operation for certificates that are not at least 30 days old.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "full_chain_path": {
          "aliases": [],
          "description": "The destination path for the full certificate chain of the certificate, intermediates, and roots.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "org": {
          "aliases": [],
          "description": "Organization \"O=\" to include in the certificate.\nIf I(org) is not specified, the organization from the client represented by I(client_id) is used.\nUnless the I(cert_type) is C(PD_SSL), this field may not be specified if the value of I(client_id) is not \"1\" (the primary client). non-primary clients, certificates may only be issued with the organization of that client.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ou": {
          "aliases": [],
          "description": "Organizational unit \"OU=\" to include in the certificate.\nI(ou) behavior is dependent on whether organizational units are enabled for your account. If organizational unit support is disabled for your account, organizational units from the I(csr) and the I(ou) parameter are ignored.\nIf both I(csr) and I(ou) are specified, the value in I(ou) will override the OU fields present in the subject distinguished name in the I(csr)\nIf neither I(csr) nor I(ou) are specified for a renew or reissue operation, the OU fields in the initial certificate are reused.\nAn invalid OU from I(csr) is ignored, but any invalid organizational units in I(ou) will result in an error indicating \"Unapproved OU\". The I(ou) parameter can be used to force failure if an unapproved organizational unit is provided.\nA maximum of one OU may be specified for current products. Multiple OUs are reserved for future products.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The destination path for the generated certificate as a PEM encoded cert.\nIf the certificate at this location is not an Entrust issued certificate, a new certificate will always be requested even if the current certificate is technically valid.\nIf there is already an Entrust certificate at this location, whether it is replaced is depends on the I(remaining_days) calculation.\nIf an existing certificate is being replaced (see I(remaining_days), I(force), and I(tracking_id)), whether a new certificate is requested or the existing certificate is renewed or reissued is based on I(request_type).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "remaining_days": {
          "aliases": [],
          "description": "The number of days the certificate must have left being valid. If C(cert_days < remaining_days) then a new certificate will be obtained using I(request_type).\nIf C(request_type=renew), a renewal will fail if the certificate being renewed has been issued within the past 30 days, so do not set a I(remaining_days) value that is within 30 days of the full lifetime of the certificate being acted upon. (e.g. if you are requesting Certificates with a 90 day lifetime, do not set remaining_days to a value C(60) or higher).\nThe I(force) option may be used to ensure that a new certificate is always obtained.",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "request_type": {
          "aliases": [],
          "description": "The operation performed if I(tracking_id) references a valid certificate to reissue, or there is already a certificate present in I(path) but either I(force) is specified or C(cert_days < remaining_days).\nSpecifying C(request_type=validate_only) means the request will be validated against the ECS API, but no certificate will be issued.\nSpecifying C(request_type=new) means a certificate request will always be submitted and a new certificate issued.\nSpecifying C(request_type=renew) means that an existing certificate (specified by I(tracking_id) if present, otherwise I(path)) will be renewed. If there is no certificate to renew, a new certificate is requested.\nSpecifying C(request_type=reissue) means that an existing certificate (specified by I(tracking_id) if present, otherwise I(path)) will be reissued. If there is no certificate to reissue, a new certificate is requested.\nIf a certificate was issued within the past 30 days, the 'renew' operation is not a valid operation and will fail.\nNote that C(reissue) is an operation that will result in the revocation of the certificate that is reissued, be cautious with it's use.\nI(check_mode) is only supported if C(request_type=new)\nFor example, setting C(request_type=renew) and C(remaining_days=30) and pointing to the same certificate on multiple playbook runs means that on the first run new certificate will be requested. It will then be left along on future runs until it is within 30 days of expiry, then the ECS \"renew\" operation will be performed.",
          "default": "new",
          "type": "str",
          "required": false,
          "choices": [
            "new",
            "renew",
            "reissue",
            "validate_only"
          ],
          "suboptions": {}
        },
        "requester_email": {
          "aliases": [],
          "description": "The requester email to associate with certificate tracking information and receive delivery and expiry notices for the certificate.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "requester_name": {
          "aliases": [],
          "description": "The requester name to associate with certificate tracking information.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "requester_phone": {
          "aliases": [],
          "description": "The requester phone number to associate with certificate tracking information.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "subject_alt_name": {
          "aliases": [],
          "description": "The subject alternative name identifiers, as an array of values (applies to I(cert_type) with a value of C(STANDARD_SSL), C(ADVANTAGE_SSL), C(UC_SSL), C(EV_SSL), C(WILDCARD_SSL), C(PRIVATE_SSL), and C(PD_SSL)).\nIf you are requesting a new SSL certificate, and you pass a I(subject_alt_name) parameter, any SAN names in the CSR are ignored. If no subjectAltName parameter is passed, the SAN names in the CSR are used.\nSee I(request_type) to understand more about SANs during reissues and renewals.\nIn the case of certificates of type C(STANDARD_SSL) certificates, if the CN of the certificate is <domain>.<tld> only the www.<domain>.<tld> value is accepted. If the CN of the certificate is www.<domain>.<tld> only the <domain>.<tld> value is accepted.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "tracking_id": {
          "aliases": [],
          "description": "The tracking ID of the certificate to reissue or renew.\nI(tracking_id) is invalid if C(request_type=new) or C(request_type=validate_only).\nIf there is a certificate present in I(path) and it is an ECS certificate, I(tracking_id) will be ignored.\nIf there is no certificate present in I(path) or there is but it is from another provider, the certificate represented by I(tracking_id) will be renewed or reissued and saved to I(path).\nIf there is no certificate present in I(path) and the I(force) and I(remaining_days) parameters do not indicate a new certificate is needed, the certificate referenced by I(tracking_id) certificate will be saved to I(path).\nThis can be used when a known certificate is not currently present on a server, but you want to renew or reissue it to be managed by an ansible playbook. For example, if you specify C(request_type=renew), I(tracking_id) of an issued certificate, and I(path) to a file that does not exist, the first run of a task will download the certificate specified by I(tracking_id) (assuming it is still valid). Future runs of the task will (if applicable - see I(force) and I(remaining_days)) renew the certificate now present in I(path).",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "tracking_info": {
          "aliases": [],
          "description": "Free form tracking information to attach to the record for the certificate.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "PyYAML >= 3.11",
        "cryptography >= 1.6"
      ],
      "short_description": "Request SSL/TLS certificates with the Entrust Certificate Services (ECS) API"
    },
    "examples": "\n- name: Request a new certificate from Entrust with bare minimum parameters.\n        Will request a new certificate if current one is valid but within 30\n        days of expiry. If replacing an existing file in path, will back it up.\n  community.crypto.ecs_certificate:\n    backup: true\n    path: /etc/ssl/crt/ansible.com.crt\n    full_chain_path: /etc/ssl/crt/ansible.com.chain.crt\n    csr: /etc/ssl/csr/ansible.com.csr\n    cert_type: EV_SSL\n    requester_name: Jo Doe\n    requester_email: jdoe@ansible.com\n    requester_phone: 555-555-5555\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: If there is no certificate present in path, request a new certificate\n        of type EV_SSL. Otherwise, if there is an Entrust managed certificate\n        in path and it is within 63 days of expiration, request a renew of that\n        certificate.\n  community.crypto.ecs_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr: /etc/ssl/csr/ansible.com.csr\n    cert_type: EV_SSL\n    cert_expiry: '2020-08-20'\n    request_type: renew\n    remaining_days: 63\n    requester_name: Jo Doe\n    requester_email: jdoe@ansible.com\n    requester_phone: 555-555-5555\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: If there is no certificate present in path, download certificate\n        specified by tracking_id if it is still valid. Otherwise, if the\n        certificate is within 79 days of expiration, request a renew of that\n        certificate and save it in path. This can be used to \"migrate\" a\n        certificate to be Ansible managed.\n  community.crypto.ecs_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr: /etc/ssl/csr/ansible.com.csr\n    tracking_id: 2378915\n    request_type: renew\n    remaining_days: 79\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Force a reissue of the certificate specified by tracking_id.\n  community.crypto.ecs_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    force: true\n    tracking_id: 2378915\n    request_type: reissue\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Request a new certificate with an alternative client. Note that the\n        issued certificate will have it's Subject Distinguished Name use the\n        organization details associated with that client, rather than what is\n        in the CSR.\n  community.crypto.ecs_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr: /etc/ssl/csr/ansible.com.csr\n    client_id: 2\n    requester_name: Jo Doe\n    requester_email: jdoe@ansible.com\n    requester_phone: 555-555-5555\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Request a new certificate with a number of CSR parameters overridden\n        and tracking information\n  community.crypto.ecs_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    full_chain_path: /etc/ssl/crt/ansible.com.chain.crt\n    csr: /etc/ssl/csr/ansible.com.csr\n    subject_alt_name:\n      - ansible.testcertificates.com\n      - www.testcertificates.com\n    eku: SERVER_AND_CLIENT_AUTH\n    ct_log: true\n    org: Test Organization Inc.\n    ou:\n      - Administration\n    tracking_info: \"Submitted via Ansible\"\n    additional_emails:\n      - itsupport@testcertificates.com\n      - jsmith@ansible.com\n    custom_fields:\n      text1: Admin\n      text2: Invoice 25\n      number1: 342\n      date1: '2018-01-01'\n      email1: sales@ansible.testcertificates.com\n      dropdown1: red\n    cert_expiry: '2020-08-15'\n    requester_name: Jo Doe\n    requester_email: jdoe@ansible.com\n    requester_phone: 555-555-5555\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n"
  },
  "community.crypto.ecs_domain": {
    "doc": {
      "description": "Request validation or re-validation of a domain with the Entrust Certificate Services (ECS) API.\nRequires credentials for the L(Entrust Certificate Services,https://www.entrustdatacard.com/products/categories/ssl-certificates) (ECS) API.\nIf the domain is already in the validation process, no new validation will be requested, but the validation data (if applicable) will be returned.\nIf the domain is already in the validation process but the I(verification_method) specified is different than the current I(verification_method), the I(verification_method) will be updated and validation data (if applicable) will be returned.\nIf the domain is an active, validated domain, the return value of I(changed) will be false, unless C(domain_status=EXPIRED), in which case a re-validation will be performed.\nIf C(verification_method=dns), details about the required DNS entry will be specified in the return parameters I(dns_contents), I(dns_location), and I(dns_resource_type).\nIf C(verification_method=web_server), details about the required file details will be specified in the return parameters I(file_contents) and I(file_location).\nIf C(verification_method=email), the email address(es) that the validation email(s) were sent to will be in the return parameter I(emails). This is purely informational. For domains requested using this module, this will always be a list of size 1.",
      "has_action": false,
      "notes": "There is a small delay (typically about 5 seconds, but can be as long as 60 seconds) before obtaining the random values when requesting a validation while C(verification_method=dns) or C(verification_method=web_server). Be aware of that if doing many domain validation requests.",
      "options": {
        "client_id": {
          "aliases": [],
          "description": "The client ID to request the domain be associated with.\nIf no client ID is specified, the domain will be added under the primary client with ID of 1.",
          "default": "1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "domain_name": {
          "aliases": [],
          "description": "The domain name to be verified or reverified.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_client_cert_key_path": {
          "aliases": [],
          "description": "The path to the key for the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_client_cert_path": {
          "aliases": [],
          "description": "The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_key": {
          "aliases": [],
          "description": "The key (password) for authentication to the Entrust Certificate Services (ECS) API.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "entrust_api_specification_path": {
          "aliases": [],
          "description": "The path to the specification file defining the Entrust Certificate Services (ECS) API configuration.\nYou can use this to keep a local copy of the specification to avoid downloading it every time the module is used.",
          "default": "https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_user": {
          "aliases": [],
          "description": "The username for authentication to the Entrust Certificate Services (ECS) API.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "verification_email": {
          "aliases": [],
          "description": "Email address to be used to verify domain ownership.\nEmail address must be either an email address present in the WHOIS data for I(domain_name), or one of the following constructed emails: admin@I(domain_name), administrator@I(domain_name), webmaster@I(domain_name), hostmaster@I(domain_name), postmaster@I(domain_name)\nNote that if I(domain_name) includes subdomains, the top level domain should be used. For example, if requesting validation of example1.ansible.com, or test.example2.ansible.com, and you want to use the \"admin\" preconstructed name, the email address should be admin@ansible.com.\nIf using the email values from the WHOIS data for the domain or it's top level namespace, they must be exact matches.\nIf C(verification_method=email) but I(verification_email) is not provided, the first email address found in WHOIS data for the domain will be used.\nTo verify domain ownership, domain owner must follow the instructions in the email they receive.\nOnly allowed if C(verification_method=email)",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "verification_method": {
          "aliases": [],
          "description": "The verification method to be used to prove control of the domain.\nIf C(verification_method=email) and the value I(verification_email) is specified, that value is used for the email validation. If I(verification_email) is not provided, the first value present in WHOIS data will be used. An email will be sent to the address in I(verification_email) with instructions on how to verify control of the domain.\nIf C(verification_method=dns), the value I(dns_contents) must be stored in location I(dns_location), with a DNS record type of I(verification_dns_record_type). To prove domain ownership, update your DNS records so the text string returned by I(dns_contents) is available at I(dns_location).\nIf C(verification_method=web_server), the contents of return value I(file_contents) must be made available on a web server accessible at location I(file_location).\nIf C(verification_method=manual), the domain will be validated with a manual process. This is not recommended.",
          "type": "str",
          "required": true,
          "choices": [
            "dns",
            "email",
            "manual",
            "web_server"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "PyYAML >= 3.11"
      ],
      "short_description": "Request validation of a domain with the Entrust Certificate Services (ECS) API",
      "version_added": "1.0.0"
    },
    "examples": "\n- name: Request domain validation using email validation for client ID of 2.\n  community.crypto.ecs_domain:\n    domain_name: ansible.com\n    client_id: 2\n    verification_method: email\n    verification_email: admin@ansible.com\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Request domain validation using DNS. If domain is already valid,\n        request revalidation if expires within 90 days\n  community.crypto.ecs_domain:\n    domain_name: ansible.com\n    verification_method: dns\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Request domain validation using web server validation, and revalidate\n        if fewer than 60 days remaining of EV eligibility.\n  community.crypto.ecs_domain:\n    domain_name: ansible.com\n    verification_method: web_server\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n\n- name: Request domain validation using manual validation.\n  community.crypto.ecs_domain:\n    domain_name: ansible.com\n    verification_method: manual\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-client.key\n"
  },
  "community.crypto.get_certificate": {
    "doc": {
      "description": "Makes a secure connection and returns information about the presented certificate\nThe module uses the cryptography Python library.\nSupport SNI (L(Server Name Indication,https://en.wikipedia.org/wiki/Server_Name_Indication)) only with python >= 2.7.",
      "has_action": false,
      "notes": "When using ca_cert on OS X it has been reported that in some conditions the validate will always succeed.",
      "options": {
        "ca_cert": {
          "aliases": [],
          "description": "A PEM file containing one or more root certificates; if present, the cert will be validated against these root certs.\nNote that this only validates the certificate is signed by the chain; not that the cert is valid for the host presenting it.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "host": {
          "aliases": [],
          "description": "The host to get the cert for (IP is fine)",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "port": {
          "aliases": [],
          "description": "The port to connect to",
          "type": "int",
          "required": true,
          "suboptions": {}
        },
        "proxy_host": {
          "aliases": [],
          "description": "Proxy host used when get a certificate.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_port": {
          "aliases": [],
          "description": "Proxy port used when get a certificate.",
          "default": "8080",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "server_name": {
          "aliases": [],
          "description": "Server name used for SNI (L(Server Name Indication,https://en.wikipedia.org/wiki/Server_Name_Indication)) when hostname is an IP or is different from server name.",
          "type": "str",
          "required": false,
          "version_added": "1.4.0",
          "suboptions": {}
        },
        "starttls": {
          "aliases": [],
          "description": "Requests a secure connection for protocols which require clients to initiate encryption.\nOnly available for C(mysql) currently.",
          "type": "str",
          "required": false,
          "choices": [
            "mysql"
          ],
          "version_added": "1.9.0",
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "The timeout in seconds",
          "default": "10",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "python >= 2.7 when using C(proxy_host)",
        "cryptography >= 1.6"
      ],
      "short_description": "Get a certificate from a host:port"
    },
    "examples": "\n- name: Get the cert from an RDP port\n  community.crypto.get_certificate:\n    host: \"1.2.3.4\"\n    port: 3389\n  delegate_to: localhost\n  run_once: true\n  register: cert\n\n- name: Get a cert from an https port\n  community.crypto.get_certificate:\n    host: \"www.google.com\"\n    port: 443\n  delegate_to: localhost\n  run_once: true\n  register: cert\n\n- name: How many days until cert expires\n  debug:\n    msg: \"cert expires in: {{ expire_days }} days.\"\n  vars:\n    expire_days: \"{{ (( cert.not_after | to_datetime('%Y%m%d%H%M%SZ')) - (ansible_date_time.iso8601 | to_datetime('%Y-%m-%dT%H:%M:%SZ')) ).days }}\"\n"
  },
  "community.crypto.luks_device": {
    "doc": {
      "description": "Module manages L(LUKS,https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup) on given device. Supports creating, destroying, opening and closing of LUKS container and adding or removing new keys and passphrases.",
      "has_action": false,
      "options": {
        "cipher": {
          "aliases": [],
          "description": "This option allows the user to define the cipher specification string for the LUKS container.\nWill only be used on container creation.\nFor pre-2.6.10 kernels, use C(aes-plain) as they don't understand the new cipher spec strings. To use ESSIV, use C(aes-cbc-essiv:sha256).",
          "type": "str",
          "required": false,
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "device": {
          "aliases": [],
          "description": "Device to work with (e.g. C(/dev/sda1)). Needed in most cases. Can be omitted only when I(state=closed) together with I(name) is provided.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force_remove_last_key": {
          "aliases": [],
          "description": "If set to C(yes), allows removing the last key from a container.\nBEWARE that when the last key has been removed from a container, the container can no longer be opened!",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "hash": {
          "aliases": [],
          "description": "This option allows the user to specify the hash function used in LUKS key setup scheme and volume key digest.\nWill only be used on container creation.",
          "type": "str",
          "required": false,
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "keyfile": {
          "aliases": [],
          "description": "Used to unlock the container. Either a I(keyfile) or a I(passphrase) is needed for most of the operations. Parameter value is the path to the keyfile with the passphrase.\nBEWARE that working with keyfiles in plaintext is dangerous. Make sure that they are protected.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "keysize": {
          "aliases": [],
          "description": "Sets the key size only if LUKS container does not exist.",
          "type": "int",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "label": {
          "aliases": [],
          "description": "This option allow the user to create a LUKS2 format container with label support, respectively to identify the container by label on later usages.\nWill only be used on container creation, or when I(device) is not specified.\nThis cannot be specified if I(type) is set to C(luks1).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Sets container name when I(state=opened). Can be used instead of I(device) when closing the existing container (i.e. when I(state=closed)).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "new_keyfile": {
          "aliases": [],
          "description": "Adds additional key to given container on I(device). Needs I(keyfile) or I(passphrase) option for authorization. LUKS container supports up to 8 keyslots. Parameter value is the path to the keyfile with the passphrase.\nNOTE that adding additional keys is idempotent only since community.crypto 1.4.0. For older versions, a new keyslot will be used even if another keyslot already exists for this keyfile.\nBEWARE that working with keyfiles in plaintext is dangerous. Make sure that they are protected.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "new_passphrase": {
          "aliases": [],
          "description": "Adds additional passphrase to given container on I(device). Needs I(keyfile) or I(passphrase) option for authorization. LUKS container supports up to 8 keyslots. Parameter value is a string with the new passphrase.\nNOTE that adding additional passphrase is idempotent only since community.crypto 1.4.0. For older versions, a new keyslot will be used even if another keyslot already exists for this passphrase.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "Used to unlock the container. Either a I(passphrase) or a I(keyfile) is needed for most of the operations. Parameter value is a string with the passphrase.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "pbkdf": {
          "aliases": [],
          "description": "This option allows the user to configure the Password-Based Key Derivation Function (PBKDF) used.\nWill only be used on container creation, and when adding keys to an existing container.",
          "type": "dict",
          "required": false,
          "version_added": "1.4.0",
          "suboptions": {
            "algorithm": {
              "aliases": [],
              "description": "The algorithm to use.\nOnly available for the LUKS 2 format.",
              "type": "str",
              "required": false,
              "choices": [
                "argon2i",
                "argon2id",
                "pbkdf2"
              ],
              "suboptions": {}
            },
            "iteration_count": {
              "aliases": [],
              "description": "Specify the iteration count used for the PBKDF.\nMutually exclusive with I(iteration_time).",
              "type": "int",
              "required": false,
              "suboptions": {}
            },
            "iteration_time": {
              "aliases": [],
              "description": "Specify the iteration time used for the PBKDF.\nNote that this is in B(seconds), not in milliseconds as on the command line.\nMutually exclusive with I(iteration_count).",
              "type": "float",
              "required": false,
              "suboptions": {}
            },
            "memory": {
              "aliases": [],
              "description": "The memory cost limit in kilobytes for the PBKDF.\nThis is not used for PBKDF2, but only for the Argon PBKDFs.",
              "type": "int",
              "required": false,
              "suboptions": {}
            },
            "parallel": {
              "aliases": [],
              "description": "The parallel cost for the PBKDF. This is the number of threads that run in parallel.\nThis is not used for PBKDF2, but only for the Argon PBKDFs.",
              "type": "int",
              "required": false,
              "suboptions": {}
            }
          }
        },
        "remove_keyfile": {
          "aliases": [],
          "description": "Removes given key from the container on I(device). Does not remove the keyfile from filesystem. Parameter value is the path to the keyfile with the passphrase.\nNOTE that removing keys is idempotent only since community.crypto 1.4.0. For older versions, trying to remove a key which no longer exists results in an error.\nNOTE that to remove the last key from a LUKS container, the I(force_remove_last_key) option must be set to C(yes).\nBEWARE that working with keyfiles in plaintext is dangerous. Make sure that they are protected.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "remove_passphrase": {
          "aliases": [],
          "description": "Removes given passphrase from the container on I(device). Parameter value is a string with the passphrase to remove.\nNOTE that removing passphrases is idempotent only since community.crypto 1.4.0. For older versions, trying to remove a passphrase which no longer exists results in an error.\nNOTE that to remove the last keyslot from a LUKS container, the I(force_remove_last_key) option must be set to C(yes).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "sector_size": {
          "aliases": [],
          "description": "This option allows the user to specify the sector size (in bytes) used for LUKS2 containers.\nWill only be used on container creation.",
          "type": "int",
          "required": false,
          "version_added": "1.5.0",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Desired state of the LUKS container. Based on its value creates, destroys, opens or closes the LUKS container on a given device.\nI(present) will create LUKS container unless already present. Requires I(device) and either I(keyfile) or I(passphrase) options to be provided.\nI(absent) will remove existing LUKS container if it exists. Requires I(device) or I(name) to be specified.\nI(opened) will unlock the LUKS container. If it does not exist it will be created first. Requires I(device) and either I(keyfile) or I(passphrase) to be specified. Use the I(name) option to set the name of the opened container.  Otherwise the name will be generated automatically and returned as a part of the result.\nI(closed) will lock the LUKS container. However if the container does not exist it will be created. Requires I(device) and either I(keyfile) or I(passphrase) options to be provided. If container does already exist I(device) or I(name) will suffice.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent",
            "opened",
            "closed"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "This option allow the user explicit define the format of LUKS container that wants to work with. Options are C(luks1) or C(luks2)",
          "type": "str",
          "required": false,
          "choices": [
            "luks1",
            "luks2"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "uuid": {
          "aliases": [],
          "description": "With this option user can identify the LUKS container by UUID.\nWill only be used when I(device) and I(label) are not specified.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptsetup",
        "wipefs (when I(state) is C(absent))",
        "lsblk",
        "blkid (when I(label) or I(uuid) options are used)"
      ],
      "short_description": "Manage encrypted (LUKS) devices"
    },
    "examples": "\n\n- name: Create LUKS container (remains unchanged if it already exists)\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    keyfile: \"/vault/keyfile\"\n\n- name: Create LUKS container with a passphrase\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    passphrase: \"foo\"\n\n- name: Create LUKS container with specific encryption\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    cipher: \"aes\"\n    hash: \"sha256\"\n\n- name: (Create and) open the LUKS container; name it \"mycrypt\"\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"opened\"\n    name: \"mycrypt\"\n    keyfile: \"/vault/keyfile\"\n\n- name: Close the existing LUKS container \"mycrypt\"\n  community.crypto.luks_device:\n    state: \"closed\"\n    name: \"mycrypt\"\n\n- name: Make sure LUKS container exists and is closed\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"closed\"\n    keyfile: \"/vault/keyfile\"\n\n- name: Create container if it does not exist and add new key to it\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    keyfile: \"/vault/keyfile\"\n    new_keyfile: \"/vault/keyfile2\"\n\n- name: Add new key to the LUKS container (container has to exist)\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    keyfile: \"/vault/keyfile\"\n    new_keyfile: \"/vault/keyfile2\"\n\n- name: Add new passphrase to the LUKS container\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    keyfile: \"/vault/keyfile\"\n    new_passphrase: \"foo\"\n\n- name: Remove existing keyfile from the LUKS container\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    remove_keyfile: \"/vault/keyfile2\"\n\n- name: Remove existing passphrase from the LUKS container\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    remove_passphrase: \"foo\"\n\n- name: Completely remove the LUKS container and its contents\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"absent\"\n\n- name: Create a container with label\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    keyfile: \"/vault/keyfile\"\n    label: personalLabelName\n\n- name: Open the LUKS container based on label without device; name it \"mycrypt\"\n  community.crypto.luks_device:\n    label: \"personalLabelName\"\n    state: \"opened\"\n    name: \"mycrypt\"\n    keyfile: \"/vault/keyfile\"\n\n- name: Close container based on UUID\n  community.crypto.luks_device:\n    uuid: 03ecd578-fad4-4e6c-9348-842e3e8fa340\n    state: \"closed\"\n    name: \"mycrypt\"\n\n- name: Create a container using luks2 format\n  community.crypto.luks_device:\n    device: \"/dev/loop0\"\n    state: \"present\"\n    keyfile: \"/vault/keyfile\"\n    type: luks2\n"
  },
  "community.crypto.openssh_cert": {
    "doc": {
      "description": "Generate and regenerate OpenSSH host or user certificates.",
      "has_action": false,
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the certificate be regenerated even if it already exists and is valid.\nEquivalent to I(regenerate=always).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "identifier": {
          "aliases": [],
          "description": "Specify the key identity when signing a public key. The identifier that is logged by the server when the certificate is used for authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "options": {
          "aliases": [],
          "description": "Specify certificate options when signing a key. The option that are valid for user certificates are:\nC(clear): Clear all enabled permissions.  This is useful for clearing the default set of permissions so permissions may be added individually.\nC(force-command=command): Forces the execution of command instead of any shell or command specified by the user when the certificate is used for authentication.\nC(no-agent-forwarding): Disable ssh-agent forwarding (permitted by default).\nC(no-port-forwarding): Disable port forwarding (permitted by default).\nC(no-pty): Disable PTY allocation (permitted by default).\nC(no-user-rc): Disable execution of C(~/.ssh/rc) by sshd (permitted by default).\nC(no-x11-forwarding): Disable X11 forwarding (permitted by default)\nC(permit-agent-forwarding): Allows ssh-agent forwarding.\nC(permit-port-forwarding): Allows port forwarding.\nC(permit-pty): Allows PTY allocation.\nC(permit-user-rc): Allows execution of C(~/.ssh/rc) by sshd.\nC(permit-x11-forwarding): Allows X11 forwarding.\nC(source-address=address_list): Restrict the source addresses from which the certificate is considered valid. The C(address_list) is a comma-separated list of one or more address/netmask pairs in CIDR format.\nAt present, no options are valid for host keys.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Path of the file containing the certificate.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "pkcs11_provider": {
          "aliases": [],
          "description": "To use a signing key that resides on a PKCS#11 token, set this to the name (or full path) of the shared library to use with the token. Usually C(libpkcs11.so).\nIf this is set, I(signing_key) needs to point to a file containing the public key of the CA.",
          "type": "str",
          "required": false,
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "principals": {
          "aliases": [],
          "description": "Certificates may be limited to be valid for a set of principal (user/host) names. By default, generated certificates are valid for all users or hosts.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "public_key": {
          "aliases": [],
          "description": "The path to the public key that will be signed with the signing key in order to generate the certificate.\nRequired if I(state) is C(present).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "regenerate": {
          "aliases": [],
          "description": "When C(never) the task will fail if a certificate already exists at I(path) and is unreadable otherwise a new certificate will only be generated if there is no existing certificate.\nWhen C(fail) the task will fail if a certificate already exists at I(path) and does not match the module's options.\nWhen C(partial_idempotence) an existing certificate will be regenerated based on I(serial), I(signature_algorithm), I(type), I(valid_from), I(valid_to), I(valid_at), and I(principals).\nWhen C(full_idempotence) I(identifier), I(options), I(public_key), and I(signing_key) are also considered when compared against an existing certificate.\nC(always) is equivalent to I(force=true).",
          "default": "partial_idempotence",
          "type": "str",
          "required": false,
          "choices": [
            "never",
            "fail",
            "partial_idempotence",
            "full_idempotence",
            "always"
          ],
          "version_added": "1.8.0",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serial_number": {
          "aliases": [],
          "description": "Specify the certificate serial number. The serial number is logged by the server when the certificate is used for authentication. The certificate serial number may be used in a KeyRevocationList. The serial number may be omitted for checks, but must be specified again for a new certificate. Note: The default value set by ssh-keygen is 0.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "signature_algorithm": {
          "aliases": [],
          "description": "As of OpenSSH 8.2 the SHA-1 signature algorithm for RSA keys has been disabled and C(ssh) will refuse host certificates signed with the SHA-1 algorithm. OpenSSH 8.1 made C(rsa-sha2-512) the default algorithm when acting as a CA and signing certificates with a RSA key. However, for OpenSSH versions less than 8.1 the SHA-2 signature algorithms, C(rsa-sha2-256) or C(rsa-sha2-512), must be specified using this option if compatibility with newer C(ssh) clients is required. Conversely if hosts using OpenSSH version 8.2 or greater must remain compatible with C(ssh) clients using OpenSSH less than 7.2, then C(ssh-rsa) can be used when generating host certificates (a corresponding change to the sshd_config to add C(ssh-rsa) to the C(CASignatureAlgorithms) keyword is also required).\nUsing any value for this option with a non-RSA I(signing_key) will cause this module to fail.\nNote: OpenSSH versions prior to 7.2 do not support SHA-2 signature algorithms for RSA keys and OpenSSH versions prior to 7.3 do not support SHA-2 signature algorithms for certificates.\nSee U(https://www.openssh.com/txt/release-8.2) for more information.",
          "type": "str",
          "required": false,
          "choices": [
            "ssh-rsa",
            "rsa-sha2-256",
            "rsa-sha2-512"
          ],
          "version_added": "1.10.0",
          "suboptions": {}
        },
        "signing_key": {
          "aliases": [],
          "description": "The path to the private openssh key that is used for signing the public key in order to generate the certificate.\nIf the private key is on a PKCS#11 token (I(pkcs11_provider)), set this to the path to the public key instead.\nRequired if I(state) is C(present).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the host or user certificate should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "Whether the module should generate a host or a user certificate.\nRequired if I(state) is C(present).",
          "type": "str",
          "required": false,
          "choices": [
            "host",
            "user"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "use_agent": {
          "aliases": [],
          "description": "Should the ssh-keygen use a CA key residing in a ssh-agent.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.3.0",
          "suboptions": {}
        },
        "valid_at": {
          "aliases": [],
          "description": "Check if the certificate is valid at a certain point in time. If it is not the certificate will be regenerated. Time will always be interpreted as UTC. Mainly to be used with relative timespec for I(valid_from) and / or I(valid_to). Note that if using relative time this module is NOT idempotent.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "valid_from": {
          "aliases": [],
          "description": "The point in time the certificate is valid from. Time can be specified either as relative time or as absolute timestamp. Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY-MM-DD | YYYY-MM-DDTHH:MM:SS | YYYY-MM-DD HH:MM:SS | always) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h). Note that if using relative time this module is NOT idempotent.\nRequired if I(state) is C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "valid_to": {
          "aliases": [],
          "description": "The point in time the certificate is valid to. Time can be specified either as relative time or as absolute timestamp. Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY-MM-DD | YYYY-MM-DDTHH:MM:SS | YYYY-MM-DD HH:MM:SS | forever) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h). Note that if using relative time this module is NOT idempotent.\nRequired if I(state) is C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "ssh-keygen"
      ],
      "short_description": "Generate OpenSSH host or user certificates."
    },
    "examples": "\n- name: Generate an OpenSSH user certificate that is valid forever and for all users\n  community.crypto.openssh_cert:\n    type: user\n    signing_key: /path/to/private_key\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: always\n    valid_to: forever\n\n# Generate an OpenSSH host certificate that is valid for 32 weeks from now and will be regenerated\n# if it is valid for less than 2 weeks from the time the module is being run\n- name: Generate an OpenSSH host certificate with valid_from, valid_to and valid_at parameters\n  community.crypto.openssh_cert:\n    type: host\n    signing_key: /path/to/private_key\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: +0s\n    valid_to: +32w\n    valid_at: +2w\n\n- name: Generate an OpenSSH host certificate that is valid forever and only for example.com and examplehost\n  community.crypto.openssh_cert:\n    type: host\n    signing_key: /path/to/private_key\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: always\n    valid_to: forever\n    principals:\n        - example.com\n        - examplehost\n\n- name: Generate an OpenSSH host Certificate that is valid from 21.1.2001 to 21.1.2019\n  community.crypto.openssh_cert:\n    type: host\n    signing_key: /path/to/private_key\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: \"2001-01-21\"\n    valid_to: \"2019-01-21\"\n\n- name: Generate an OpenSSH user Certificate with clear and force-command option\n  community.crypto.openssh_cert:\n    type: user\n    signing_key: /path/to/private_key\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: always\n    valid_to: forever\n    options:\n        - \"clear\"\n        - \"force-command=/tmp/bla/foo\"\n\n- name: Generate an OpenSSH user certificate using a PKCS#11 token\n  community.crypto.openssh_cert:\n    type: user\n    signing_key: /path/to/ca_public_key.pub\n    pkcs11_provider: libpkcs11.so\n    public_key: /path/to/public_key.pub\n    path: /path/to/certificate\n    valid_from: always\n    valid_to: forever\n\n"
  },
  "community.crypto.openssh_keypair": {
    "doc": {
      "description": "This module allows one to (re)generate OpenSSH private and public keys. It uses ssh-keygen to generate keys. One can generate C(rsa), C(dsa), C(rsa1), C(ed25519) or C(ecdsa) private keys.",
      "has_action": false,
      "notes": "In case the ssh key is broken or password protected, the module will fail. Set the I(force) option to C(yes) if you want to regenerate the keypair.\nSupports C(check_mode).\nIn the case a custom C(mode), C(group), C(owner), or other file attribute is provided it will be applied to both key files.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backend": {
          "aliases": [],
          "description": "Selects between the C(cryptography) library or the OpenSSH binary C(opensshbin).\nC(auto) will default to C(opensshbin) unless the OpenSSH binary is not installed or when using I(passphrase).",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "opensshbin"
          ],
          "version_added": "1.7.0",
          "suboptions": {}
        },
        "comment": {
          "aliases": [],
          "description": "Provides a new comment to the public key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the key be regenerated even if it already exists",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "Passphrase used to decrypt an existing private key or encrypt a newly generated private key.\nPassphrases are not supported for I(type=rsa1).\nCan only be used when I(backend=cryptography), or when I(backend=auto) and a required C(cryptography) version is installed.",
          "type": "str",
          "required": false,
          "version_added": "1.7.0",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Name of the files containing the public and private key. The file containing the public key will have the extension C(.pub).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "private_key_format": {
          "aliases": [],
          "description": "Used when a I(backend=cryptography) to select a format for the private key at the provided I(path).\nThe only valid option currently is C(auto) which will match the key format of the installed OpenSSH version.\nFor OpenSSH < 7.8 private keys will be in PKCS1 format except ed25519 keys which will be in OpenSSH format.\nFor OpenSSH >= 7.8 all private key types will be in the OpenSSH format.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto"
          ],
          "version_added": "1.7.0",
          "suboptions": {}
        },
        "regenerate": {
          "aliases": [],
          "description": "Allows to configure in which situations the module is allowed to regenerate private keys. The module will always generate a new key if the destination file does not exist.\nBy default, the key will be regenerated when it does not match the module's options, except when the key cannot be read or the passphrase does not match. Please note that this B(changed) for Ansible 2.10. For Ansible 2.9, the behavior was as if C(full_idempotence) is specified.\nIf set to C(never), the module will fail if the key cannot be read or the passphrase isn't matching, and will never regenerate an existing key.\nIf set to C(fail), the module will fail if the key does not correspond to the module's options.\nIf set to C(partial_idempotence), the key will be regenerated if it does not conform to the module's options. The key is B(not) regenerated if it cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified.\nIf set to C(full_idempotence), the key will be regenerated if it does not conform to the module's options. This is also the case if the key cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified. Make sure you have a B(backup) when using this option!\nIf set to C(always), the module will always regenerate the key. This is equivalent to setting I(force) to C(yes).\nNote that adjusting the comment and the permissions can be changed without regeneration. Therefore, even for C(never), the task can result in changed.",
          "default": "partial_idempotence",
          "type": "str",
          "required": false,
          "choices": [
            "never",
            "fail",
            "partial_idempotence",
            "full_idempotence",
            "always"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Specifies the number of bits in the private key to create. For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. Generally, 2048 bits is considered sufficient.  DSA keys must be exactly 1024 bits as specified by FIPS 186-2. For ECDSA keys, size determines the key length by selecting from one of three elliptic curve sizes: 256, 384 or 521 bits. Attempting to use bit lengths other than these three values for ECDSA keys will cause this module to fail. Ed25519 keys have a fixed length and the size will be ignored.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the private and public keys should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "The algorithm used to generate the SSH private key. C(rsa1) is for protocol version 1. C(rsa1) is deprecated and may not be supported by every version of ssh-keygen.",
          "default": "rsa",
          "type": "str",
          "required": false,
          "choices": [
            "rsa",
            "dsa",
            "rsa1",
            "ecdsa",
            "ed25519"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "ssh-keygen (if I(backend=openssh))",
        "cryptography >= 2.6 (if I(backend=cryptography) and OpenSSH < 7.8 is installed)",
        "cryptography >= 3.0 (if I(backend=cryptography) and OpenSSH >= 7.8 is installed)"
      ],
      "short_description": "Generate OpenSSH private and public keys"
    },
    "examples": "\n- name: Generate an OpenSSH keypair with the default values (4096 bits, rsa)\n  community.crypto.openssh_keypair:\n    path: /tmp/id_ssh_rsa\n\n- name: Generate an OpenSSH keypair with the default values (4096 bits, rsa) and encrypted private key\n  community.crypto.openssh_keypair:\n    path: /tmp/id_ssh_rsa\n    passphrase: super_secret_password\n\n- name: Generate an OpenSSH rsa keypair with a different size (2048 bits)\n  community.crypto.openssh_keypair:\n    path: /tmp/id_ssh_rsa\n    size: 2048\n\n- name: Force regenerate an OpenSSH keypair if it already exists\n  community.crypto.openssh_keypair:\n    path: /tmp/id_ssh_rsa\n    force: True\n\n- name: Generate an OpenSSH keypair with a different algorithm (dsa)\n  community.crypto.openssh_keypair:\n    path: /tmp/id_ssh_dsa\n    type: dsa\n"
  },
  "community.crypto.openssl_csr": {
    "doc": {
      "description": "Please note that the module regenerates an existing CSR if it doesn't match the module's options, or if it seems to be corrupt. If you are concerned that this could overwrite your existing CSR, consider using the I(backup) option.\nThis module allows one to (re)generate OpenSSL certificate signing requests.\nThis module supports the subjectAltName, keyUsage, extendedKeyUsage, basicConstraints and OCSP Must Staple extensions.",
      "has_action": false,
      "notes": "If the certificate signing request already exists it will be checked whether subjectAltName, keyUsage, extendedKeyUsage and basicConstraints only contain the requested values, whether OCSP Must Staple is as requested, and if the request was signed by the given private key.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "authority_cert_issuer": {
          "aliases": [],
          "description": "Names that will be present in the authority cert issuer field of the certificate signing request.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA)\nExample: C(DNS:ca.example.org)\nIf specified, I(authority_cert_serial_number) must also be specified.\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "authority_cert_serial_number": {
          "aliases": [],
          "description": "The authority cert serial number.\nIf specified, I(authority_cert_issuer) must also be specified.\nNote that this is only supported if the C(cryptography) backend is used!\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "authority_key_identifier": {
          "aliases": [],
          "description": "The authority key identifier as a hex string, where two bytes are separated by colons.\nExample: C(00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33)\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original CSR back if you overwrote it with a new one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "basic_constraints": {
          "aliases": [
            "basicConstraints"
          ],
          "description": "Indicates basic constraints, such as if the certificate is a CA.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "basic_constraints_critical": {
          "aliases": [
            "basicConstraints_critical"
          ],
          "description": "Should the basicConstraints extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "common_name": {
          "aliases": [
            "CN",
            "commonName"
          ],
          "description": "The commonName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "country_name": {
          "aliases": [
            "C",
            "countryName"
          ],
          "description": "The countryName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "create_subject_key_identifier": {
          "aliases": [],
          "description": "Create the Subject Key Identifier from the public key.\nPlease note that commercial CAs can ignore the value, respectively use a value of their own choice instead. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "crl_distribution_points": {
          "aliases": [],
          "description": "Allows to specify one or multiple CRL distribution points.\nOnly supported by the C(cryptography) backend.",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "1.4.0",
          "suboptions": {
            "crl_issuer": {
              "aliases": [],
              "description": "Information about the issuer of the CRL.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "full_name": {
              "aliases": [],
              "description": "Describes how the CRL can be retrieved.\nMutually exclusive with I(relative_name).\nExample: C(URI:https://ca.example.com/revocations.crl).",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "reasons": {
              "aliases": [],
              "description": "List of reasons that this distribution point can be used for when performing revocation checks.",
              "type": "list",
              "required": false,
              "choices": [
                "key_compromise",
                "ca_compromise",
                "affiliation_changed",
                "superseded",
                "cessation_of_operation",
                "certificate_hold",
                "privilege_withdrawn",
                "aa_compromise"
              ],
              "elements": "str",
              "suboptions": {}
            },
            "relative_name": {
              "aliases": [],
              "description": "Describes how the CRL can be retrieved relative to the CRL issuer.\nMutually exclusive with I(full_name).\nExample: C(/CN=example.com).\nCan only be used when cryptography >= 1.6 is installed.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            }
          }
        },
        "digest": {
          "aliases": [],
          "description": "The digest used when signing the certificate signing request with the private key.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "email_address": {
          "aliases": [
            "E",
            "emailAddress"
          ],
          "description": "The emailAddress field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "extended_key_usage": {
          "aliases": [
            "extKeyUsage",
            "extendedKeyUsage"
          ],
          "description": "Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "extended_key_usage_critical": {
          "aliases": [
            "extKeyUsage_critical",
            "extendedKeyUsage_critical"
          ],
          "description": "Should the extkeyUsage extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the certificate signing request be forced regenerated by this ansible module.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "key_usage": {
          "aliases": [
            "keyUsage"
          ],
          "description": "This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "key_usage_critical": {
          "aliases": [
            "keyUsage_critical"
          ],
          "description": "Should the keyUsage extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "locality_name": {
          "aliases": [
            "L",
            "localityName"
          ],
          "description": "The localityName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "name_constraints_critical": {
          "aliases": [],
          "description": "Should the Name Constraints extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "name_constraints_excluded": {
          "aliases": [],
          "description": "For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is B(not) allowed to issue certificates for.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "name_constraints_permitted": {
          "aliases": [],
          "description": "For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is allowed to issue certificates for.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "1.1.0",
          "suboptions": {}
        },
        "ocsp_must_staple": {
          "aliases": [
            "ocspMustStaple"
          ],
          "description": "Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools.ietf.org/html/rfc7633)).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ocsp_must_staple_critical": {
          "aliases": [
            "ocspMustStaple_critical"
          ],
          "description": "Should the OCSP Must Staple extension be considered as critical.\nNote that according to the RFC, this extension should not be marked as critical, as old clients not knowing about OCSP Must Staple are required to reject such certificates (see U(https://tools.ietf.org/html/rfc7633#section-4)).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "organization_name": {
          "aliases": [
            "O",
            "organizationName"
          ],
          "description": "The organizationName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "organizational_unit_name": {
          "aliases": [
            "OU",
            "organizationalUnitName"
          ],
          "description": "The organizationalUnitName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The name of the file into which the generated OpenSSL certificate signing request will be written.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "The content of the private key to use when signing the certificate signing request.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "The path to the private key to use when signing the certificate signing request.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) CSR's content as I(csr).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the certificate signing request should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "state_or_province_name": {
          "aliases": [
            "ST",
            "stateOrProvinceName"
          ],
          "description": "The stateOrProvinceName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "subject": {
          "aliases": [],
          "description": "Key/value pairs that will be present in the subject name field of the certificate signing request.\nIf you need to specify more than one value with the same key, use a list as value.\nIf the order of the components is important, use I(subject_ordered).\nMutually exclusive with I(subject_ordered).",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "subject_alt_name": {
          "aliases": [
            "subjectAltName"
          ],
          "description": "Subject Alternative Name (SAN) extension to attach to the certificate signing request.\nThis can either be a 'comma separated string' or a YAML list.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).\nNote that if no SAN is specified, but a common name, the common name will be added as a SAN except if C(useCommonNameForSAN) is set to I(false).\nMore at U(https://tools.ietf.org/html/rfc5280#section-4.2.1.6).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "subject_alt_name_critical": {
          "aliases": [
            "subjectAltName_critical"
          ],
          "description": "Should the subjectAltName extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "subject_key_identifier": {
          "aliases": [],
          "description": "The subject key identifier as a hex string, where two bytes are separated by colons.\nExample: C(00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33)\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this option can only be used if I(create_subject_key_identifier) is C(no).\nNote that this is only supported if the C(cryptography) backend is used!",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "subject_ordered": {
          "aliases": [],
          "description": "A list of dictionaries, where every dictionary must contain one key/value pair. This key/value pair will be present in the subject name field of the certificate signing request.\nIf you want to specify more than one value with the same key in a row, you can use a list as value.\nMutually exclusive with I(subject), and any other subject field option, such as I(country_name), I(state_or_province_name), I(locality_name), I(organization_name), I(organizational_unit_name), I(common_name), or I(email_address).",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "use_common_name_for_san": {
          "aliases": [
            "useCommonNameForSAN"
          ],
          "description": "If set to C(yes), the module will fill the common name in for C(subject_alt_name) with C(DNS:) prefix if no SAN is specified.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "version": {
          "aliases": [],
          "description": "The version of the certificate signing request.\nThe only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1) is 1.\nThis option no longer accepts unsupported values since community.crypto 2.0.0.",
          "default": "1",
          "type": "int",
          "required": false,
          "choices": [
            "1"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.3"
      ],
      "short_description": "Generate OpenSSL Certificate Signing Request (CSR)"
    },
    "examples": "\n- name: Generate an OpenSSL Certificate Signing Request\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n\n- name: Generate an OpenSSL Certificate Signing Request with an inline key\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_content: \"{{ private_key_content }}\"\n    common_name: www.ansible.com\n\n- name: Generate an OpenSSL Certificate Signing Request with a passphrase protected private key\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    privatekey_passphrase: ansible\n    common_name: www.ansible.com\n\n- name: Generate an OpenSSL Certificate Signing Request with Subject information\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    country_name: FR\n    organization_name: Ansible\n    email_address: jdoe@ansible.com\n    common_name: www.ansible.com\n\n- name: Generate an OpenSSL Certificate Signing Request with subjectAltName extension\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    subject_alt_name: 'DNS:www.ansible.com,DNS:m.ansible.com'\n\n- name: Generate an OpenSSL CSR with subjectAltName extension with dynamic list\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    subject_alt_name: \"{{ item.value | map('regex_replace', '^', 'DNS:') | list }}\"\n  with_dict:\n    dns_server:\n    - www.ansible.com\n    - m.ansible.com\n\n- name: Force regenerate an OpenSSL Certificate Signing Request\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    force: yes\n    common_name: www.ansible.com\n\n- name: Generate an OpenSSL Certificate Signing Request with special key usages\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n    key_usage:\n      - digitalSignature\n      - keyAgreement\n    extended_key_usage:\n      - clientAuth\n\n- name: Generate an OpenSSL Certificate Signing Request with OCSP Must Staple\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n    ocsp_must_staple: yes\n\n- name: Generate an OpenSSL Certificate Signing Request for WinRM Certificate authentication\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/winrm.auth.csr\n    privatekey_path: /etc/ssl/private/winrm.auth.pem\n    common_name: username\n    extended_key_usage:\n    - clientAuth\n    subject_alt_name: otherName:1.3.6.1.4.1.311.20.2.3;UTF8:username@localhost\n\n- name: Generate an OpenSSL Certificate Signing Request with a CRL distribution point\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n    crl_distribution_points:\n      - full_name:\n          - \"URI:https://ca.example.com/revocations.crl\"\n        crl_issuer:\n          - \"URI:https://ca.example.com/\"\n        reasons:\n          - key_compromise\n          - ca_compromise\n          - cessation_of_operation\n"
  },
  "community.crypto.openssl_csr_info": {
    "doc": {
      "description": "This module allows one to query information on OpenSSL Certificate Signing Requests (CSR).\nIn case the CSR signature cannot be validated, the module will fail. In this case, all return variables are still returned.\nIt uses the cryptography python library to interact with OpenSSL.",
      "has_action": false,
      "options": {
        "content": {
          "aliases": [],
          "description": "Content of the CSR file.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the CSR file is loaded from.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.3"
      ],
      "short_description": "Provide information of OpenSSL Certificate Signing Requests (CSR)"
    },
    "examples": "\n- name: Generate an OpenSSL Certificate Signing Request\n  community.crypto.openssl_csr:\n    path: /etc/ssl/csr/www.ansible.com.csr\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n\n- name: Get information on the CSR\n  community.crypto.openssl_csr_info:\n    path: /etc/ssl/csr/www.ansible.com.csr\n  register: result\n\n- name: Dump information\n  debug:\n    var: result\n"
  },
  "community.crypto.openssl_csr_pipe": {
    "doc": {
      "description": "Please note that the module regenerates an existing CSR if it doesn't match the module's options, or if it seems to be corrupt.\nThis module allows one to (re)generate OpenSSL certificate signing requests.\nThis module supports the subjectAltName, keyUsage, extendedKeyUsage, basicConstraints and OCSP Must Staple extensions.",
      "has_action": false,
      "notes": "If the certificate signing request already exists it will be checked whether subjectAltName, keyUsage, extendedKeyUsage and basicConstraints only contain the requested values, whether OCSP Must Staple is as requested, and if the request was signed by the given private key.",
      "options": {
        "authority_cert_issuer": {
          "aliases": [],
          "description": "Names that will be present in the authority cert issuer field of the certificate signing request.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA)\nExample: C(DNS:ca.example.org)\nIf specified, I(authority_cert_serial_number) must also be specified.\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "authority_cert_serial_number": {
          "aliases": [],
          "description": "The authority cert serial number.\nIf specified, I(authority_cert_issuer) must also be specified.\nNote that this is only supported if the C(cryptography) backend is used!\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "authority_key_identifier": {
          "aliases": [],
          "description": "The authority key identifier as a hex string, where two bytes are separated by colons.\nExample: C(00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33)\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!\nThe C(AuthorityKeyIdentifier) extension will only be added if at least one of I(authority_key_identifier), I(authority_cert_issuer) and I(authority_cert_serial_number) is specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "basic_constraints": {
          "aliases": [
            "basicConstraints"
          ],
          "description": "Indicates basic constraints, such as if the certificate is a CA.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "basic_constraints_critical": {
          "aliases": [
            "basicConstraints_critical"
          ],
          "description": "Should the basicConstraints extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "common_name": {
          "aliases": [
            "CN",
            "commonName"
          ],
          "description": "The commonName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "The existing CSR.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "country_name": {
          "aliases": [
            "C",
            "countryName"
          ],
          "description": "The countryName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "create_subject_key_identifier": {
          "aliases": [],
          "description": "Create the Subject Key Identifier from the public key.\nPlease note that commercial CAs can ignore the value, respectively use a value of their own choice instead. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "crl_distribution_points": {
          "aliases": [],
          "description": "Allows to specify one or multiple CRL distribution points.\nOnly supported by the C(cryptography) backend.",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "1.4.0",
          "suboptions": {
            "crl_issuer": {
              "aliases": [],
              "description": "Information about the issuer of the CRL.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "full_name": {
              "aliases": [],
              "description": "Describes how the CRL can be retrieved.\nMutually exclusive with I(relative_name).\nExample: C(URI:https://ca.example.com/revocations.crl).",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "reasons": {
              "aliases": [],
              "description": "List of reasons that this distribution point can be used for when performing revocation checks.",
              "type": "list",
              "required": false,
              "choices": [
                "key_compromise",
                "ca_compromise",
                "affiliation_changed",
                "superseded",
                "cessation_of_operation",
                "certificate_hold",
                "privilege_withdrawn",
                "aa_compromise"
              ],
              "elements": "str",
              "suboptions": {}
            },
            "relative_name": {
              "aliases": [],
              "description": "Describes how the CRL can be retrieved relative to the CRL issuer.\nMutually exclusive with I(full_name).\nExample: C(/CN=example.com).\nCan only be used when cryptography >= 1.6 is installed.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            }
          }
        },
        "digest": {
          "aliases": [],
          "description": "The digest used when signing the certificate signing request with the private key.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "email_address": {
          "aliases": [
            "E",
            "emailAddress"
          ],
          "description": "The emailAddress field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "extended_key_usage": {
          "aliases": [
            "extKeyUsage",
            "extendedKeyUsage"
          ],
          "description": "Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "extended_key_usage_critical": {
          "aliases": [
            "extKeyUsage_critical",
            "extendedKeyUsage_critical"
          ],
          "description": "Should the extkeyUsage extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "key_usage": {
          "aliases": [
            "keyUsage"
          ],
          "description": "This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "key_usage_critical": {
          "aliases": [
            "keyUsage_critical"
          ],
          "description": "Should the keyUsage extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "locality_name": {
          "aliases": [
            "L",
            "localityName"
          ],
          "description": "The localityName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name_constraints_critical": {
          "aliases": [],
          "description": "Should the Name Constraints extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name_constraints_excluded": {
          "aliases": [],
          "description": "For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is B(not) allowed to issue certificates for.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "name_constraints_permitted": {
          "aliases": [],
          "description": "For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is allowed to issue certificates for.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "ocsp_must_staple": {
          "aliases": [
            "ocspMustStaple"
          ],
          "description": "Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools.ietf.org/html/rfc7633)).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ocsp_must_staple_critical": {
          "aliases": [
            "ocspMustStaple_critical"
          ],
          "description": "Should the OCSP Must Staple extension be considered as critical.\nNote that according to the RFC, this extension should not be marked as critical, as old clients not knowing about OCSP Must Staple are required to reject such certificates (see U(https://tools.ietf.org/html/rfc7633#section-4)).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "organization_name": {
          "aliases": [
            "O",
            "organizationName"
          ],
          "description": "The organizationName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "organizational_unit_name": {
          "aliases": [
            "OU",
            "organizationalUnitName"
          ],
          "description": "The organizationalUnitName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "The content of the private key to use when signing the certificate signing request.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "The path to the private key to use when signing the certificate signing request.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "state_or_province_name": {
          "aliases": [
            "ST",
            "stateOrProvinceName"
          ],
          "description": "The stateOrProvinceName field of the certificate signing request subject.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "subject": {
          "aliases": [],
          "description": "Key/value pairs that will be present in the subject name field of the certificate signing request.\nIf you need to specify more than one value with the same key, use a list as value.\nIf the order of the components is important, use I(subject_ordered).\nMutually exclusive with I(subject_ordered).",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "subject_alt_name": {
          "aliases": [
            "subjectAltName"
          ],
          "description": "Subject Alternative Name (SAN) extension to attach to the certificate signing request.\nThis can either be a 'comma separated string' or a YAML list.\nValues must be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA).\nNote that if no SAN is specified, but a common name, the common name will be added as a SAN except if C(useCommonNameForSAN) is set to I(false).\nMore at U(https://tools.ietf.org/html/rfc5280#section-4.2.1.6).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "subject_alt_name_critical": {
          "aliases": [
            "subjectAltName_critical"
          ],
          "description": "Should the subjectAltName extension be considered as critical.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "subject_key_identifier": {
          "aliases": [],
          "description": "The subject key identifier as a hex string, where two bytes are separated by colons.\nExample: C(00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33)\nPlease note that commercial CAs ignore this value, respectively use a value of their own choice. Specifying this option is mostly useful for self-signed certificates or for own CAs.\nNote that this option can only be used if I(create_subject_key_identifier) is C(no).\nNote that this is only supported if the C(cryptography) backend is used!",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "subject_ordered": {
          "aliases": [],
          "description": "A list of dictionaries, where every dictionary must contain one key/value pair. This key/value pair will be present in the subject name field of the certificate signing request.\nIf you want to specify more than one value with the same key in a row, you can use a list as value.\nMutually exclusive with I(subject), and any other subject field option, such as I(country_name), I(state_or_province_name), I(locality_name), I(organization_name), I(organizational_unit_name), I(common_name), or I(email_address).",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "use_common_name_for_san": {
          "aliases": [
            "useCommonNameForSAN"
          ],
          "description": "If set to C(yes), the module will fill the common name in for C(subject_alt_name) with C(DNS:) prefix if no SAN is specified.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "version": {
          "aliases": [],
          "description": "The version of the certificate signing request.\nThe only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1) is 1.\nThis option no longer accepts unsupported values since community.crypto 2.0.0.",
          "default": "1",
          "type": "int",
          "required": false,
          "choices": [
            "1"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.3"
      ],
      "short_description": "Generate OpenSSL Certificate Signing Request (CSR)",
      "version_added": "1.3.0"
    },
    "examples": "\n- name: Generate an OpenSSL Certificate Signing Request\n  community.crypto.openssl_csr_pipe:\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    common_name: www.ansible.com\n  register: result\n- debug:\n    var: result.csr\n\n- name: Generate an OpenSSL Certificate Signing Request with an inline CSR\n  community.crypto.openssl_csr:\n    content: \"{{ lookup('file', '/etc/ssl/csr/www.ansible.com.csr') }}\"\n    privatekey_content: \"{{ private_key_content }}\"\n    common_name: www.ansible.com\n  register: result\n- name: Store CSR\n  ansible.builtin.copy:\n    dest: /etc/ssl/csr/www.ansible.com.csr\n    content: \"{{ result.csr }}\"\n  when: result is changed\n"
  },
  "community.crypto.openssl_dhparam": {
    "doc": {
      "description": "This module allows one to (re)generate OpenSSL DH-params.\nThis module uses file common arguments to specify generated file permissions.\nPlease note that the module regenerates existing DH params if they do not match the module's options. If you are concerned that this could overwrite your existing DH params, consider using the I(backup) option.\nThe module can use the cryptography Python library, or the C(openssl) executable. By default, it tries to detect which one is available. This can be overridden with the I(select_crypto_backend) option.",
      "has_action": false,
      "notes": "Supports C(check_mode).",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original DH params back if you overwrote them with new ones by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the parameters be regenerated even it it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Name of the file in which the generated parameters will be saved.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) DH params' content as I(dhparams).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(openssl).\nIf set to C(openssl), will try to use the OpenSSL C(openssl) executable.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "openssl"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Size (in bits) of the generated DH-params.",
          "default": "4096",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the parameters should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "Either cryptography >= 2.0",
        "Or OpenSSL binary C(openssl)"
      ],
      "short_description": "Generate OpenSSL Diffie-Hellman Parameters"
    },
    "examples": "\n- name: Generate Diffie-Hellman parameters with the default size (4096 bits)\n  community.crypto.openssl_dhparam:\n    path: /etc/ssl/dhparams.pem\n\n- name: Generate DH Parameters with a different size (2048 bits)\n  community.crypto.openssl_dhparam:\n    path: /etc/ssl/dhparams.pem\n    size: 2048\n\n- name: Force regenerate an DH parameters if they already exist\n  community.crypto.openssl_dhparam:\n    path: /etc/ssl/dhparams.pem\n    force: yes\n"
  },
  "community.crypto.openssl_pkcs12": {
    "doc": {
      "description": "This module allows one to (re-)generate PKCS#12.\nThe module can use the cryptography Python library, or the pyOpenSSL Python library. By default, it tries to detect which one is available, assuming none of the I(iter_size) and I(maciter_size) options are used. This can be overridden with the I(select_crypto_backend) option.",
      "has_action": false,
      "options": {
        "action": {
          "aliases": [],
          "description": "C(export) or C(parse) a PKCS#12.",
          "default": "export",
          "type": "str",
          "required": false,
          "choices": [
            "export",
            "parse"
          ],
          "suboptions": {}
        },
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original output file back if you overwrote it with a new one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "certificate_path": {
          "aliases": [],
          "description": "The path to read certificates and private keys from.\nMust be in PEM format.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the file be regenerated even if it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "friendly_name": {
          "aliases": [
            "name"
          ],
          "description": "Specifies the friendly name for the certificate and private key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "iter_size": {
          "aliases": [],
          "description": "Number of times to repeat the encryption step.\nThis is not considered during idempotency checks.\nThis is only used by the C(pyopenssl) backend. When using it, the default is C(2048).",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "maciter_size": {
          "aliases": [],
          "description": "Number of times to repeat the MAC step.\nThis is not considered during idempotency checks.\nThis is only used by the C(pyopenssl) backend. When using it, the default is C(1).",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "other_certificates": {
          "aliases": [
            "ca_certificates"
          ],
          "description": "List of other certificates to include. Pre Ansible 2.8 this parameter was called I(ca_certificates).\nAssumes there is one PEM-encoded certificate per file. If a file contains multiple PEM certificates, set I(other_certificates_parse_all) to C(true).",
          "type": "list",
          "required": false,
          "elements": "path",
          "suboptions": {}
        },
        "other_certificates_parse_all": {
          "aliases": [],
          "description": "If set to C(true), assumes that the files mentioned in I(other_certificates) can contain more than one certificate per file (or even none per file).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.4.0",
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "The PKCS#12 password.\nB(Note:) PKCS12 encryption is not secure and should not be used as a security mechanism. If you need to store or send a PKCS12 file safely, you should additionally encrypt it with something else.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Filename to write the PKCS#12 file to.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "Passphrase source to decrypt any input private keys with.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "File to read private key from.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) PKCS#12's content as I(pkcs12).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available, and falls back to C(pyopenssl). If one of I(iter_size) or I(maciter_size) is used, C(auto) will always result in C(pyopenssl) to be chosen for backwards compatibility.\nIf set to C(pyopenssl), will try to use the L(pyOpenSSL,https://pypi.org/project/pyOpenSSL/) library.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography",
            "pyopenssl"
          ],
          "version_added": "1.7.0",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "PKCS#12 file path to parse.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the file should exist or not. All parameters except C(path) are ignored when state is C(absent).",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "PyOpenSSL >= 0.15 or cryptography >= 3.0"
      ],
      "short_description": "Generate OpenSSL PKCS#12 archive"
    },
    "examples": "\n- name: Generate PKCS#12 file\n  community.crypto.openssl_pkcs12:\n    action: export\n    path: /opt/certs/ansible.p12\n    friendly_name: raclette\n    privatekey_path: /opt/certs/keys/key.pem\n    certificate_path: /opt/certs/cert.pem\n    other_certificates: /opt/certs/ca.pem\n    # Note that if /opt/certs/ca.pem contains multiple certificates,\n    # only the first one will be used. See the other_certificates_parse_all\n    # option for changing this behavior.\n    state: present\n\n- name: Generate PKCS#12 file\n  community.crypto.openssl_pkcs12:\n    action: export\n    path: /opt/certs/ansible.p12\n    friendly_name: raclette\n    privatekey_path: /opt/certs/keys/key.pem\n    certificate_path: /opt/certs/cert.pem\n    other_certificates_parse_all: true\n    other_certificates:\n      - /opt/certs/ca_bundle.pem\n        # Since we set other_certificates_parse_all to true, all\n        # certificates in the CA bundle are included and not just\n        # the first one.\n      - /opt/certs/intermediate.pem\n        # In case this file has multiple certificates in it,\n        # all will be included as well.\n    state: present\n\n- name: Change PKCS#12 file permission\n  community.crypto.openssl_pkcs12:\n    action: export\n    path: /opt/certs/ansible.p12\n    friendly_name: raclette\n    privatekey_path: /opt/certs/keys/key.pem\n    certificate_path: /opt/certs/cert.pem\n    other_certificates: /opt/certs/ca.pem\n    state: present\n    mode: '0600'\n\n- name: Regen PKCS#12 file\n  community.crypto.openssl_pkcs12:\n    action: export\n    src: /opt/certs/ansible.p12\n    path: /opt/certs/ansible.p12\n    friendly_name: raclette\n    privatekey_path: /opt/certs/keys/key.pem\n    certificate_path: /opt/certs/cert.pem\n    other_certificates: /opt/certs/ca.pem\n    state: present\n    mode: '0600'\n    force: yes\n\n- name: Dump/Parse PKCS#12 file\n  community.crypto.openssl_pkcs12:\n    action: parse\n    src: /opt/certs/ansible.p12\n    path: /opt/certs/ansible.pem\n    state: present\n\n- name: Remove PKCS#12 file\n  community.crypto.openssl_pkcs12:\n    path: /opt/certs/ansible.p12\n    state: absent\n"
  },
  "community.crypto.openssl_privatekey": {
    "doc": {
      "description": "Keys are generated in PEM format.\nOne can generate L(RSA,https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29), L(DSA,https://en.wikipedia.org/wiki/Digital_Signature_Algorithm), L(ECC,https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) or L(EdDSA,https://en.wikipedia.org/wiki/EdDSA) private keys.\nPlease note that the module regenerates private keys if they don't match the module's options. In particular, if you provide another passphrase (or specify none), change the keysize, etc., the private key will be regenerated. If you are concerned that this could B(overwrite your private key), consider using the I(backup) option.\nThe default mode for the private key file will be C(0600) if I(mode) is not explicitly set.\nThis module allows one to (re)generate OpenSSL private keys.",
      "has_action": false,
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original private key back if you overwrote it with a new one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "cipher": {
          "aliases": [],
          "description": "The cipher to encrypt the private key. Must be C(auto).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "curve": {
          "aliases": [],
          "description": "Note that not all curves are supported by all versions of C(cryptography).\nFor maximal interoperability, C(secp384r1) or C(secp256r1) should be used.\nWe use the curve names as defined in the L(IANA registry for TLS,https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8).\nPlease note that all curves except C(secp224r1), C(secp256k1), C(secp256r1), C(secp384r1) and C(secp521r1) are discouraged for new private keys.",
          "type": "str",
          "required": false,
          "choices": [
            "secp224r1",
            "secp256k1",
            "secp256r1",
            "secp384r1",
            "secp521r1",
            "secp192r1",
            "brainpoolP256r1",
            "brainpoolP384r1",
            "brainpoolP512r1",
            "sect163k1",
            "sect163r2",
            "sect233k1",
            "sect233r1",
            "sect283k1",
            "sect283r1",
            "sect409k1",
            "sect409r1",
            "sect571k1",
            "sect571r1"
          ],
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the key be regenerated even if it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "format": {
          "aliases": [],
          "description": "Determines which format the private key is written in. By default, PKCS1 (traditional OpenSSL format) is used for all keys which support it. Please note that not every key can be exported in any format.\nThe value C(auto) selects a fromat based on the key format. The value C(auto_ignore) does the same, but for existing private key files, it will not force a regenerate when its format is not the automatically selected one for generation.\nNote that if the format for an existing private key mismatches, the key is B(regenerated) by default. To change this behavior, use the I(format_mismatch) option.",
          "default": "auto_ignore",
          "type": "str",
          "required": false,
          "choices": [
            "pkcs1",
            "pkcs8",
            "raw",
            "auto",
            "auto_ignore"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "format_mismatch": {
          "aliases": [],
          "description": "Determines behavior of the module if the format of a private key does not match the expected format, but all other parameters are as expected.\nIf set to C(regenerate) (default), generates a new private key.\nIf set to C(convert), the key will be converted to the new format instead.\nOnly supported by the C(cryptography) backend.",
          "default": "regenerate",
          "type": "str",
          "required": false,
          "choices": [
            "regenerate",
            "convert"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Name of the file in which the generated TLS/SSL private key will be written. It will have C(0600) mode if I(mode) is not explicitly set.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "regenerate": {
          "aliases": [],
          "description": "Allows to configure in which situations the module is allowed to regenerate private keys. The module will always generate a new key if the destination file does not exist.\nBy default, the key will be regenerated when it doesn't match the module's options, except when the key cannot be read or the passphrase does not match. Please note that this B(changed) for Ansible 2.10. For Ansible 2.9, the behavior was as if C(full_idempotence) is specified.\nIf set to C(never), the module will fail if the key cannot be read or the passphrase isn't matching, and will never regenerate an existing key.\nIf set to C(fail), the module will fail if the key does not correspond to the module's options.\nIf set to C(partial_idempotence), the key will be regenerated if it does not conform to the module's options. The key is B(not) regenerated if it cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified.\nIf set to C(full_idempotence), the key will be regenerated if it does not conform to the module's options. This is also the case if the key cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified. Make sure you have a B(backup) when using this option!\nIf set to C(always), the module will always regenerate the key. This is equivalent to setting I(force) to C(yes).\nNote that if I(format_mismatch) is set to C(convert) and everything matches except the format, the key will always be converted, except if I(regenerate) is set to C(always).",
          "default": "full_idempotence",
          "type": "str",
          "required": false,
          "choices": [
            "never",
            "fail",
            "partial_idempotence",
            "full_idempotence",
            "always"
          ],
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) private key's content as I(privatekey).\nNote that especially if the private key is not encrypted, you have to make sure that the returned value is treated appropriately and not accidentally written to logs etc.! Use with care!\nUse Ansible's I(no_log) task option to avoid the output being shown. See also U(https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#how-do-i-keep-secret-data-in-my-playbook).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Size (in bits) of the TLS/SSL key to generate.",
          "default": "4096",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the private key should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "The algorithm used to generate the TLS/SSL private key.\nNote that C(ECC), C(X25519), C(X448), C(Ed25519) and C(Ed448) require the C(cryptography) backend. C(X25519) needs cryptography 2.5 or newer, while C(X448), C(Ed25519) and C(Ed448) require cryptography 2.6 or newer. For C(ECC), the minimal cryptography version required depends on the I(curve) option.",
          "default": "RSA",
          "type": "str",
          "required": false,
          "choices": [
            "DSA",
            "ECC",
            "Ed25519",
            "Ed448",
            "RSA",
            "X25519",
            "X448"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2.3 (older versions might work as well)"
      ],
      "short_description": "Generate OpenSSL private keys"
    },
    "examples": "\n- name: Generate an OpenSSL private key with the default values (4096 bits, RSA)\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n\n- name: Generate an OpenSSL private key with the default values (4096 bits, RSA) and a passphrase\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n    passphrase: ansible\n    cipher: aes256\n\n- name: Generate an OpenSSL private key with a different size (2048 bits)\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n    size: 2048\n\n- name: Force regenerate an OpenSSL private key if it already exists\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n    force: yes\n\n- name: Generate an OpenSSL private key with a different algorithm (DSA)\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n    type: DSA\n"
  },
  "community.crypto.openssl_privatekey_info": {
    "doc": {
      "description": "This module allows one to query information on OpenSSL private keys.\nIn case the key consistency checks fail, the module will fail as this indicates a faked private key. In this case, all return variables are still returned. Note that key consistency checks are not available all key types; if none is available, C(none) is returned for C(key_is_consistent).\nIt uses the cryptography python library to interact with OpenSSL.",
      "has_action": false,
      "notes": "Supports C(check_mode).",
      "options": {
        "check_consistency": {
          "aliases": [],
          "description": "Whether to check consistency of the private key.\nIn community.crypto < 2.0.0, consistency was always checked.\nSince community.crypto 2.0.0, the consistency check has been disabled by default to avoid private key material to be transported around and computed with, and only do so when requested explicitly. This can potentially prevent L(side-channel attacks,https://en.wikipedia.org/wiki/Side-channel_attack).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "Content of the private key file.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the private key file is loaded from.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_private_key_data": {
          "aliases": [],
          "description": "Whether to return private key data.\nOnly set this to C(yes) when you want private information about this key to leave the remote machine.\nB(WARNING:) you have to make sure that private key data isn't accidentally logged!",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2.3"
      ],
      "short_description": "Provide information for OpenSSL private keys"
    },
    "examples": "\n- name: Generate an OpenSSL private key with the default values (4096 bits, RSA)\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n\n- name: Get information on generated key\n  community.crypto.openssl_privatekey_info:\n    path: /etc/ssl/private/ansible.com.pem\n  register: result\n\n- name: Dump information\n  ansible.builtin.debug:\n    var: result\n"
  },
  "community.crypto.openssl_privatekey_pipe": {
    "doc": {
      "description": "Keys are generated in PEM format.\nMake sure to not write the result of this module into logs or to the console, as it contains private key data! Use the I(no_log) task option to be sure.\nNote that this module is implemented as an L(action plugin,https://docs.ansible.com/ansible/latest/plugins/action.html) and will always be executed on the controller.\nOne can generate L(RSA,https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29), L(DSA,https://en.wikipedia.org/wiki/Digital_Signature_Algorithm), L(ECC,https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) or L(EdDSA,https://en.wikipedia.org/wiki/EdDSA) private keys.\nPlease note that the module regenerates private keys if they don't match the module's options. In particular, if you provide another passphrase (or specify none), change the keysize, etc., the private key will be regenerated. If you are concerned that this could B(overwrite your private key), consider using the I(backup) option.\nThis allows to read and write keys to vaults without having to write intermediate versions to disk.\nThis module allows one to (re)generate OpenSSL private keys without disk access.",
      "has_action": true,
      "options": {
        "cipher": {
          "aliases": [],
          "description": "The cipher to encrypt the private key. Must be C(auto).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "The current private key data.\nNeeded for idempotency. If not provided, the module will always return a change, and all idempotence-related options are ignored.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "content_base64": {
          "aliases": [],
          "description": "Set to C(true) if the content is base64 encoded.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "curve": {
          "aliases": [],
          "description": "Note that not all curves are supported by all versions of C(cryptography).\nFor maximal interoperability, C(secp384r1) or C(secp256r1) should be used.\nWe use the curve names as defined in the L(IANA registry for TLS,https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8).\nPlease note that all curves except C(secp224r1), C(secp256k1), C(secp256r1), C(secp384r1) and C(secp521r1) are discouraged for new private keys.",
          "type": "str",
          "required": false,
          "choices": [
            "secp224r1",
            "secp256k1",
            "secp256r1",
            "secp384r1",
            "secp521r1",
            "secp192r1",
            "brainpoolP256r1",
            "brainpoolP384r1",
            "brainpoolP512r1",
            "sect163k1",
            "sect163r2",
            "sect233k1",
            "sect233r1",
            "sect283k1",
            "sect283r1",
            "sect409k1",
            "sect409r1",
            "sect571k1",
            "sect571r1"
          ],
          "suboptions": {}
        },
        "format": {
          "aliases": [],
          "description": "Determines which format the private key is written in. By default, PKCS1 (traditional OpenSSL format) is used for all keys which support it. Please note that not every key can be exported in any format.\nThe value C(auto) selects a fromat based on the key format. The value C(auto_ignore) does the same, but for existing private key files, it will not force a regenerate when its format is not the automatically selected one for generation.\nNote that if the format for an existing private key mismatches, the key is B(regenerated) by default. To change this behavior, use the I(format_mismatch) option.",
          "default": "auto_ignore",
          "type": "str",
          "required": false,
          "choices": [
            "pkcs1",
            "pkcs8",
            "raw",
            "auto",
            "auto_ignore"
          ],
          "suboptions": {}
        },
        "format_mismatch": {
          "aliases": [],
          "description": "Determines behavior of the module if the format of a private key does not match the expected format, but all other parameters are as expected.\nIf set to C(regenerate) (default), generates a new private key.\nIf set to C(convert), the key will be converted to the new format instead.\nOnly supported by the C(cryptography) backend.",
          "default": "regenerate",
          "type": "str",
          "required": false,
          "choices": [
            "regenerate",
            "convert"
          ],
          "suboptions": {}
        },
        "passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "regenerate": {
          "aliases": [],
          "description": "Allows to configure in which situations the module is allowed to regenerate private keys. The module will always generate a new key if the destination file does not exist.\nBy default, the key will be regenerated when it doesn't match the module's options, except when the key cannot be read or the passphrase does not match. Please note that this B(changed) for Ansible 2.10. For Ansible 2.9, the behavior was as if C(full_idempotence) is specified.\nIf set to C(never), the module will fail if the key cannot be read or the passphrase isn't matching, and will never regenerate an existing key.\nIf set to C(fail), the module will fail if the key does not correspond to the module's options.\nIf set to C(partial_idempotence), the key will be regenerated if it does not conform to the module's options. The key is B(not) regenerated if it cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified.\nIf set to C(full_idempotence), the key will be regenerated if it does not conform to the module's options. This is also the case if the key cannot be read (broken file), the key is protected by an unknown passphrase, or when they key is not protected by a passphrase, but a passphrase is specified. Make sure you have a B(backup) when using this option!\nIf set to C(always), the module will always regenerate the key. This is equivalent to setting I(force) to C(yes).\nNote that if I(format_mismatch) is set to C(convert) and everything matches except the format, the key will always be converted, except if I(regenerate) is set to C(always).",
          "default": "full_idempotence",
          "type": "str",
          "required": false,
          "choices": [
            "never",
            "fail",
            "partial_idempotence",
            "full_idempotence",
            "always"
          ],
          "suboptions": {}
        },
        "return_current_key": {
          "aliases": [],
          "description": "Set to C(true) to return the current private key when the module did not generate a new one.\nNote that in case of check mode, when this option is not set to C(true), the module always returns the current key (if it was provided) and Ansible will replace it by C(VALUE_SPECIFIED_IN_NO_LOG_PARAMETER).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Size (in bits) of the TLS/SSL key to generate.",
          "default": "4096",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "The algorithm used to generate the TLS/SSL private key.\nNote that C(ECC), C(X25519), C(X448), C(Ed25519) and C(Ed448) require the C(cryptography) backend. C(X25519) needs cryptography 2.5 or newer, while C(X448), C(Ed25519) and C(Ed448) require cryptography 2.6 or newer. For C(ECC), the minimal cryptography version required depends on the I(curve) option.",
          "default": "RSA",
          "type": "str",
          "required": false,
          "choices": [
            "DSA",
            "ECC",
            "Ed25519",
            "Ed448",
            "RSA",
            "X25519",
            "X448"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2.3 (older versions might work as well)"
      ],
      "short_description": "Generate OpenSSL private keys without disk access",
      "version_added": "1.3.0"
    },
    "examples": "\n- name: Generate an OpenSSL private key with the default values (4096 bits, RSA)\n  community.crypto.openssl_privatekey_pipe:\n    path: /etc/ssl/private/ansible.com.pem\n  register: output\n  no_log: true  # make sure that private key data is not accidentally revealed in logs!\n- name: Show generated key\n  debug:\n    msg: \"{{ output.privatekey }}\"\n  # DO NOT OUTPUT KEY MATERIAL TO CONSOLE OR LOGS IN PRODUCTION!\n\n- block:\n    - name: Update sops-encrypted key with the community.sops collection\n      community.crypto.openssl_privatekey_pipe:\n        content: \"{{ lookup('community.sops.sops', 'private_key.pem.sops') }}\"\n        size: 2048\n      register: output\n      no_log: true  # make sure that private key data is not accidentally revealed in logs!\n\n    - name: Update encrypted key when openssl_privatekey_pipe reported a change\n      community.sops.sops_encrypt:\n        path: private_key.pem.sops\n        content_text: \"{{ output.privatekey }}\"\n      when: output is changed\n  always:\n    - name: Make sure that output (which contains the private key) is overwritten\n      set_fact:\n        output: ''\n"
  },
  "community.crypto.openssl_publickey": {
    "doc": {
      "description": "This module allows one to (re)generate OpenSSL public keys from their private keys.\nKeys are generated in PEM or OpenSSH format.\nThe module uses the cryptography Python library.",
      "has_action": false,
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original public key back if you overwrote it with a different one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the key be regenerated even it it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "format": {
          "aliases": [],
          "description": "The format of the public key.",
          "default": "PEM",
          "type": "str",
          "required": false,
          "choices": [
            "OpenSSH",
            "PEM"
          ],
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Name of the file in which the generated TLS/SSL public key will be written.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "The content of the TLS/SSL private key from which to generate the public key.\nEither I(privatekey_path) or I(privatekey_content) must be specified, but not both. If I(state) is C(present), one of them is required.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "Path to the TLS/SSL private key from which to generate the public key.\nEither I(privatekey_path) or I(privatekey_content) must be specified, but not both. If I(state) is C(present), one of them is required.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) public key's content as I(publickey).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the public key should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2.3 (older versions might work as well)",
        "Needs cryptography >= 1.4 if I(format) is C(OpenSSH)"
      ],
      "short_description": "Generate an OpenSSL public key from its private key."
    },
    "examples": "\n- name: Generate an OpenSSL public key in PEM format\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n\n- name: Generate an OpenSSL public key in PEM format from an inline key\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_content: \"{{ private_key_content }}\"\n\n- name: Generate an OpenSSL public key in OpenSSH v2 format\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    format: OpenSSH\n\n- name: Generate an OpenSSL public key with a passphrase protected private key\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    privatekey_passphrase: ansible\n\n- name: Force regenerate an OpenSSL public key if it already exists\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    force: yes\n\n- name: Remove an OpenSSL public key\n  community.crypto.openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    state: absent\n"
  },
  "community.crypto.openssl_publickey_info": {
    "doc": {
      "description": "This module allows one to query information on OpenSSL public keys.\nIt uses the cryptography python library to interact with OpenSSL.",
      "has_action": false,
      "notes": "Supports C(check_mode).",
      "options": {
        "content": {
          "aliases": [],
          "description": "Content of the public key file.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the public key file is loaded from.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2.3"
      ],
      "short_description": "Provide information for OpenSSL public keys",
      "version_added": "1.7.0"
    },
    "examples": "\n- name: Generate an OpenSSL private key with the default values (4096 bits, RSA)\n  community.crypto.openssl_privatekey:\n    path: /etc/ssl/private/ansible.com.pem\n\n- name: Create public key from private key\n  community.crypto.openssl_publickey:\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    path: /etc/ssl/ansible.com.pub\n\n- name: Get information on public key\n  community.crypto.openssl_publickey_info:\n    path: /etc/ssl/ansible.com.pub\n  register: result\n\n- name: Dump information\n  ansible.builtin.debug:\n    var: result\n"
  },
  "community.crypto.openssl_signature": {
    "doc": {
      "description": "This module allows one to sign data using a private key.\nThe module uses the cryptography Python library.",
      "has_action": false,
      "notes": "When using the C(cryptography) backend, the following key types require at least the following C(cryptography) version:\nRSA keys: C(cryptography) >= 1.4\nDSA and ECDSA keys: C(cryptography) >= 1.5\ned448 and ed25519 keys: C(cryptography) >= 2.6\n",
      "options": {
        "path": {
          "aliases": [],
          "description": "The file to sign.\nThis file will only be read and not modified.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "The content of the private key to use when signing the certificate signing request.\nEither I(privatekey_path) or I(privatekey_content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the private key.\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "The path to the private key to use when signing.\nEither I(privatekey_path) or I(privatekey_content) must be specified, but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.4 (some key types require newer versions)"
      ],
      "short_description": "Sign data with openssl",
      "version_added": "1.1.0"
    },
    "examples": "\n- name: Sign example file\n  community.crypto.openssl_signature:\n    privatekey_path: private.key\n    path: /tmp/example_file\n  register: sig\n\n- name: Verify signature of example file\n  community.crypto.openssl_signature_info:\n    certificate_path: cert.pem\n    path: /tmp/example_file\n    signature: \"{{ sig.signature }}\"\n  register: verify\n\n- name: Make sure the signature is valid\n  assert:\n    that:\n      - verify.valid\n"
  },
  "community.crypto.openssl_signature_info": {
    "doc": {
      "description": "This module allows one to verify a signature for a file by a certificate.\nThe module uses the cryptography Python library.",
      "has_action": false,
      "notes": "When using the C(cryptography) backend, the following key types require at least the following C(cryptography) version:\nRSA keys: C(cryptography) >= 1.4\nDSA and ECDSA keys: C(cryptography) >= 1.5\ned448 and ed25519 keys: C(cryptography) >= 2.6\n\nSupports C(check_mode).",
      "options": {
        "certificate_content": {
          "aliases": [],
          "description": "The content of the certificate used to verify the signature.\nEither I(certificate_path) or I(certificate_content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "certificate_path": {
          "aliases": [],
          "description": "The path to the certificate used to verify the signature.\nEither I(certificate_path) or I(certificate_content) must be specified, but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The signed file to verify.\nThis file will only be read and not modified.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "signature": {
          "aliases": [],
          "description": "Base64 encoded signature.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.4 (some key types require newer versions)"
      ],
      "short_description": "Verify signatures with openssl",
      "version_added": "1.1.0"
    },
    "examples": "\n- name: Sign example file\n  community.crypto.openssl_signature:\n    privatekey_path: private.key\n    path: /tmp/example_file\n  register: sig\n\n- name: Verify signature of example file\n  community.crypto.openssl_signature_info:\n    certificate_path: cert.pem\n    path: /tmp/example_file\n    signature: \"{{ sig.signature }}\"\n  register: verify\n\n- name: Make sure the signature is valid\n  assert:\n    that:\n      - verify.valid\n"
  },
  "community.crypto.x509_certificate": {
    "doc": {
      "description": "It implements a notion of provider (one of C(selfsigned), C(ownca), C(acme), and C(entrust)) for your certificate.\nIt uses the cryptography python library to interact with OpenSSL.\nNote that this module was called C(openssl_certificate) when included directly in Ansible up to version 2.9. When moved to the collection C(community.crypto), it was renamed to M(community.crypto.x509_certificate). From Ansible 2.10 on, it can still be used by the old short name (or by C(ansible.builtin.openssl_certificate)), which redirects to C(community.crypto.x509_certificate). When using FQCNs or when using the L(collections,https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#using-collections-in-a-playbook) keyword, the new name M(community.crypto.x509_certificate) should be used to avoid a deprecation warning.\nPlease note that the module regenerates existing certificate if it does not match the module's options, or if it seems to be corrupt. If you are concerned that this could overwrite your existing certificate, consider using the I(backup) option.\nThe C(ownca) provider is intended for generating an OpenSSL certificate signed with your own CA (Certificate Authority) certificate (self-signed certificate).\nThis module allows one to (re)generate OpenSSL certificates.",
      "has_action": false,
      "notes": "Supports C(check_mode).\nAll ASN.1 TIME values should be specified following the YYYYMMDDHHMMSSZ pattern.\nDate specified should be UTC. Minutes and seconds are mandatory.\nFor security reason, when you use C(ownca) provider, you should NOT run M(community.crypto.x509_certificate) on a target machine, but on a dedicated CA machine. It is recommended not to store the CA private key on the target machine. Once signed, the certificate can be moved to the target machine.\nFor the C(selfsigned) provider, I(csr_path) and I(csr_content) are optional. If not provided, a certificate without any information (Subject, Subject Alternative Names, Key Usage, etc.) is created.",
      "options": {
        "acme_accountkey_path": {
          "aliases": [],
          "description": "The path to the accountkey for the C(acme) provider.\nThis is only used by the C(acme) provider.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "acme_chain": {
          "aliases": [],
          "description": "Include the intermediate certificate to the generated certificate\nThis is only used by the C(acme) provider.\nNote that this is only available for older versions of C(acme-tiny). New versions include the chain automatically, and setting I(acme_chain) to C(yes) results in an error.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "acme_challenge_path": {
          "aliases": [],
          "description": "The path to the ACME challenge directory that is served on U(http://<HOST>:80/.well-known/acme-challenge/)\nThis is only used by the C(acme) provider.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "acme_directory": {
          "aliases": [],
          "description": "The ACME directory to use. You can use any directory that supports the ACME protocol, such as Buypass or Let's Encrypt.\nLet's Encrypt recommends using their staging server while developing jobs. U(https://letsencrypt.org/docs/staging-environment/).",
          "default": "https://acme-v02.api.letsencrypt.org/directory",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original certificate back if you overwrote it with a new one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "csr_content": {
          "aliases": [],
          "description": "Content of the Certificate Signing Request (CSR) used to generate this certificate.\nThis is mutually exclusive with I(csr_path).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "csr_path": {
          "aliases": [],
          "description": "Path to the Certificate Signing Request (CSR) used to generate this certificate.\nThis is mutually exclusive with I(csr_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_client_cert_key_path": {
          "aliases": [],
          "description": "The path to the private key of the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_client_cert_path": {
          "aliases": [],
          "description": "The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_key": {
          "aliases": [],
          "description": "The key (password) for authentication to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_specification_path": {
          "aliases": [],
          "description": "The path to the specification file defining the Entrust Certificate Services (ECS) API configuration.\nYou can use this to keep a local copy of the specification to avoid downloading it every time the module is used.\nThis is only used by the C(entrust) provider.",
          "default": "https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_user": {
          "aliases": [],
          "description": "The username for authentication to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_cert_type": {
          "aliases": [],
          "description": "Specify the type of certificate requested.\nThis is only used by the C(entrust) provider.",
          "default": "STANDARD_SSL",
          "type": "str",
          "required": false,
          "choices": [
            "STANDARD_SSL",
            "ADVANTAGE_SSL",
            "UC_SSL",
            "EV_SSL",
            "WILDCARD_SSL",
            "PRIVATE_SSL",
            "PD_SSL",
            "CDS_ENT_LITE",
            "CDS_ENT_PRO",
            "SMIME_ENT"
          ],
          "suboptions": {}
        },
        "entrust_not_after": {
          "aliases": [],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as an absolute timestamp.\nA valid absolute time format is C(ASN.1 TIME) such as C(2019-06-18).\nA valid relative time format is C([+-]timespec) where timespec can be an integer + C([w | d | h | m | s]), such as C(+365d) or C(+32w1d2h)).\nTime will always be interpreted as UTC.\nNote that only the date (day, month, year) is supported for specifying the expiry date of the issued certificate.\nThe full date-time is adjusted to EST (GMT -5:00) before issuance, which may result in a certificate with an expiration date one day earlier than expected if a relative time is used.\nThe minimum certificate lifetime is 90 days, and maximum is three years.\nIf this value is not specified, the certificate will stop being valid 365 days the date of issue.\nThis is only used by the C(entrust) provider.\nPlease note that this value is B(not) covered by the I(ignore_timestamps) option.",
          "default": "+365d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_email": {
          "aliases": [],
          "description": "The email of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_name": {
          "aliases": [],
          "description": "The name of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_phone": {
          "aliases": [],
          "description": "The phone number of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Generate the certificate, even if it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ignore_timestamps": {
          "aliases": [],
          "description": "Whether the \"not before\" and \"not after\" timestamps should be ignored for idempotency checks.\nIt is better to keep the default value C(true) when using relative timestamps (like C(+0s) for now).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "ownca_content": {
          "aliases": [],
          "description": "Content of the CA (Certificate Authority) certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_path).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "ownca_create_authority_key_identifier": {
          "aliases": [],
          "description": "Create a Authority Key Identifier from the CA's certificate. If the CSR provided a authority key identifier, it is ignored.\nThe Authority Key Identifier is generated from the CA certificate's Subject Key Identifier, if available. If it is not available, the CA certificate's public key will be used.\nThis is only used by the C(ownca) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ownca_create_subject_key_identifier": {
          "aliases": [],
          "description": "Whether to create the Subject Key Identifier (SKI) from the public key.\nA value of C(create_if_not_provided) (default) only creates a SKI when the CSR does not provide one.\nA value of C(always_create) always creates a SKI. If the CSR provides one, that one is ignored.\nA value of C(never_create) never creates a SKI. If the CSR provides one, that one is used.\nThis is only used by the C(ownca) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "create_if_not_provided",
          "type": "str",
          "required": false,
          "choices": [
            "create_if_not_provided",
            "always_create",
            "never_create"
          ],
          "suboptions": {}
        },
        "ownca_digest": {
          "aliases": [],
          "description": "The digest algorithm to be used for the C(ownca) certificate.\nThis is only used by the C(ownca) provider.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_not_after": {
          "aliases": [],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will stop being valid 10 years from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(ownca) provider.\nOn macOS 10.15 and onwards, TLS server certificates must have a validity period of 825 days or fewer. Please see U(https://support.apple.com/en-us/HT210176) for more details.",
          "default": "+3650d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_not_before": {
          "aliases": [],
          "description": "The point in time the certificate is valid from.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will start being valid from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(ownca) provider.",
          "default": "+0s",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_path": {
          "aliases": [],
          "description": "Remote absolute path of the CA (Certificate Authority) certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "ownca_privatekey_content": {
          "aliases": [],
          "description": "Content of the CA (Certificate Authority) private key to use when signing the certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_privatekey_path).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "ownca_privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the I(ownca_privatekey_path) resp. I(ownca_privatekey_content).\nThis is only used by the C(ownca) provider.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_privatekey_path": {
          "aliases": [],
          "description": "Path to the CA (Certificate Authority) private key to use when signing the certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_privatekey_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "ownca_version": {
          "aliases": [],
          "description": "The version of the C(ownca) certificate.\nNowadays it should almost always be C(3).\nThis is only used by the C(ownca) provider.",
          "default": "3",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the generated certificate file should be created or is already located.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "Path to the private key to use when signing the certificate.\nThis is mutually exclusive with I(privatekey_path).",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the I(privatekey_path) resp. I(privatekey_content).\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "Path to the private key to use when signing the certificate.\nThis is mutually exclusive with I(privatekey_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "provider": {
          "aliases": [],
          "description": "Name of the provider to use to generate/retrieve the OpenSSL certificate. Please see the examples on how to emulate it with M(community.crypto.x509_certificate_info), M(community.crypto.openssl_csr_info), M(community.crypto.openssl_privatekey_info) and M(ansible.builtin.assert).\nThe C(entrust) provider was added for Ansible 2.9 and requires credentials for the L(Entrust Certificate Services,https://www.entrustdatacard.com/products/categories/ssl-certificates) (ECS) API.\nRequired if I(state) is C(present).",
          "type": "str",
          "required": false,
          "choices": [
            "acme",
            "entrust",
            "ownca",
            "selfsigned"
          ],
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) certificate's content as I(certificate).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_create_subject_key_identifier": {
          "aliases": [],
          "description": "Whether to create the Subject Key Identifier (SKI) from the public key.\nA value of C(create_if_not_provided) (default) only creates a SKI when the CSR does not provide one.\nA value of C(always_create) always creates a SKI. If the CSR provides one, that one is ignored.\nA value of C(never_create) never creates a SKI. If the CSR provides one, that one is used.\nThis is only used by the C(selfsigned) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "create_if_not_provided",
          "type": "str",
          "required": false,
          "choices": [
            "create_if_not_provided",
            "always_create",
            "never_create"
          ],
          "suboptions": {}
        },
        "selfsigned_digest": {
          "aliases": [],
          "description": "Digest algorithm to be used when self-signing the certificate.\nThis is only used by the C(selfsigned) provider.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_not_after": {
          "aliases": [
            "selfsigned_notAfter"
          ],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will stop being valid 10 years from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(selfsigned) provider.\nOn macOS 10.15 and onwards, TLS server certificates must have a validity period of 825 days or fewer. Please see U(https://support.apple.com/en-us/HT210176) for more details.",
          "default": "+3650d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_not_before": {
          "aliases": [
            "selfsigned_notBefore"
          ],
          "description": "The point in time the certificate is valid from.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will start being valid from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(selfsigned) provider.",
          "default": "+0s",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_version": {
          "aliases": [],
          "description": "Version of the C(selfsigned) certificate.\nNowadays it should almost always be C(3).\nThis is only used by the C(selfsigned) provider.",
          "default": "3",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the certificate should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "acme-tiny >= 4.0.0 (if using the C(acme) provider)",
        "cryptography >= 1.6 (if using C(selfsigned) or C(ownca) provider)"
      ],
      "short_description": "Generate and/or check OpenSSL certificates"
    },
    "examples": "\n- name: Generate a Self Signed OpenSSL certificate\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    provider: selfsigned\n\n- name: Generate an OpenSSL certificate signed with your own CA certificate\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    ownca_path: /etc/ssl/crt/ansible_CA.crt\n    ownca_privatekey_path: /etc/ssl/private/ansible_CA.pem\n    provider: ownca\n\n- name: Generate a Let's Encrypt Certificate\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    provider: acme\n    acme_accountkey_path: /etc/ssl/private/ansible.com.pem\n    acme_challenge_path: /etc/ssl/challenges/ansible.com/\n\n- name: Force (re-)generate a new Let's Encrypt Certificate\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    provider: acme\n    acme_accountkey_path: /etc/ssl/private/ansible.com.pem\n    acme_challenge_path: /etc/ssl/challenges/ansible.com/\n    force: yes\n\n- name: Generate an Entrust certificate via the Entrust Certificate Services (ECS) API\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    provider: entrust\n    entrust_requester_name: Jo Doe\n    entrust_requester_email: jdoe@ansible.com\n    entrust_requester_phone: 555-555-5555\n    entrust_cert_type: STANDARD_SSL\n    entrust_api_user: apiusername\n    entrust_api_key: a^lv*32!cd9LnT\n    entrust_api_client_cert_path: /etc/ssl/entrust/ecs-client.crt\n    entrust_api_client_cert_key_path: /etc/ssl/entrust/ecs-key.crt\n    entrust_api_specification_path: /etc/ssl/entrust/api-docs/cms-api-2.1.0.yaml\n\n# The following example shows how to emulate the behavior of the removed\n# \"assertonly\" provider with the x509_certificate_info, openssl_csr_info,\n# openssl_privatekey_info and assert modules:\n\n- name: Get certificate information\n  community.crypto.x509_certificate_info:\n    path: /etc/ssl/crt/ansible.com.crt\n    # for valid_at, invalid_at and valid_in\n    valid_at:\n      one_day_ten_hours: \"+1d10h\"\n      fixed_timestamp: 20200331202428Z\n      ten_seconds: \"+10\"\n  register: result\n\n- name: Get CSR information\n  community.crypto.openssl_csr_info:\n    # Verifies that the CSR signature is valid; module will fail if not\n    path: /etc/ssl/csr/ansible.com.csr\n  register: result_csr\n\n- name: Get private key information\n  community.crypto.openssl_privatekey_info:\n    path: /etc/ssl/csr/ansible.com.key\n  register: result_privatekey\n\n- assert:\n    that:\n      # When private key was specified for assertonly, this was checked:\n      - result.public_key == result_privatekey.public_key\n      # When CSR was specified for assertonly, this was checked:\n      - result.public_key == result_csr.public_key\n      - result.subject_ordered == result_csr.subject_ordered\n      - result.extensions_by_oid == result_csr.extensions_by_oid\n      # signature_algorithms check\n      - \"result.signature_algorithm == 'sha256WithRSAEncryption' or result.signature_algorithm == 'sha512WithRSAEncryption'\"\n      # subject and subject_strict\n      - \"result.subject.commonName == 'ansible.com'\"\n      - \"result.subject | length == 1\"  # the number must be the number of entries you check for\n      # issuer and issuer_strict\n      - \"result.issuer.commonName == 'ansible.com'\"\n      - \"result.issuer | length == 1\"  # the number must be the number of entries you check for\n      # has_expired\n      - not result.expired\n      # version\n      - result.version == 3\n      # key_usage and key_usage_strict\n      - \"'Data Encipherment' in result.key_usage\"\n      - \"result.key_usage | length == 1\"  # the number must be the number of entries you check for\n      # extended_key_usage and extended_key_usage_strict\n      - \"'DVCS' in result.extended_key_usage\"\n      - \"result.extended_key_usage | length == 1\"  # the number must be the number of entries you check for\n      # subject_alt_name and subject_alt_name_strict\n      - \"'dns:ansible.com' in result.subject_alt_name\"\n      - \"result.subject_alt_name | length == 1\"  # the number must be the number of entries you check for\n      # not_before and not_after\n      - \"result.not_before == '20190331202428Z'\"\n      - \"result.not_after == '20190413202428Z'\"\n      # valid_at, invalid_at and valid_in\n      - \"result.valid_at.one_day_ten_hours\"  # for valid_at\n      - \"not result.valid_at.fixed_timestamp\"  # for invalid_at\n      - \"result.valid_at.ten_seconds\"  # for valid_in\n"
  },
  "community.crypto.x509_certificate_info": {
    "doc": {
      "description": "This module allows one to query information on OpenSSL certificates.\nIt uses the cryptography python library to interact with OpenSSL.\nNote that this module was called C(openssl_certificate_info) when included directly in Ansible up to version 2.9.  When moved to the collection C(community.crypto), it was renamed to M(community.crypto.x509_certificate_info). From Ansible 2.10 on, it can still be used by the old short name (or by C(ansible.builtin.openssl_certificate_info)), which redirects to C(community.crypto.x509_certificate_info). When using FQCNs or when using the L(collections,https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#using-collections-in-a-playbook) keyword, the new name M(community.crypto.x509_certificate_info) should be used to avoid a deprecation warning.",
      "has_action": false,
      "notes": "All timestamp values are provided in ASN.1 TIME format, in other words, following the C(YYYYMMDDHHMMSSZ) pattern. They are all in UTC.\nSupports C(check_mode).",
      "options": {
        "content": {
          "aliases": [],
          "description": "Content of the X.509 certificate in PEM format.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the certificate file is loaded from.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "valid_at": {
          "aliases": [],
          "description": "A dict of names mapping to time specifications. Every time specified here will be checked whether the certificate is valid at this point. See the C(valid_at) return value for informations on the result.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h), and ASN.1 TIME (in other words, pattern C(YYYYMMDDHHMMSSZ)). Note that all timestamps will be treated as being in UTC.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.6"
      ],
      "short_description": "Provide information of OpenSSL X.509 certificates"
    },
    "examples": "\n- name: Generate a Self Signed OpenSSL certificate\n  community.crypto.x509_certificate:\n    path: /etc/ssl/crt/ansible.com.crt\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    csr_path: /etc/ssl/csr/ansible.com.csr\n    provider: selfsigned\n\n\n# Get information on the certificate\n\n- name: Get information on generated certificate\n  community.crypto.x509_certificate_info:\n    path: /etc/ssl/crt/ansible.com.crt\n  register: result\n\n- name: Dump information\n  ansible.builtin.debug:\n    var: result\n\n\n# Check whether the certificate is valid or not valid at certain times, fail\n# if this is not the case. The first task (x509_certificate_info) collects\n# the information, and the second task (assert) validates the result and\n# makes the playbook fail in case something is not as expected.\n\n- name: Test whether that certificate is valid tomorrow and/or in three weeks\n  community.crypto.x509_certificate_info:\n    path: /etc/ssl/crt/ansible.com.crt\n    valid_at:\n      point_1: \"+1d\"\n      point_2: \"+3w\"\n  register: result\n\n- name: Validate that certificate is valid tomorrow, but not in three weeks\n  assert:\n    that:\n      - result.valid_at.point_1      # valid in one day\n      - not result.valid_at.point_2  # not valid in three weeks\n"
  },
  "community.crypto.x509_certificate_pipe": {
    "doc": {
      "description": "It implements a notion of provider (ie. C(selfsigned), C(ownca), C(entrust)) for your certificate.\nIt uses the cryptography python library to interact with OpenSSL.\nPlease note that the module regenerates an existing certificate if it does not match the module's options, or if it seems to be corrupt. If you are concerned that this could overwrite your existing certificate, consider using the I(backup) option.\nThe C(ownca) provider is intended for generating an OpenSSL certificate signed with your own CA (Certificate Authority) certificate (self-signed certificate).\nThis module allows one to (re)generate OpenSSL certificates.",
      "has_action": false,
      "notes": "Supports C(check_mode).\nAll ASN.1 TIME values should be specified following the YYYYMMDDHHMMSSZ pattern.\nDate specified should be UTC. Minutes and seconds are mandatory.\nFor security reason, when you use C(ownca) provider, you should NOT run M(community.crypto.x509_certificate) on a target machine, but on a dedicated CA machine. It is recommended not to store the CA private key on the target machine. Once signed, the certificate can be moved to the target machine.\nFor the C(selfsigned) provider, I(csr_path) and I(csr_content) are optional. If not provided, a certificate without any information (Subject, Subject Alternative Names, Key Usage, etc.) is created.",
      "options": {
        "content": {
          "aliases": [],
          "description": "The existing certificate.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "csr_content": {
          "aliases": [],
          "description": "Content of the Certificate Signing Request (CSR) used to generate this certificate.\nThis is mutually exclusive with I(csr_path).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "csr_path": {
          "aliases": [],
          "description": "Path to the Certificate Signing Request (CSR) used to generate this certificate.\nThis is mutually exclusive with I(csr_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_client_cert_key_path": {
          "aliases": [],
          "description": "The path to the private key of the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_client_cert_path": {
          "aliases": [],
          "description": "The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_key": {
          "aliases": [],
          "description": "The key (password) for authentication to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_specification_path": {
          "aliases": [],
          "description": "The path to the specification file defining the Entrust Certificate Services (ECS) API configuration.\nYou can use this to keep a local copy of the specification to avoid downloading it every time the module is used.\nThis is only used by the C(entrust) provider.",
          "default": "https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "entrust_api_user": {
          "aliases": [],
          "description": "The username for authentication to the Entrust Certificate Services (ECS) API.\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_cert_type": {
          "aliases": [],
          "description": "Specify the type of certificate requested.\nThis is only used by the C(entrust) provider.",
          "default": "STANDARD_SSL",
          "type": "str",
          "required": false,
          "choices": [
            "STANDARD_SSL",
            "ADVANTAGE_SSL",
            "UC_SSL",
            "EV_SSL",
            "WILDCARD_SSL",
            "PRIVATE_SSL",
            "PD_SSL",
            "CDS_ENT_LITE",
            "CDS_ENT_PRO",
            "SMIME_ENT"
          ],
          "suboptions": {}
        },
        "entrust_not_after": {
          "aliases": [],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as an absolute timestamp.\nA valid absolute time format is C(ASN.1 TIME) such as C(2019-06-18).\nA valid relative time format is C([+-]timespec) where timespec can be an integer + C([w | d | h | m | s]), such as C(+365d) or C(+32w1d2h)).\nTime will always be interpreted as UTC.\nNote that only the date (day, month, year) is supported for specifying the expiry date of the issued certificate.\nThe full date-time is adjusted to EST (GMT -5:00) before issuance, which may result in a certificate with an expiration date one day earlier than expected if a relative time is used.\nThe minimum certificate lifetime is 90 days, and maximum is three years.\nIf this value is not specified, the certificate will stop being valid 365 days the date of issue.\nThis is only used by the C(entrust) provider.\nPlease note that this value is B(not) covered by the I(ignore_timestamps) option.",
          "default": "+365d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_email": {
          "aliases": [],
          "description": "The email of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_name": {
          "aliases": [],
          "description": "The name of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "entrust_requester_phone": {
          "aliases": [],
          "description": "The phone number of the requester of the certificate (for tracking purposes).\nThis is only used by the C(entrust) provider.\nThis is required if the provider is C(entrust).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Generate the certificate, even if it already exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ignore_timestamps": {
          "aliases": [],
          "description": "Whether the \"not before\" and \"not after\" timestamps should be ignored for idempotency checks.\nIt is better to keep the default value C(true) when using relative timestamps (like C(+0s) for now).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "ownca_content": {
          "aliases": [],
          "description": "Content of the CA (Certificate Authority) certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_path).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_create_authority_key_identifier": {
          "aliases": [],
          "description": "Create a Authority Key Identifier from the CA's certificate. If the CSR provided a authority key identifier, it is ignored.\nThe Authority Key Identifier is generated from the CA certificate's Subject Key Identifier, if available. If it is not available, the CA certificate's public key will be used.\nThis is only used by the C(ownca) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ownca_create_subject_key_identifier": {
          "aliases": [],
          "description": "Whether to create the Subject Key Identifier (SKI) from the public key.\nA value of C(create_if_not_provided) (default) only creates a SKI when the CSR does not provide one.\nA value of C(always_create) always creates a SKI. If the CSR provides one, that one is ignored.\nA value of C(never_create) never creates a SKI. If the CSR provides one, that one is used.\nThis is only used by the C(ownca) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "create_if_not_provided",
          "type": "str",
          "required": false,
          "choices": [
            "create_if_not_provided",
            "always_create",
            "never_create"
          ],
          "suboptions": {}
        },
        "ownca_digest": {
          "aliases": [],
          "description": "The digest algorithm to be used for the C(ownca) certificate.\nThis is only used by the C(ownca) provider.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_not_after": {
          "aliases": [],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will stop being valid 10 years from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(ownca) provider.\nOn macOS 10.15 and onwards, TLS server certificates must have a validity period of 825 days or fewer. Please see U(https://support.apple.com/en-us/HT210176) for more details.",
          "default": "+3650d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_not_before": {
          "aliases": [],
          "description": "The point in time the certificate is valid from.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will start being valid from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(ownca) provider.",
          "default": "+0s",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_path": {
          "aliases": [],
          "description": "Remote absolute path of the CA (Certificate Authority) certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "ownca_privatekey_content": {
          "aliases": [],
          "description": "Content of the CA (Certificate Authority) private key to use when signing the certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_privatekey_path).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the I(ownca_privatekey_path) resp. I(ownca_privatekey_content).\nThis is only used by the C(ownca) provider.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ownca_privatekey_path": {
          "aliases": [],
          "description": "Path to the CA (Certificate Authority) private key to use when signing the certificate.\nThis is only used by the C(ownca) provider.\nThis is mutually exclusive with I(ownca_privatekey_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "ownca_version": {
          "aliases": [],
          "description": "The version of the C(ownca) certificate.\nNowadays it should almost always be C(3).\nThis is only used by the C(ownca) provider.",
          "default": "3",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "Path to the private key to use when signing the certificate.\nThis is mutually exclusive with I(privatekey_path).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the I(privatekey_path) resp. I(privatekey_content).\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "Path to the private key to use when signing the certificate.\nThis is mutually exclusive with I(privatekey_content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "provider": {
          "aliases": [],
          "description": "Name of the provider to use to generate/retrieve the OpenSSL certificate.\nThe C(entrust) provider requires credentials for the L(Entrust Certificate Services,https://www.entrustdatacard.com/products/categories/ssl-certificates) (ECS) API.",
          "type": "str",
          "required": true,
          "choices": [
            "entrust",
            "ownca",
            "selfsigned"
          ],
          "suboptions": {}
        },
        "select_crypto_backend": {
          "aliases": [],
          "description": "Determines which crypto backend to use.\nThe default choice is C(auto), which tries to use C(cryptography) if available.\nIf set to C(cryptography), will try to use the L(cryptography,https://cryptography.io/) library.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "cryptography"
          ],
          "suboptions": {}
        },
        "selfsigned_create_subject_key_identifier": {
          "aliases": [],
          "description": "Whether to create the Subject Key Identifier (SKI) from the public key.\nA value of C(create_if_not_provided) (default) only creates a SKI when the CSR does not provide one.\nA value of C(always_create) always creates a SKI. If the CSR provides one, that one is ignored.\nA value of C(never_create) never creates a SKI. If the CSR provides one, that one is used.\nThis is only used by the C(selfsigned) provider.\nNote that this is only supported if the C(cryptography) backend is used!",
          "default": "create_if_not_provided",
          "type": "str",
          "required": false,
          "choices": [
            "create_if_not_provided",
            "always_create",
            "never_create"
          ],
          "suboptions": {}
        },
        "selfsigned_digest": {
          "aliases": [],
          "description": "Digest algorithm to be used when self-signing the certificate.\nThis is only used by the C(selfsigned) provider.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_not_after": {
          "aliases": [
            "selfsigned_notAfter"
          ],
          "description": "The point in time at which the certificate stops being valid.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will stop being valid 10 years from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(selfsigned) provider.\nOn macOS 10.15 and onwards, TLS server certificates must have a validity period of 825 days or fewer. Please see U(https://support.apple.com/en-us/HT210176) for more details.",
          "default": "+3650d",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_not_before": {
          "aliases": [
            "selfsigned_notBefore"
          ],
          "description": "The point in time the certificate is valid from.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nIf this value is not specified, the certificate will start being valid from now.\nNote that this value is B(not used to determine whether an existing certificate should be regenerated). This can be changed by setting the I(ignore_timestamps) option to C(false). Please note that you should avoid relative timestamps when setting I(ignore_timestamps=false).\nThis is only used by the C(selfsigned) provider.",
          "default": "+0s",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selfsigned_version": {
          "aliases": [],
          "description": "Version of the C(selfsigned) certificate.\nNowadays it should almost always be C(3).\nThis is only used by the C(selfsigned) provider.",
          "default": "3",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.6 (if using C(selfsigned) or C(ownca) provider)"
      ],
      "short_description": "Generate and/or check OpenSSL certificates",
      "version_added": "1.3.0"
    },
    "examples": "\n- name: Generate a Self Signed OpenSSL certificate\n  community.crypto.x509_certificate_pipe:\n    provider: selfsigned\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    csr_path: /etc/ssl/csr/ansible.com.csr\n  register: result\n- name: Print the certificate\n  ansible.builtin.debug:\n    var: result.certificate\n\n# In the following example, both CSR and certificate file are stored on the\n# machine where ansible-playbook is executed, while the OwnCA data (certificate,\n# private key) are stored on the remote machine.\n\n- name: (1/2) Generate an OpenSSL Certificate with the CSR provided inline\n  community.crypto.x509_certificate_pipe:\n    provider: ownca\n    content: \"{{ lookup('file', '/etc/ssl/csr/www.ansible.com.crt') }}\"\n    csr_content: \"{{ lookup('file', '/etc/ssl/csr/www.ansible.com.csr') }}\"\n    ownca_cert: /path/to/ca_cert.crt\n    ownca_privatekey: /path/to/ca_cert.key\n    ownca_privatekey_passphrase: hunter2\n  register: result\n\n- name: (2/2) Store certificate\n  ansible.builtin.copy:\n    dest: /etc/ssl/csr/www.ansible.com.crt\n    content: \"{{ result.certificate }}\"\n  delegate_to: localhost\n  when: result is changed\n\n# In the following example, the certificate from another machine is signed by\n# our OwnCA whose private key and certificate are only available on this\n# machine (where ansible-playbook is executed), without having to write\n# the certificate file to disk on localhost. The CSR could have been\n# provided by community.crypto.openssl_csr_pipe earlier, or also have been\n# read from the remote machine.\n\n- name: (1/3) Read certificate's contents from remote machine\n  ansible.builtin.slurp:\n    src: /etc/ssl/csr/www.ansible.com.crt\n  register: certificate_content\n\n- name: (2/3) Generate an OpenSSL Certificate with the CSR provided inline\n  community.crypto.x509_certificate_pipe:\n    provider: ownca\n    content: \"{{ certificate_content.content | b64decode }}\"\n    csr_content: \"{{ the_csr }}\"\n    ownca_cert: /path/to/ca_cert.crt\n    ownca_privatekey: /path/to/ca_cert.key\n    ownca_privatekey_passphrase: hunter2\n  delegate_to: localhost\n  register: result\n\n- name: (3/3) Store certificate\n  ansible.builtin.copy:\n    dest: /etc/ssl/csr/www.ansible.com.crt\n    content: \"{{ result.certificate }}\"\n  when: result is changed\n"
  },
  "community.crypto.x509_crl": {
    "doc": {
      "description": "This module allows one to (re)generate or update Certificate Revocation Lists (CRLs).\nCertificates on the revocation list can be either specified by serial number and (optionally) their issuer, or as a path to a certificate file in PEM format.",
      "has_action": false,
      "notes": "All ASN.1 TIME values should be specified following the YYYYMMDDHHMMSSZ pattern.\nDate specified should be UTC. Minutes and seconds are mandatory.\nSupports C(check_mode).",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including a timestamp so you can get the original CRL back if you overwrote it with a new one by accident.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "digest": {
          "aliases": [],
          "description": "Digest algorithm to be used when signing the CRL.",
          "default": "sha256",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Should the CRL be forced to be regenerated.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "format": {
          "aliases": [],
          "description": "Whether the CRL file should be in PEM or DER format.\nIf an existing CRL file does match everything but I(format), it will be converted to the correct format instead of regenerated.",
          "default": "pem",
          "type": "str",
          "required": false,
          "choices": [
            "pem",
            "der"
          ],
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ignore_timestamps": {
          "aliases": [],
          "description": "Whether the timestamps I(last_update), I(next_update) and I(revocation_date) (in I(revoked_certificates)) should be ignored for idempotency checks. The timestamp I(invalidity_date) in I(revoked_certificates) will never be ignored.\nUse this in combination with relative timestamps for these values to get idempotency.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "issuer": {
          "aliases": [],
          "description": "Key/value pairs that will be present in the issuer name field of the CRL.\nIf you need to specify more than one value with the same key, use a list as value.\nIf the order of the components is important, use I(issuer_ordered).\nOne of I(issuer) and I(issuer_ordered) is required if I(state) is C(present).\nMutually exclusive with I(issuer_ordered).",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "issuer_ordered": {
          "aliases": [],
          "description": "A list of dictionaries, where every dictionary must contain one key/value pair. This key/value pair will be present in the issuer name field of the CRL.\nIf you want to specify more than one value with the same key in a row, you can use a list as value.\nOne of I(issuer) and I(issuer_ordered) is required if I(state) is C(present).\nMutually exclusive with I(issuer).",
          "type": "list",
          "required": false,
          "elements": "dict",
          "version_added": "2.0.0",
          "suboptions": {}
        },
        "last_update": {
          "aliases": [],
          "description": "The point in time from which this CRL can be trusted.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nNote that if using relative time this module is NOT idempotent, except when I(ignore_timestamps) is set to C(yes).",
          "default": "+0s",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "Defines how to process entries of existing CRLs.\nIf set to C(generate), makes sure that the CRL has the exact set of revoked certificates as specified in I(revoked_certificates).\nIf set to C(update), makes sure that the CRL contains the revoked certificates from I(revoked_certificates), but can also contain other revoked certificates. If the CRL file already exists, all entries from the existing CRL will also be included in the new CRL. When using C(update), you might be interested in setting I(ignore_timestamps) to C(yes).",
          "default": "generate",
          "type": "str",
          "required": false,
          "choices": [
            "generate",
            "update"
          ],
          "suboptions": {}
        },
        "next_update": {
          "aliases": [],
          "description": "The absolute latest point in time by which this I(issuer) is expected to have issued another CRL. Many clients will treat a CRL as expired once I(next_update) occurs.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nNote that if using relative time this module is NOT idempotent, except when I(ignore_timestamps) is set to C(yes).\nRequired if I(state) is C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the generated CRL file should be created or is already located.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "privatekey_content": {
          "aliases": [],
          "description": "The content of the CA's private key to use when signing the CRL.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_passphrase": {
          "aliases": [],
          "description": "The passphrase for the I(privatekey_path).\nThis is required if the private key is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "privatekey_path": {
          "aliases": [],
          "description": "Path to the CA's private key to use when signing the CRL.\nEither I(privatekey_path) or I(privatekey_content) must be specified if I(state) is C(present), but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "If set to C(yes), will return the (current or generated) CRL's content as I(crl).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "revoked_certificates": {
          "aliases": [],
          "description": "List of certificates to be revoked.\nRequired if I(state) is C(present).",
          "type": "list",
          "required": false,
          "elements": "dict",
          "suboptions": {
            "content": {
              "aliases": [],
              "description": "Content of a certificate in PEM format.\nThe serial number and issuer will be extracted from the certificate.\nMutually exclusive with I(path) and I(serial_number). One of these three options must be specified.",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "invalidity_date": {
              "aliases": [],
              "description": "The point in time it was known/suspected that the private key was compromised or that the certificate otherwise became invalid.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nNote that if using relative time this module is NOT idempotent. This will NOT change when I(ignore_timestamps) is set to C(yes).",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "invalidity_date_critical": {
              "aliases": [],
              "description": "Whether the invalidity date extension should be critical.",
              "default": "False",
              "type": "bool",
              "required": false,
              "suboptions": {}
            },
            "issuer": {
              "aliases": [],
              "description": "The certificate's issuer.\nExample: C(DNS:ca.example.org)",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "issuer_critical": {
              "aliases": [],
              "description": "Whether the certificate issuer extension should be critical.",
              "default": "False",
              "type": "bool",
              "required": false,
              "suboptions": {}
            },
            "path": {
              "aliases": [],
              "description": "Path to a certificate in PEM format.\nThe serial number and issuer will be extracted from the certificate.\nMutually exclusive with I(content) and I(serial_number). One of these three options must be specified.",
              "type": "path",
              "required": false,
              "suboptions": {}
            },
            "reason": {
              "aliases": [],
              "description": "The value for the revocation reason extension.",
              "type": "str",
              "required": false,
              "choices": [
                "unspecified",
                "key_compromise",
                "ca_compromise",
                "affiliation_changed",
                "superseded",
                "cessation_of_operation",
                "certificate_hold",
                "privilege_withdrawn",
                "aa_compromise",
                "remove_from_crl"
              ],
              "suboptions": {}
            },
            "reason_critical": {
              "aliases": [],
              "description": "Whether the revocation reason extension should be critical.",
              "default": "False",
              "type": "bool",
              "required": false,
              "suboptions": {}
            },
            "revocation_date": {
              "aliases": [],
              "description": "The point in time the certificate was revoked.\nTime can be specified either as relative time or as absolute timestamp.\nTime will always be interpreted as UTC.\nValid format is C([+-]timespec | ASN.1 TIME) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h).\nNote that if using relative time this module is NOT idempotent, except when I(ignore_timestamps) is set to C(yes).",
              "default": "+0s",
              "type": "str",
              "required": false,
              "suboptions": {}
            },
            "serial_number": {
              "aliases": [],
              "description": "Serial number of the certificate.\nMutually exclusive with I(path) and I(content). One of these three options must be specified.",
              "type": "int",
              "required": false,
              "suboptions": {}
            }
          }
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the CRL file should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2"
      ],
      "short_description": "Generate Certificate Revocation Lists (CRLs)",
      "version_added": "1.0.0"
    },
    "examples": "\n- name: Generate a CRL\n  community.crypto.x509_crl:\n    path: /etc/ssl/my-ca.crl\n    privatekey_path: /etc/ssl/private/my-ca.pem\n    issuer:\n      CN: My CA\n    last_update: \"+0s\"\n    next_update: \"+7d\"\n    revoked_certificates:\n      - serial_number: 1234\n        revocation_date: 20190331202428Z\n        issuer:\n          CN: My CA\n      - serial_number: 2345\n        revocation_date: 20191013152910Z\n        reason: affiliation_changed\n        invalidity_date: 20191001000000Z\n      - path: /etc/ssl/crt/revoked-cert.pem\n        revocation_date: 20191010010203Z\n"
  },
  "community.crypto.x509_crl_info": {
    "doc": {
      "description": "This module allows one to retrieve information on Certificate Revocation Lists (CRLs).",
      "has_action": false,
      "notes": "All timestamp values are provided in ASN.1 TIME format, in other words, following the C(YYYYMMDDHHMMSSZ) pattern. They are all in UTC.\nSupports C(check_mode).",
      "options": {
        "content": {
          "aliases": [],
          "description": "Content of the X.509 CRL in PEM format, or Base64-encoded X.509 CRL.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "list_revoked_certificates": {
          "aliases": [],
          "description": "If set to C(false), the list of revoked certificates is not included in the result.\nThis is useful when retrieving information on large CRL files. Enumerating all revoked certificates can take some time, including serializing the result as JSON, sending it to the Ansible controller, and decoding it again.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.7.0",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Remote absolute path where the generated CRL file should be created or is already located.\nEither I(path) or I(content) must be specified, but not both.",
          "type": "path",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "cryptography >= 1.2"
      ],
      "short_description": "Retrieve information on Certificate Revocation Lists (CRLs)",
      "version_added": "1.0.0"
    },
    "examples": "\n- name: Get information on CRL\n  community.crypto.x509_crl_info:\n    path: /etc/ssl/my-ca.crl\n  register: result\n\n- name: Print the information\n  ansible.builtin.debug:\n    msg: \"{{ result }}\"\n\n- name: Get information on CRL without list of revoked certificates\n  community.crypto.x509_crl_info:\n    path: /etc/ssl/very-large.crl\n    list_revoked_certificates: false\n  register: result\n"
  }
}