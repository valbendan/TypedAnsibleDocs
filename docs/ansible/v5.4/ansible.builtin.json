{
  "add_host": {
    "doc": {
      "description": "Use variables to create new hosts and groups in inventory for use in later plays of the same playbook.\nTakes variables so you can define the new hosts more fully.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "The alias C(host) of the parameter C(name) is only available on Ansible 2.4 and newer.\nSince Ansible 2.4, the C(inventory_dir) variable is now set to C(None) instead of the 'global inventory source', because you can now have multiple sources.  An example was added that shows how to partially restore the previous behaviour.\nThough this module does not change the remote host, we do provide 'changed' status as it can be useful for those trying to track inventory changes.\nThe hosts added will not bypass the C(--limit) from the command line, so both of those need to be in agreement to make them available as play targets. They are still available from hostvars and for delegation as a normal part of the inventory.",
      "options": {
        "groups": {
          "aliases": [
            "group",
            "groupname"
          ],
          "description": "The groups to add the hostname to.",
          "type": "list",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "host",
            "hostname"
          ],
          "description": "The hostname/ip of the host to add to the inventory, can include a colon and a port number.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Add a host (and alternatively a group) to the ansible-playbook in-memory inventory",
      "version_added": "0.9"
    },
    "examples": "\n- name: Add host to group 'just_created' with variable foo=42\n  add_host:\n    name: '{{ ip_from_ec2 }}'\n    groups: just_created\n    foo: 42\n\n- name: Add host to multiple groups\n  add_host:\n    hostname: '{{ new_ip }}'\n    groups:\n    - group1\n    - group2\n\n- name: Add a host with a non-standard port local to your machines\n  add_host:\n    name: '{{ new_ip }}:{{ new_port }}'\n\n- name: Add a host alias that we reach through a tunnel (Ansible 1.9 and older)\n  add_host:\n    hostname: '{{ new_ip }}'\n    ansible_ssh_host: '{{ inventory_hostname }}'\n    ansible_ssh_port: '{{ new_port }}'\n\n- name: Add a host alias that we reach through a tunnel (Ansible 2.0 and newer)\n  add_host:\n    hostname: '{{ new_ip }}'\n    ansible_host: '{{ inventory_hostname }}'\n    ansible_port: '{{ new_port }}'\n\n- name: Ensure inventory vars are set to the same value as the inventory_hostname has (close to pre Ansible 2.4 behaviour)\n  add_host:\n    hostname: charlie\n    inventory_dir: '{{ inventory_dir }}'\n\n- name: Add all hosts running this playbook to the done group\n  add_host:\n    name: '{{ item }}'\n    groups: done\n  loop: \"{{ ansible_play_hosts }}\"\n"
  },
  "apt": {
    "doc": {
      "description": "Manages I(apt) packages (such as for Debian/Ubuntu).",
      "has_action": false,
      "notes": "Three of the upgrade modes (C(full), C(safe) and its alias C(yes)) required C(aptitude) up to 2.3, since 2.4 C(apt-get) is used as a fall-back.\nIn most cases, packages installed with apt will start newly installed services by default. Most distributions have mechanisms to avoid this. For example when installing Postgresql-9.5 in Debian 9, creating an excutable shell script (/usr/sbin/policy-rc.d) that throws a return code of 101 will stop Postgresql 9.5 starting up after install. Remove the file or remove its execute permission afterwards.\nThe apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user. Since we don't have warnings and prompts before installing we disallow this.Use an explicit fnmatch pattern if you want wildcarding)\nWhen used with a C(loop:) each package will be processed individually, it is much more efficient to pass the list directly to the I(name) option.",
      "options": {
        "allow_downgrade": {
          "aliases": [
            "allow-downgrade",
            "allow_downgrades",
            "allow-downgrades"
          ],
          "description": "Corresponds to the C(--allow-downgrades) option for I(apt).\nThis option enables the named package and version to replace an already installed higher version of that package.\nNote that setting I(allow_downgrade=true) can make this module behave in a non-idempotent way.\n(The task could end up with a set of packages that does not match the complete list of specified packages to install).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "allow_unauthenticated": {
          "aliases": [
            "allow-unauthenticated"
          ],
          "description": "Ignore if packages cannot be authenticated. This is useful for bootstrapping environments that manage their own apt-key setup.\nC(allow_unauthenticated) is only supported with state: I(install)/I(present)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "autoclean": {
          "aliases": [],
          "description": "If C(yes), cleans the local repository of retrieved package files that can no longer be downloaded.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "autoremove": {
          "aliases": [],
          "description": "If C(yes), remove unused dependency packages for all module states except I(build-dep). It can also be used as the only option.\nPrevious to version 2.4, autoclean was also an alias for autoremove, now it is its own separate command. See documentation for further information.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "cache_valid_time": {
          "aliases": [],
          "description": "Update the apt cache if it is older than the I(cache_valid_time). This option is set in seconds.\nAs of Ansible 2.4, if explicitly set, this sets I(update_cache=yes).",
          "default": "0",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "deb": {
          "aliases": [],
          "description": "Path to a .deb package on the remote machine.\nIf :// in the path, ansible will attempt to download deb before installing. (Version added 2.1)\nRequires the C(xz-utils) package to extract the control file of the deb package to install.",
          "type": "path",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "default_release": {
          "aliases": [
            "default-release"
          ],
          "description": "Corresponds to the C(-t) option for I(apt) and sets pin priorities",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "dpkg_options": {
          "aliases": [],
          "description": "Add dpkg options to apt command. Defaults to '-o \"Dpkg::Options::=--force-confdef\" -o \"Dpkg::Options::=--force-confold\"'\nOptions should be supplied as comma separated list",
          "default": "force-confdef,force-confold",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "fail_on_autoremove": {
          "aliases": [],
          "description": "Corresponds to the C(--no-remove) option for C(apt).\nIf C(yes), it is ensured that no packages will be removed or the task will fail.\nC(fail_on_autoremove) is only supported with state except C(absent)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Corresponds to the C(--force-yes) to I(apt-get) and implies C(allow_unauthenticated: yes) and C(allow_downgrade: yes)\nThis option will disable checking both the packages' signatures and the certificates of the web servers they are downloaded from.\nThis option *is not* the equivalent of passing the C(-f) flag to I(apt-get) on the command line\n**This is a destructive operation with the potential to destroy your system, and it should almost never be used.** Please also see C(man apt-get) for more information.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force_apt_get": {
          "aliases": [],
          "description": "Force usage of apt-get instead of aptitude",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "install_recommends": {
          "aliases": [
            "install-recommends"
          ],
          "description": "Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "lock_timeout": {
          "aliases": [],
          "description": "How many seconds will this action wait to acquire a lock on the apt db.\nSometimes there is a transitory lock and this will retry at least until timeout is hit.",
          "default": "60",
          "type": "int",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "package",
            "pkg"
          ],
          "description": "A list of package names, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "only_upgrade": {
          "aliases": [],
          "description": "Only upgrade a package if it is already installed.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "policy_rc_d": {
          "aliases": [],
          "description": "Force the exit code of /usr/sbin/policy-rc.d.\nFor example, if I(policy_rc_d=101) the installed package will not trigger a service start.\nIf /usr/sbin/policy-rc.d already exists, it is backed up and restored after the package installation.\nIf C(null), the /usr/sbin/policy-rc.d isn't created/changed.",
          "type": "int",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "purge": {
          "aliases": [],
          "description": "Will force purging of configuration files if the module state is set to I(absent).",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Indicates the desired package state. C(latest) ensures that the latest version is installed. C(build-dep) ensures the package build dependencies are installed. C(fixed) attempt to correct a system with broken dependencies in place.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "build-dep",
            "latest",
            "present",
            "fixed"
          ],
          "suboptions": {}
        },
        "update_cache": {
          "aliases": [
            "update-cache"
          ],
          "description": "Run the equivalent of C(apt-get update) before the operation. Can be run as part of the package installation or as a separate step.\nDefault is not to update the cache.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "update_cache_retries": {
          "aliases": [],
          "description": "Amount of retries if the cache update fails. Also see I(update_cache_retry_max_delay).",
          "default": "5",
          "type": "int",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "update_cache_retry_max_delay": {
          "aliases": [],
          "description": "Use an exponential backoff delay for each retry (see I(update_cache_retries)) up to this max delay in seconds.",
          "default": "12",
          "type": "int",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "upgrade": {
          "aliases": [],
          "description": "If yes or safe, performs an aptitude safe-upgrade.\nIf full, performs an aptitude full-upgrade.\nIf dist, performs an apt-get dist-upgrade.\nNote: This does not upgrade a specific package, use state=latest for that.\nNote: Since 2.4, apt-get is used as a fall-back if aptitude is not present.",
          "default": "no",
          "type": "str",
          "required": false,
          "choices": [
            "dist",
            "full",
            "no",
            "safe",
            "yes"
          ],
          "version_added": "1.1",
          "suboptions": {}
        }
      },
      "requirements": [
        "python-apt (python 2)",
        "python3-apt (python 3)",
        "aptitude (before 2.4)"
      ],
      "short_description": "Manages apt-packages",
      "version_added": "0.0.2"
    },
    "examples": "\n- name: Install apache httpd  (state=present is optional)\n  apt:\n    name: apache2\n    state: present\n\n- name: Update repositories cache and install \"foo\" package\n  apt:\n    name: foo\n    update_cache: yes\n\n- name: Remove \"foo\" package\n  apt:\n    name: foo\n    state: absent\n\n- name: Install the package \"foo\"\n  apt:\n    name: foo\n\n- name: Install a list of packages\n  apt:\n    pkg:\n    - foo\n    - foo-tools\n\n- name: Install the version '1.00' of package \"foo\"\n  apt:\n    name: foo=1.00\n\n- name: Update the repository cache and update package \"nginx\" to latest version using default release squeeze-backport\n  apt:\n    name: nginx\n    state: latest\n    default_release: squeeze-backports\n    update_cache: yes\n\n- name: Install the version '1.18.0' of package \"nginx\" and allow potential downgrades\n  apt:\n    name: nginx=1.18.0\n    state: present\n    allow_downgrade: yes\n\n- name: Install zfsutils-linux with ensuring conflicted packages (e.g. zfs-fuse) will not be removed.\n  apt:\n    name: zfsutils-linux\n    state: latest\n    fail_on_autoremove: yes\n\n- name: Install latest version of \"openjdk-6-jdk\" ignoring \"install-recommends\"\n  apt:\n    name: openjdk-6-jdk\n    state: latest\n    install_recommends: no\n\n- name: Update all packages to their latest version\n  apt:\n    name: \"*\"\n    state: latest\n\n- name: Upgrade the OS (apt-get dist-upgrade)\n  apt:\n    upgrade: dist\n\n- name: Run the equivalent of \"apt-get update\" as a separate step\n  apt:\n    update_cache: yes\n\n- name: Only run \"update_cache=yes\" if the last one is more than 3600 seconds ago\n  apt:\n    update_cache: yes\n    cache_valid_time: 3600\n\n- name: Pass options to dpkg on run\n  apt:\n    upgrade: dist\n    update_cache: yes\n    dpkg_options: 'force-confold,force-confdef'\n\n- name: Install a .deb package\n  apt:\n    deb: /tmp/mypackage.deb\n\n- name: Install the build dependencies for package \"foo\"\n  apt:\n    pkg: foo\n    state: build-dep\n\n- name: Install a .deb package from the internet\n  apt:\n    deb: https://example.com/python-ppq_0.1-1_all.deb\n\n- name: Remove useless packages from the cache\n  apt:\n    autoclean: yes\n\n- name: Remove dependencies that are no longer required\n  apt:\n    autoremove: yes\n"
  },
  "apt_key": {
    "doc": {
      "description": "Add or remove an I(apt) key, optionally downloading it.",
      "has_action": false,
      "notes": "The apt-key command has been deprecated and suggests to 'manage keyring files in trusted.gpg.d instead'. See the Debian wiki for details. This module is kept for backwards compatiblity for systems that still use apt-key as the main way to manage apt repository keys.\nAs a sanity check, downloaded key id must match the one specified.\nUse full fingerprint (40 characters) key ids to avoid key collisions. To generate a full-fingerprint imported key: C(apt-key adv --list-public-keys --with-fingerprint --with-colons).\nIf you specify both the key id and the URL with C(state=present), the task can verify or add the key as needed.\nAdding a new key requires an apt cache update (e.g. using the M(ansible.builtin.apt) module's update_cache option).",
      "options": {
        "data": {
          "aliases": [],
          "description": "The keyfile contents to add to the keyring.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "file": {
          "aliases": [],
          "description": "The path to a keyfile on the remote server to add to the keyring.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "id": {
          "aliases": [],
          "description": "The identifier of the key.\nIncluding this allows check mode to correctly report the changed state.\nIf specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead.\nThis parameter is required when C(state) is set to C(absent).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "keyring": {
          "aliases": [],
          "description": "The full path to specific keyring file in C(/etc/apt/trusted.gpg.d/).",
          "type": "path",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "keyserver": {
          "aliases": [],
          "description": "The keyserver to retrieve key from.",
          "type": "str",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Ensures that the key is present (added) or absent (revoked).",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "The URL to retrieve key from.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "gpg"
      ],
      "short_description": "Add or remove an apt key",
      "version_added": "1.0"
    },
    "examples": "\n- name: Add an apt key by id from a keyserver\n  ansible.builtin.apt_key:\n    keyserver: keyserver.ubuntu.com\n    id: 36A1D7869245C8950F966E92D8576A8BA88D21E9\n\n- name: Add an Apt signing key, uses whichever key is at the URL\n  ansible.builtin.apt_key:\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    state: present\n\n- name: Add an Apt signing key, will not download if present\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    state: present\n\n- name: Remove a Apt specific signing key, leading 0x is valid\n  ansible.builtin.apt_key:\n    id: 0x9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    state: absent\n\n# Use armored file since utf-8 string is expected. Must be of \"PGP PUBLIC KEY BLOCK\" type.\n- name: Add a key from a file on the Ansible server\n  ansible.builtin.apt_key:\n    data: \"{{ lookup('file', 'apt.asc') }}\"\n    state: present\n\n- name: Add an Apt signing key to a specific keyring file\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc\n    keyring: /etc/apt/trusted.gpg.d/debian.gpg\n\n- name: Add Apt signing key on remote server to keyring\n  ansible.builtin.apt_key:\n    id: 9FED2BCBDCD29CDF762678CBAED4B06F473041FA\n    file: /tmp/apt.gpg\n    state: present\n"
  },
  "apt_repository": {
    "doc": {
      "description": "Add or remove an APT repositories in Ubuntu and Debian.",
      "has_action": false,
      "notes": "This module supports Debian Squeeze (version 6) as well as its successors and derivatives.",
      "options": {
        "codename": {
          "aliases": [],
          "description": "Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (for example, Debian or Mint).",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "filename": {
          "aliases": [],
          "description": "Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "install_python_apt": {
          "aliases": [],
          "description": "Whether to automatically try to install the Python apt library or not, if it is not already installed. Without this library, the module does not work.\nRuns C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3.\nOnly works with the system Python 2 or Python 3. If you are using a Python on the remote that is not the system Python, set I(install_python_apt=false) and ensure that the Python apt library for your Python version is installed some other way.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The octal mode for newly created files in sources.list.d.\nDefault is what system uses (probably 0644).",
          "type": "raw",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "repo": {
          "aliases": [],
          "description": "A source string for the repository.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "A source string state.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "update_cache": {
          "aliases": [
            "update-cache"
          ],
          "description": "Run the equivalent of C(apt-get update) when a change occurs.  Cache updates are run after making changes.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "update_cache_retries": {
          "aliases": [],
          "description": "Amount of retries if the cache update fails. Also see I(update_cache_retry_max_delay).",
          "default": "5",
          "type": "int",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "update_cache_retry_max_delay": {
          "aliases": [],
          "description": "Use an exponential backoff delay for each retry (see I(update_cache_retries)) up to this max delay in seconds.",
          "default": "12",
          "type": "int",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        }
      },
      "requirements": [
        "python-apt (python 2)",
        "python3-apt (python 3)"
      ],
      "short_description": "Add and remove APT repositories",
      "version_added": "0.7"
    },
    "examples": "\n- name: Add specified repository into sources list\n  ansible.builtin.apt_repository:\n    repo: deb http://archive.canonical.com/ubuntu hardy partner\n    state: present\n\n- name: Add specified repository into sources list using specified filename\n  ansible.builtin.apt_repository:\n    repo: deb http://dl.google.com/linux/chrome/deb/ stable main\n    state: present\n    filename: google-chrome\n\n- name: Add source repository into sources list\n  ansible.builtin.apt_repository:\n    repo: deb-src http://archive.canonical.com/ubuntu hardy partner\n    state: present\n\n- name: Remove specified repository from sources list\n  ansible.builtin.apt_repository:\n    repo: deb http://archive.canonical.com/ubuntu hardy partner\n    state: absent\n\n- name: Add nginx stable repository from PPA and install its signing key on Ubuntu target\n  ansible.builtin.apt_repository:\n    repo: ppa:nginx/stable\n\n- name: Add nginx stable repository from PPA and install its signing key on Debian target\n  ansible.builtin.apt_repository:\n    repo: 'ppa:nginx/stable'\n    codename: trusty\n"
  },
  "assemble": {
    "doc": {
      "description": "Assembles a configuration file from fragments.\nOften a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. C(assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file.\nFiles are assembled in string sorting order.\nPuppet calls this idea I(fragments).",
      "has_action": true,
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file (if C(yes)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "decrypt": {
          "aliases": [],
          "description": "This option controls the autodecryption of source files using vault.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "delimiter": {
          "aliases": [],
          "description": "A delimiter to separate the file contents.",
          "type": "str",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "A file to create using the concatenation of all of the source files.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ignore_hidden": {
          "aliases": [],
          "description": "A boolean that controls if files that start with a '.' will be included or not.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "regexp": {
          "aliases": [],
          "description": "Assemble files only if C(regex) matches the filename.\nIf not set, all files are assembled.\nEvery \"\\\" (backslash) must be escaped as \"\\\\\" to comply to YAML syntax.\nUses L(Python regular expressions,https://docs.python.org/3/library/re.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "remote_src": {
          "aliases": [],
          "description": "If C(no), it will search for src at originating/master machine.\nIf C(yes), it will go to the remote/target machine for the src.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "An already existing directory full of source files.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying into place.\nThe path to the file to validate is passed in via '%s' which must be present as in the sshd example below.\nThe command is passed securely so shell features like expansion and pipes won't work.",
          "type": "str",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        }
      },
      "short_description": "Assemble configuration files from fragments",
      "version_added": "0.5"
    },
    "examples": "\n- name: Assemble from fragments from a directory\n  ansible.builtin.assemble:\n    src: /etc/someapp/fragments\n    dest: /etc/someapp/someapp.conf\n\n- name: Insert the provided delimiter between fragments\n  ansible.builtin.assemble:\n    src: /etc/someapp/fragments\n    dest: /etc/someapp/someapp.conf\n    delimiter: '### START FRAGMENT ###'\n\n- name: Assemble a new \"sshd_config\" file into place, after passing validation with sshd\n  ansible.builtin.assemble:\n    src: /etc/ssh/conf.d/\n    dest: /etc/ssh/sshd_config\n    validate: /usr/sbin/sshd -t -f %s\n"
  },
  "assert": {
    "doc": {
      "description": "This module asserts that given expressions are true with an optional custom message.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "options": {
        "fail_msg": {
          "aliases": [
            "msg"
          ],
          "description": "The customized message used for a failing assertion.\nThis argument was called 'msg' before Ansible 2.7, now it is renamed to 'fail_msg' with alias 'msg'.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "quiet": {
          "aliases": [],
          "description": "Set this to C(yes) to avoid verbose output.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "success_msg": {
          "aliases": [],
          "description": "The customized message used for a successful assertion.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "that": {
          "aliases": [],
          "description": "A list of string expressions of the same form that can be passed to the 'when' statement.",
          "type": "list",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Asserts given expressions are true",
      "version_added": "1.5"
    },
    "examples": "\n- assert: { that: \"ansible_os_family != 'RedHat'\" }\n\n- assert:\n    that:\n      - \"'foo' in some_command_result.stdout\"\n      - number_of_the_counting == 3\n\n- name: After version 2.7 both 'msg' and 'fail_msg' can customize failing assertion message\n  assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    fail_msg: \"'my_param' must be between 0 and 100\"\n    success_msg: \"'my_param' is between 0 and 100\"\n\n- name: Please use 'msg' when ansible version is smaller than 2.7\n  assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    msg: \"'my_param' must be between 0 and 100\"\n\n- name: Use quiet to avoid verbose output\n  assert:\n    that:\n      - my_param <= 100\n      - my_param >= 0\n    quiet: true\n"
  },
  "async_status": {
    "doc": {
      "description": "This module gets the status of an asynchronous task.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "options": {
        "jid": {
          "aliases": [],
          "description": "Job or task identifier",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "If C(status), obtain the status.\nIf C(cleanup), clean up the async job cache (by default in C(~/.ansible_async/)) for the specified job I(jid).",
          "default": "status",
          "type": "str",
          "required": false,
          "choices": [
            "cleanup",
            "status"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Obtain status of asynchronous task",
      "version_added": "0.5"
    },
    "examples": "\n---\n- name: Asynchronous yum task\n  yum:\n    name: docker-io\n    state: present\n  async: 1000\n  poll: 0\n  register: yum_sleeper\n\n- name: Wait for asynchronous job to end\n  async_status:\n    jid: '{{ yum_sleeper.ansible_job_id }}'\n  register: job_result\n  until: job_result.finished\n  retries: 100\n  delay: 10\n"
  },
  "blockinfile": {
    "doc": {
      "description": "This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.",
      "has_action": false,
      "notes": "When using 'with_*' loops be aware that if you do not set a unique mark the block will be overwritten on each iteration.\nAs of Ansible 2.3, the I(dest) option has been changed to I(path) as default, but I(dest) still works as well.\nOption I(follow) has been removed in Ansible 2.5, because this module modifies the contents of the file so I(follow=no) doesn't make sense.\nWhen more then one block should be handled in one file you must change the I(marker) per task.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "block": {
          "aliases": [
            "content"
          ],
          "description": "The text to insert inside the marker lines.\nIf it is missing or an empty string, the block will be removed as if C(state) were specified to C(absent).",
          "default": "",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "create": {
          "aliases": [],
          "description": "Create a new file if it does not exist.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "insertafter": {
          "aliases": [],
          "description": "If specified and no begin/ending C(marker) lines are found, the block will be inserted after the last match of specified regular expression.\nA special value is available; C(EOF) for inserting the block at the end of the file.\nIf specified regular expression has no matches, C(EOF) will be used instead.",
          "default": "EOF",
          "type": "str",
          "required": false,
          "choices": [
            "EOF",
            "*regex*"
          ],
          "suboptions": {}
        },
        "insertbefore": {
          "aliases": [],
          "description": "If specified and no begin/ending C(marker) lines are found, the block will be inserted before the last match of specified regular expression.\nA special value is available; C(BOF) for inserting the block at the beginning of the file.\nIf specified regular expression has no matches, the block will be inserted at the end of the file.",
          "type": "str",
          "required": false,
          "choices": [
            "BOF",
            "*regex*"
          ],
          "suboptions": {}
        },
        "marker": {
          "aliases": [],
          "description": "The marker line template.\nC({mark}) will be replaced with the values in C(marker_begin) (default=\"BEGIN\") and C(marker_end) (default=\"END\").\nUsing a custom marker without the C({mark}) variable may result in the block being repeatedly inserted on subsequent playbook runs.",
          "default": "# {mark} ANSIBLE MANAGED BLOCK",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "marker_begin": {
          "aliases": [],
          "description": "This will be inserted at C({mark}) in the opening ansible block marker.",
          "default": "BEGIN",
          "type": "str",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "marker_end": {
          "aliases": [],
          "description": "This will be inserted at C({mark}) in the closing ansible block marker.",
          "default": "END",
          "type": "str",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "destfile",
            "name"
          ],
          "description": "The file to modify.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the block should be there or not.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying the updated file into the final destination.\nA temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.\nAlso, the command is passed securely so shell features such as expansion and pipes will not work.\nFor an example on how to handle more complex validation than what this option provides, see L(Complex configuration validation,https://docs.ansible.com/ansible/devel/reference_appendices/faq.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Insert/update/remove a text block surrounded by marker lines",
      "version_added": "2.0"
    },
    "examples": "\n# Before Ansible 2.3, option 'dest' or 'name' was used instead of 'path'\n- name: Insert/Update \"Match User\" configuration block in /etc/ssh/sshd_config\n  blockinfile:\n    path: /etc/ssh/sshd_config\n    block: |\n      Match User ansible-agent\n      PasswordAuthentication no\n\n- name: Insert/Update eth0 configuration stanza in /etc/network/interfaces\n        (it might be better to copy files into /etc/network/interfaces.d/)\n  blockinfile:\n    path: /etc/network/interfaces\n    block: |\n      iface eth0 inet static\n          address 192.0.2.23\n          netmask 255.255.255.0\n\n- name: Insert/Update configuration using a local file and validate it\n  blockinfile:\n    block: \"{{ lookup('file', './local/sshd_config') }}\"\n    path: /etc/ssh/sshd_config\n    backup: yes\n    validate: /usr/sbin/sshd -T -f %s\n\n- name: Insert/Update HTML surrounded by custom markers after <body> line\n  blockinfile:\n    path: /var/www/html/index.html\n    marker: \"<!-- {mark} ANSIBLE MANAGED BLOCK -->\"\n    insertafter: \"<body>\"\n    block: |\n      <h1>Welcome to {{ ansible_hostname }}</h1>\n      <p>Last updated on {{ ansible_date_time.iso8601 }}</p>\n\n- name: Remove HTML as well as surrounding markers\n  blockinfile:\n    path: /var/www/html/index.html\n    marker: \"<!-- {mark} ANSIBLE MANAGED BLOCK -->\"\n    block: \"\"\n\n- name: Add mappings to /etc/hosts\n  blockinfile:\n    path: /etc/hosts\n    block: |\n      {{ item.ip }} {{ item.name }}\n    marker: \"# {mark} ANSIBLE MANAGED BLOCK {{ item.name }}\"\n  loop:\n    - { name: host1, ip: 10.10.1.10 }\n    - { name: host2, ip: 10.10.1.11 }\n    - { name: host3, ip: 10.10.1.12 }\n"
  },
  "command": {
    "doc": {
      "description": "The C(command) module takes the command name followed by a list of space-delimited arguments.\nThe given command will be executed on all selected nodes.\nThe command(s) will not be processed through the shell, so variables like C($HOSTNAME) and operations like C(\"*\"), C(\"<\"), C(\">\"), C(\"|\"), C(\";\") and C(\"&\") will not work. Use the M(ansible.builtin.shell) module if you need these features.\nTo create C(command) tasks that are easier to read than the ones using space-delimited arguments, pass parameters using the C(args) L(task keyword,../reference_appendices/playbooks_keywords.html#task) or use C(cmd) parameter.\nEither a free form command or C(cmd) parameter is required, see the examples.\nFor Windows targets, use the M(ansible.windows.win_command) module instead.",
      "has_action": true,
      "notes": "If you want to run a command through the shell (say you are using C(<), C(>), C(|), and so on), you actually want the M(ansible.builtin.shell) module instead. Parsing shell metacharacters can lead to unexpected commands being executed if quoting is not done correctly so it is more secure to use the C(command) module when possible.\nC(creates), C(removes), and C(chdir) can be specified after the command. For instance, if you only want to run a command if a certain file does not exist, use this.\nCheck mode is supported when passing C(creates) or C(removes). If running in check mode and either of these are specified, the module will check for the existence of the file and report the correct changed status. If these are not supplied, the task will be skipped.\nThe C(executable) parameter is removed since version 2.4. If you have a need for this parameter, use the M(ansible.builtin.shell) module instead.\nFor Windows targets, use the M(ansible.windows.win_command) module instead.\nFor rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.",
      "options": {
        "argv": {
          "aliases": [],
          "description": "Passes the command as a list rather than a string.\nUse C(argv) to avoid quoting values that would otherwise be interpreted incorrectly (for example \"user name\").\nOnly the string (free form) or the list (argv) form can be provided, not both.  One or the other must be provided.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.6",
          "suboptions": {}
        },
        "chdir": {
          "aliases": [],
          "description": "Change into this directory before running the command.",
          "type": "path",
          "required": false,
          "version_added": "0.6",
          "suboptions": {}
        },
        "cmd": {
          "aliases": [],
          "description": "The command to run.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename or (since 2.0) glob pattern. If a matching file already exists, this step B(will not) be run.\nThis is checked before I(removes) is checked.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "The command module takes a free form string as a command to run.\nThere is no actual parameter named 'free form'.",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename or (since 2.0) glob pattern. If a matching file exists, this step B(will) be run.\nThis is checked after I(creates) is checked.",
          "type": "path",
          "required": false,
          "version_added": "0.8",
          "suboptions": {}
        },
        "stdin": {
          "aliases": [],
          "description": "Set the stdin of the command directly to the specified value.",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "stdin_add_newline": {
          "aliases": [],
          "description": "If set to C(yes), append a newline to stdin data.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "strip_empty_ends": {
          "aliases": [],
          "description": "Strip empty lines from the end of stdout/stderr in result.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "warn": {
          "aliases": [],
          "description": "(deprecated) Enable or disable task warnings.\nThis feature is deprecated and will be removed in 2.14.\nAs of version 2.11, this option is now disabled by default.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        }
      },
      "short_description": "Execute commands on targets",
      "version_added": "historical"
    },
    "examples": "\n- name: Return motd to registered var\n  ansible.builtin.command: cat /etc/motd\n  register: mymotd\n\n# free-form (string) arguments, all arguments on one line\n- name: Run command if /path/to/database does not exist (without 'args')\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name creates=/path/to/database\n\n# free-form (string) arguments, some arguments on separate lines with the 'args' keyword\n# 'args' is a task keyword, passed at the same level as the module\n- name: Run command if /path/to/database does not exist (with 'args' keyword)\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name\n  args:\n    creates: /path/to/database\n\n# 'cmd' is module parameter\n- name: Run command if /path/to/database does not exist (with 'cmd' parameter)\n  ansible.builtin.command:\n    cmd: /usr/bin/make_database.sh db_user db_name\n    creates: /path/to/database\n\n- name: Change the working directory to somedir/ and run the command as db_owner if /path/to/database does not exist\n  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name\n  become: yes\n  become_user: db_owner\n  args:\n    chdir: somedir/\n    creates: /path/to/database\n\n# argv (list) arguments, each argument on a separate line, 'args' keyword not necessary\n# 'argv' is a parameter, indented one level from the module\n- name: Use 'argv' to send a command as a list - leave 'command' empty\n  ansible.builtin.command:\n    argv:\n      - /usr/bin/make_database.sh\n      - Username with whitespace\n      - dbname with whitespace\n    creates: /path/to/database\n\n- name: Safely use templated variable to run command. Always use the quote filter to avoid injection issues\n  ansible.builtin.command: cat {{ myfile|quote }}\n  register: myoutput\n"
  },
  "copy": {
    "doc": {
      "description": "The C(copy) module copies a file from the local or remote machine to a location on the remote machine.\nUse the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.\nIf you need variable interpolation in copied files, use the M(ansible.builtin.template) module. Using a variable in the C(content) field will result in unpredictable output.\nFor Windows targets, use the M(ansible.windows.win_copy) module instead.",
      "has_action": true,
      "notes": "The M(ansible.builtin.copy) module recursively copy facility does not scale to lots (>hundreds) of files.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "0.7",
          "suboptions": {}
        },
        "checksum": {
          "aliases": [],
          "description": "SHA1 checksum of the file being transferred.\nUsed to validate that the copy of the file was successful.\nIf this is not provided, ansible will use the local calculated checksum of the src file.",
          "type": "str",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "When used instead of C(src), sets the contents of a file directly to the specified value.\nWorks only when C(dest) is a file. Creates the file if it does not exist.\nFor advanced formatting or if C(content) contains a variable, use the M(ansible.builtin.template) module.",
          "type": "str",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "decrypt": {
          "aliases": [],
          "description": "This option controls the autodecryption of source files using vault.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Remote absolute path where the file should be copied to.\nIf C(src) is a directory, this must be a directory too.\nIf C(dest) is a non-existent path and if either C(dest) ends with \"/\" or C(src) is a directory, C(dest) is created.\nIf I(dest) is a relative path, the starting directory is determined by the remote host.\nIf C(src) and C(dest) are files, the parent directory of C(dest) is not created and the task fails if it does not already exist.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "directory_mode": {
          "aliases": [],
          "description": "When doing a recursive copy set the mode for the directories.\nIf this is not set we will use the system defaults.\nThe mode is only set on directories which are newly created, and will not affect those that already existed.",
          "type": "raw",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "This flag indicates that filesystem links in the destination, if they exist, should be followed.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        },
        "force": {
          "aliases": [
            "thirsty"
          ],
          "description": "Influence whether the remote file must always be replaced.\nIf C(yes), the remote file will be replaced when contents are different than the source.\nIf C(no), the file will only be transferred if the destination does not exist.\nAlias C(thirsty) has been deprecated and will be removed in 2.13.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "local_follow": {
          "aliases": [],
          "description": "This flag indicates that filesystem links in the source tree, if they exist, should be followed.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions of the destination file or directory.\nFor those used to C(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number. Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nAs of Ansible 2.3, the mode may also be the special string C(preserve).\nC(preserve) means that the file will be given the same permissions as the source file.\nWhen doing a recursive copy, see also C(directory_mode).\nIf C(mode) is not specified and the destination file B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created file.\nIf C(mode) is not specified and the destination file B(does) exist, the mode of the existing file will be used.\nSpecifying C(mode) is the best way to ensure files are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "remote_src": {
          "aliases": [],
          "description": "Influence whether C(src) needs to be transferred or already is present remotely.\nIf C(no), it will search for C(src) on the controller node.\nIf C(yes) it will search for C(src) on the managed (remote) node.\nC(remote_src) supports recursive copying as of version 2.8.\nC(remote_src) only works with C(mode=preserve) as of version 2.6.\nAutodecryption of files does not work when C(remote_src=yes).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Local path to a file to copy to the remote server.\nThis can be absolute or relative.\nIf path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to the C(rsync) command line tool.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying the updated file into the final destination.\nA temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.\nAlso, the command is passed securely so shell features such as expansion and pipes will not work.\nFor an example on how to handle more complex validation than what this option provides, see L(Complex configuration validation,https://docs.ansible.com/ansible/devel/reference_appendices/faq.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Copy files to remote locations",
      "version_added": "historical"
    },
    "examples": "\n- name: Copy file with owner and permissions\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: '0644'\n\n- name: Copy file with owner and permission, using symbolic representation\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: u=rw,g=r,o=r\n\n- name: Another symbolic mode example, adding some permissions and removing others\n  ansible.builtin.copy:\n    src: /srv/myfiles/foo.conf\n    dest: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: u+rw,g-wx,o-rwx\n\n- name: Copy a new \"ntp.conf\" file into place, backing up the original if it differs from the copied version\n  ansible.builtin.copy:\n    src: /mine/ntp.conf\n    dest: /etc/ntp.conf\n    owner: root\n    group: root\n    mode: '0644'\n    backup: yes\n\n- name: Copy a new \"sudoers\" file into place, after passing validation with visudo\n  ansible.builtin.copy:\n    src: /mine/sudoers\n    dest: /etc/sudoers\n    validate: /usr/sbin/visudo -csf %s\n\n- name: Copy a \"sudoers\" file on the remote machine for editing\n  ansible.builtin.copy:\n    src: /etc/sudoers\n    dest: /etc/sudoers.edit\n    remote_src: yes\n    validate: /usr/sbin/visudo -csf %s\n\n- name: Copy using inline content\n  ansible.builtin.copy:\n    content: '# This file was moved to /etc/other.conf'\n    dest: /etc/mine.conf\n\n- name: If follow=yes, /path/to/file will be overwritten by contents of foo.conf\n  ansible.builtin.copy:\n    src: /etc/foo.conf\n    dest: /path/to/link  # link to /path/to/file\n    follow: yes\n\n- name: If follow=no, /path/to/link will become a file and be overwritten by contents of foo.conf\n  ansible.builtin.copy:\n    src: /etc/foo.conf\n    dest: /path/to/link  # link to /path/to/file\n    follow: no\n"
  },
  "cron": {
    "doc": {
      "description": "Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.\nWhen crontab jobs are managed: the module includes one line with the description of the crontab entry C(\"#Ansible: <name>\") corresponding to the \"name\" passed to the module, which is used by future ansible/module calls to find/check the state. The \"name\" parameter should be unique, and changing the \"name\" value will result in a new cron task being created (or a different one being removed).\nWhen environment variables are managed, no comment line is added, but, when the module needs to find/check the state, it uses the \"name\" parameter to find the environment variable definition line.\nWhen using symbols such as %, they must be properly escaped.",
      "has_action": false,
      "options": {
        "backup": {
          "aliases": [],
          "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup_file) variable by this module.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "cron_file": {
          "aliases": [],
          "description": "If specified, uses this file instead of an individual user's crontab. The assumption is that this file is exclusively managed by the module, do not use if the file contains multiple entries, NEVER use for /etc/crontab.\nIf this is a relative path, it is interpreted with respect to I(/etc/cron.d).\nMany linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens.\nUsing this parameter requires you to specify the I(user) as well, unless I(state) is not I(present).\nEither this parameter or I(name) is required",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "day": {
          "aliases": [
            "dom"
          ],
          "description": "Day of the month the job should run (C(1-31), C(*), C(*/2), and so on).",
          "default": "*",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "disabled": {
          "aliases": [],
          "description": "If the job should be disabled (commented out) in the crontab.\nOnly has effect if I(state=present).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "env": {
          "aliases": [],
          "description": "If set, manages a crontab's environment variable.\nNew variables are added on top of crontab.\nI(name) and I(value) parameters are the name and the value of environment variable.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "hour": {
          "aliases": [],
          "description": "Hour when the job should run (C(0-23), C(*), C(*/2), and so on).",
          "default": "*",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "insertafter": {
          "aliases": [],
          "description": "Used with I(state=present) and I(env).\nIf specified, the environment variable will be inserted after the declaration of specified environment variable.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "insertbefore": {
          "aliases": [],
          "description": "Used with I(state=present) and I(env).\nIf specified, the environment variable will be inserted before the declaration of specified environment variable.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "job": {
          "aliases": [
            "value"
          ],
          "description": "The command to execute or, if env is set, the value of environment variable.\nThe command should not contain line breaks.\nRequired if I(state=present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "minute": {
          "aliases": [],
          "description": "Minute when the job should run (C(0-59), C(*), C(*/2), and so on).",
          "default": "*",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "month": {
          "aliases": [],
          "description": "Month of the year the job should run (C(1-12), C(*), C(*/2), and so on).",
          "default": "*",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Description of a crontab entry or, if env is set, the name of environment variable.\nThis parameter is always required as of ansible-core 2.12.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "special_time": {
          "aliases": [],
          "description": "Special time specification nickname.",
          "type": "str",
          "required": false,
          "choices": [
            "annually",
            "daily",
            "hourly",
            "monthly",
            "reboot",
            "weekly",
            "yearly"
          ],
          "version_added": "1.3",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to ensure the job or environment variable is present or absent.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "user": {
          "aliases": [],
          "description": "The specific user whose crontab should be modified.\nWhen unset, this parameter defaults to the current user.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "weekday": {
          "aliases": [
            "dow"
          ],
          "description": "Day of the week that the job should run (C(0-6) for Sunday-Saturday, C(*), and so on).",
          "default": "*",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "cron (any 'vixie cron' conformant variant, like cronie)"
      ],
      "short_description": "Manage cron.d and crontab entries",
      "version_added": "0.9"
    },
    "examples": "\n- name: Ensure a job that runs at 2 and 5 exists. Creates an entry like \"0 5,2 * * ls -alh > /dev/null\"\n  ansible.builtin.cron:\n    name: \"check dirs\"\n    minute: \"0\"\n    hour: \"5,2\"\n    job: \"ls -alh > /dev/null\"\n\n- name: 'Ensure an old job is no longer present. Removes any job that is prefixed by \"#Ansible: an old job\" from the crontab'\n  ansible.builtin.cron:\n    name: \"an old job\"\n    state: absent\n\n- name: Creates an entry like \"@reboot /some/job.sh\"\n  ansible.builtin.cron:\n    name: \"a job for reboot\"\n    special_time: reboot\n    job: \"/some/job.sh\"\n\n- name: Creates an entry like \"PATH=/opt/bin\" on top of crontab\n  ansible.builtin.cron:\n    name: PATH\n    env: yes\n    job: /opt/bin\n\n- name: Creates an entry like \"APP_HOME=/srv/app\" and insert it after PATH declaration\n  ansible.builtin.cron:\n    name: APP_HOME\n    env: yes\n    job: /srv/app\n    insertafter: PATH\n\n- name: Creates a cron file under /etc/cron.d\n  ansible.builtin.cron:\n    name: yum autoupdate\n    weekday: \"2\"\n    minute: \"0\"\n    hour: \"12\"\n    user: root\n    job: \"YUMINTERACTIVE=0 /usr/sbin/yum-autoupdate\"\n    cron_file: ansible_yum-autoupdate\n\n- name: Removes a cron file from under /etc/cron.d\n  ansible.builtin.cron:\n    name: \"yum autoupdate\"\n    cron_file: ansible_yum-autoupdate\n    state: absent\n\n- name: Removes \"APP_HOME\" environment variable from crontab\n  ansible.builtin.cron:\n    name: APP_HOME\n    env: yes\n    state: absent\n"
  },
  "debconf": {
    "doc": {
      "description": "Configure a .deb package using debconf-set-selections.\nOr just query existing selections.",
      "has_action": false,
      "notes": "This module requires the command line debconf tools.\nA number of questions have to be answered (depending on the package). Use 'debconf-show <package>' on any Debian or derivative with the package installed to see questions/settings available.\nSome distros will always record tasks involving the setting of passwords as changed. This is due to debconf-get-selections masking passwords.\nIt is highly recommended to add I(no_log=True) to task while handling sensitive information using this module.",
      "options": {
        "name": {
          "aliases": [
            "pkg"
          ],
          "description": "Name of package to configure.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "question": {
          "aliases": [
            "selection",
            "setting"
          ],
          "description": "A debconf configuration setting.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "unseen": {
          "aliases": [],
          "description": "Do not set 'seen' flag when pre-seeding.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "value": {
          "aliases": [
            "answer"
          ],
          "description": "Value to set the configuration to.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "vtype": {
          "aliases": [],
          "description": "The type of the value supplied.\nIt is highly recommended to add I(no_log=True) to task while specifying I(vtype=password).\nC(seen) was added in Ansible 2.2.",
          "type": "str",
          "required": false,
          "choices": [
            "boolean",
            "error",
            "multiselect",
            "note",
            "password",
            "seen",
            "select",
            "string",
            "text",
            "title"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "debconf",
        "debconf-utils"
      ],
      "short_description": "Configure a .deb package",
      "version_added": "1.6"
    },
    "examples": "\n- name: Set default locale to fr_FR.UTF-8\n  ansible.builtin.debconf:\n    name: locales\n    question: locales/default_environment_locale\n    value: fr_FR.UTF-8\n    vtype: select\n\n- name: Set to generate locales\n  ansible.builtin.debconf:\n    name: locales\n    question: locales/locales_to_be_generated\n    value: en_US.UTF-8 UTF-8, fr_FR.UTF-8 UTF-8\n    vtype: multiselect\n\n- name: Accept oracle license\n  ansible.builtin.debconf:\n    name: oracle-java7-installer\n    question: shared/accepted-oracle-license-v1-1\n    value: 'true'\n    vtype: select\n\n- name: Specifying package you can register/return the list of questions and current values\n  ansible.builtin.debconf:\n    name: tzdata\n\n- name: Pre-configure tripwire site passphrase\n  ansible.builtin.debconf:\n    name: tripwire\n    question: tripwire/site-passphrase\n    value: \"{{ site_passphrase }}\"\n    vtype: password\n  no_log: True\n"
  },
  "debug": {
    "doc": {
      "description": "This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook.\nUseful for debugging together with the 'when:' directive.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "options": {
        "msg": {
          "aliases": [],
          "description": "The customized message that is printed. If omitted, prints a generic message.",
          "default": "Hello world!",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "var": {
          "aliases": [],
          "description": "A variable name to debug.\nMutually exclusive with the C(msg) option.\nBe aware that this option already runs in Jinja2 context and has an implicit C({{ }}) wrapping, so you should not be using Jinja2 delimiters unless you are looking for double interpolation.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "verbosity": {
          "aliases": [],
          "description": "A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above.",
          "default": "0",
          "type": "int",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        }
      },
      "short_description": "Print statements during execution",
      "version_added": "0.8"
    },
    "examples": "\n- name: Print the gateway for each host when defined\n  ansible.builtin.debug:\n    msg: System {{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}\n  when: ansible_default_ipv4.gateway is defined\n\n- name: Get uptime information\n  ansible.builtin.shell: /usr/bin/uptime\n  register: result\n\n- name: Print return information from the previous task\n  ansible.builtin.debug:\n    var: result\n    verbosity: 2\n\n- name: Display all variables/facts known for a host\n  ansible.builtin.debug:\n    var: hostvars[inventory_hostname]\n    verbosity: 4\n\n- name: Prints two lines of messages, but only if there is an environment value set\n  ansible.builtin.debug:\n    msg:\n    - \"Provisioning based on YOUR_KEY which is: {{ lookup('env', 'YOUR_KEY') }}\"\n    - \"These servers were built using the password of '{{ password_used }}'. Please retain this for later use.\"\n"
  },
  "dnf": {
    "doc": {
      "description": "Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.",
      "has_action": false,
      "notes": "When used with a C(loop:) each package will be processed individually, it is much more efficient to pass the list directly to the I(name) option.\nGroup removal doesn't work if the group was installed with Ansible because upstream dnf's API doesn't properly mark groups as installed, therefore upon removal the module is unable to detect that the group is installed (https://bugzilla.redhat.com/show_bug.cgi?id=1620324)",
      "options": {
        "allow_downgrade": {
          "aliases": [],
          "description": "Specify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "allowerasing": {
          "aliases": [],
          "description": "If C(yes) it allows  erasing  of  installed  packages to resolve dependencies.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "autoremove": {
          "aliases": [],
          "description": "If C(yes), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when state is I(absent)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "bugfix": {
          "aliases": [],
          "description": "If set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related.\nNote that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "cacheonly": {
          "aliases": [],
          "description": "Tells dnf to run entirely from system cache; does not download or update metadata.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "conf_file": {
          "aliases": [],
          "description": "The remote dnf configuration file to use for the transaction.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "disable_excludes": {
          "aliases": [],
          "description": "Disable the excludes defined in DNF config files.\nIf set to C(all), disables all excludes.\nIf set to C(main), disable excludes defined in [main] in dnf.conf.\nIf set to C(repoid), disable excludes defined for given repo id.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "disable_gpg_check": {
          "aliases": [],
          "description": "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest).\nThis setting affects packages installed from a repository as well as \"local\" packages installed from the filesystem or a URL.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "disable_plugin": {
          "aliases": [],
          "description": "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.7",
          "suboptions": {}
        },
        "disablerepo": {
          "aliases": [],
          "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "download_dir": {
          "aliases": [],
          "description": "Specifies an alternate directory to store packages.\nHas an effect only if I(download_only) is specified.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "download_only": {
          "aliases": [],
          "description": "Only download the packages, do not install them.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "enable_plugin": {
          "aliases": [],
          "description": "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.7",
          "suboptions": {}
        },
        "enablerepo": {
          "aliases": [],
          "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "exclude": {
          "aliases": [],
          "description": "Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.7",
          "suboptions": {}
        },
        "install_repoquery": {
          "aliases": [],
          "description": "This is effectively a no-op in DNF as it is not needed with DNF, but is an accepted parameter for feature parity/compatibility with the I(yum) module.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "install_weak_deps": {
          "aliases": [],
          "description": "Will also install all packages linked by a weak dependency relation.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "installroot": {
          "aliases": [],
          "description": "Specifies an alternative installroot, relative to which all packages will be installed.",
          "default": "/",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "list": {
          "aliases": [],
          "description": "Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "lock_timeout": {
          "aliases": [],
          "description": "Amount of time to wait for the dnf lockfile to be freed.",
          "default": "30",
          "type": "int",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "pkg"
          ],
          "description": "A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.\nComparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name>=1.0)\nYou can also pass an absolute path for a binary which is provided by the package to install. See examples for more information.",
          "type": "list",
          "required": true,
          "elements": "str",
          "suboptions": {}
        },
        "nobest": {
          "aliases": [],
          "description": "Set best option to False, so that transactions are not limited to best candidates only.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "releasever": {
          "aliases": [],
          "description": "Specifies an alternative release from which all packages will be installed.",
          "type": "str",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "security": {
          "aliases": [],
          "description": "If set to C(yes), and C(state=latest) then only installs updates that have been marked security related.\nNote that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "skip_broken": {
          "aliases": [],
          "description": "Skip all unavailable packages or packages with broken dependencies without raising an error. Equivalent to passing the --skip-broken option.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to install (C(present), C(latest)), or remove (C(absent)) a package.\nDefault is C(None), however in effect the default action is C(present) unless the C(autoremove) option is enabled for this module, then C(absent) is inferred.",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present",
            "installed",
            "removed",
            "latest"
          ],
          "suboptions": {}
        },
        "update_cache": {
          "aliases": [
            "expire-cache"
          ],
          "description": "Force dnf to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "update_only": {
          "aliases": [],
          "description": "When using latest, only update installed packages. Do not install packages.\nHas an effect only if state is I(latest)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        }
      },
      "requirements": [
        "python >= 2.6",
        "python-dnf",
        "for the autoremove option you need dnf >= 2.0.1\""
      ],
      "short_description": "Manages packages with the I(dnf) package manager",
      "version_added": "1.9"
    },
    "examples": "\n- name: Install the latest version of Apache\n  dnf:\n    name: httpd\n    state: latest\n\n- name: Install Apache >= 2.4\n  dnf:\n    name: httpd>=2.4\n    state: present\n\n- name: Install the latest version of Apache and MariaDB\n  dnf:\n    name:\n      - httpd\n      - mariadb-server\n    state: latest\n\n- name: Remove the Apache package\n  dnf:\n    name: httpd\n    state: absent\n\n- name: Install the latest version of Apache from the testing repo\n  dnf:\n    name: httpd\n    enablerepo: testing\n    state: present\n\n- name: Upgrade all packages\n  dnf:\n    name: \"*\"\n    state: latest\n\n- name: Install the nginx rpm from a remote repo\n  dnf:\n    name: 'http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm'\n    state: present\n\n- name: Install nginx rpm from a local file\n  dnf:\n    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm\n    state: present\n\n- name: Install Package based upon the file it provides\n  dnf:\n    name: /usr/bin/cowsay\n    state: present\n\n- name: Install the 'Development tools' package group\n  dnf:\n    name: '@Development tools'\n    state: present\n\n- name: Autoremove unneeded packages installed as dependencies\n  dnf:\n    autoremove: yes\n\n- name: Uninstall httpd but keep its dependencies\n  dnf:\n    name: httpd\n    state: absent\n    autoremove: no\n\n- name: Install a modularity appstream with defined stream and profile\n  dnf:\n    name: '@postgresql:9.6/client'\n    state: present\n\n- name: Install a modularity appstream with defined stream\n  dnf:\n    name: '@postgresql:9.6'\n    state: present\n\n- name: Install a modularity appstream with defined profile\n  dnf:\n    name: '@postgresql/client'\n    state: present\n"
  },
  "dpkg_selections": {
    "doc": {
      "description": "Change dpkg package selection state via --get-selections and --set-selections.",
      "has_action": false,
      "notes": "This module won't cause any packages to be installed/removed/purged, use the C(apt) module for that.",
      "options": {
        "name": {
          "aliases": [],
          "description": "Name of the package.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "selection": {
          "aliases": [],
          "description": "The selection state to set the package to.",
          "type": "str",
          "required": true,
          "choices": [
            "install",
            "hold",
            "deinstall",
            "purge"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Dpkg package selection selections",
      "version_added": "2.0"
    },
    "examples": "\n- name: Prevent python from being upgraded\n  dpkg_selections:\n    name: python\n    selection: hold\n"
  },
  "expect": {
    "doc": {
      "description": "The C(expect) module executes a command and responds to prompts.\nThe given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($HOME) and operations like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work.",
      "has_action": false,
      "notes": "If you want to run a command through the shell (say you are using C(<), C(>), C(|), and so on), you must specify a shell in the command such as C(/bin/bash -c \"/path/to/something | grep else\").\nThe question, or key, under I(responses) is a python regex match. Case insensitive searches are indicated with a prefix of C(?i).\nThe C(pexpect) library used by this module operates with a search window of 2000 bytes, and does not use a multiline regex match. To perform a start of line bound match, use a pattern like ``(?m)^pattern``\nBy default, if a question is encountered multiple times, its string response will be repeated. If you need different responses for successive question matches, instead of a string response, use a list of strings as the response. The list functionality is new in 2.1.\nThe M(ansible.builtin.expect) module is designed for simple scenarios. For more complex needs, consider the use of expect code with the M(ansible.builtin.shell) or M(ansible.builtin.script) modules. (An example is part of the M(ansible.builtin.shell) module documentation).",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "Change into this directory before running the command.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "command": {
          "aliases": [],
          "description": "The command module takes command to run.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename, when it already exists, this step will B(not) be run.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "echo": {
          "aliases": [],
          "description": "Whether or not to echo out your response strings.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename, when it does not exist, this step will B(not) be run.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "responses": {
          "aliases": [],
          "description": "Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.",
          "type": "dict",
          "required": true,
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "Amount of time in seconds to wait for the expected strings. Use C(null) to disable timeout.",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "python >= 2.6",
        "pexpect >= 3.3"
      ],
      "short_description": "Executes a command and responds to prompts",
      "version_added": "2.0"
    },
    "examples": "\n- name: Case insensitive password string match\n  ansible.builtin.expect:\n    command: passwd username\n    responses:\n      (?i)password: \"MySekretPa$$word\"\n  # you don't want to show passwords in your logs\n  no_log: true\n\n- name: Generic question with multiple different responses\n  ansible.builtin.expect:\n    command: /path/to/custom/command\n    responses:\n      Question:\n        - response1\n        - response2\n        - response3\n"
  },
  "fail": {
    "doc": {
      "description": "This module fails the progress with a custom message.\nIt can be useful for bailing out when a certain condition is met using C(when).\nThis module is also supported for Windows targets.",
      "has_action": true,
      "options": {
        "msg": {
          "aliases": [],
          "description": "The customized message used for failing execution.\nIf omitted, fail will simply bail out with a generic message.",
          "default": "Failed as requested from task",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Fail with custom message",
      "version_added": "0.8"
    },
    "examples": "\n- name: Example using fail and when together\n  fail:\n    msg: The system may not be provisioned according to the CMDB status.\n  when: cmdb_status != \"to-be-staged\"\n"
  },
  "fetch": {
    "doc": {
      "description": "This module works like M(ansible.builtin.copy), but in reverse.\nIt is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname.\nFiles that already exist at I(dest) will be overwritten if they are different than the I(src).\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "When running fetch with C(become), the M(ansible.builtin.slurp) module will also be used to fetch the contents of the file for determining the remote checksum. This effectively doubles the transfer size, and depending on the file size can consume all available memory on the remote or local hosts causing a C(MemoryError). Due to this it is advisable to run this module without C(become) whenever possible.\nPrior to Ansible 2.5 this module would not fail if reading the remote file was impossible unless C(fail_on_missing) was set.\nIn Ansible 2.5 or later, playbook authors are encouraged to use C(fail_when) or C(ignore_errors) to get this ability. They may also explicitly set C(fail_on_missing) to C(no) to get the non-failing behaviour.",
      "options": {
        "dest": {
          "aliases": [],
          "description": "A directory to save the file into.\nFor example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile). The host name is based on the inventory name.",
          "required": true,
          "suboptions": {}
        },
        "fail_on_missing": {
          "aliases": [],
          "description": "When set to C(yes), the task will fail if the remote file cannot be read for any reason.\nPrior to Ansible 2.5, setting this would only fail if the source file was missing.\nThe default was changed to C(yes) in Ansible 2.5.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "flat": {
          "aliases": [],
          "description": "Allows you to override the default behavior of appending hostname/path/to/file to the destination.\nIf C(dest) ends with '/', it will use the basename of the source file, similar to the copy module.\nThis can be useful if working with a single host, or if retrieving files that are uniquely named per host.\nIf using multiple hosts with the same filename, the file will be overwritten for each host.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.2",
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "The file on the remote system to fetch.\nThis I(must) be a file, not a directory.\nRecursive fetching may be supported in a later release.",
          "required": true,
          "suboptions": {}
        },
        "validate_checksum": {
          "aliases": [],
          "description": "Verify that the source and destination checksums match after the files are fetched.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        }
      },
      "short_description": "Fetch files from remote nodes",
      "version_added": "0.2"
    },
    "examples": "\n- name: Store file into /tmp/fetched/host.example.com/tmp/somefile\n  ansible.builtin.fetch:\n    src: /tmp/somefile\n    dest: /tmp/fetched\n\n- name: Specifying a path directly\n  ansible.builtin.fetch:\n    src: /tmp/somefile\n    dest: /tmp/prefix-{{ inventory_hostname }}\n    flat: yes\n\n- name: Specifying a destination path\n  ansible.builtin.fetch:\n    src: /tmp/uniquefile\n    dest: /tmp/special/\n    flat: yes\n\n- name: Storing in a path relative to the playbook\n  ansible.builtin.fetch:\n    src: /tmp/uniquefile\n    dest: special/prefix-{{ inventory_hostname }}\n    flat: yes\n"
  },
  "file": {
    "doc": {
      "description": "Set attributes of files, symlinks or directories.\nAlternatively, remove files, symlinks or directories.\nMany other modules support the same options as the C(file) module - including M(ansible.builtin.copy), M(ansible.builtin.template), and M(ansible.builtin.assemble).\nFor Windows targets, use the M(ansible.windows.win_file) module instead.",
      "has_action": false,
      "options": {
        "access_time": {
          "aliases": [],
          "description": "This parameter indicates the time the file's access time should be set to.\nShould be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).\nDefault is C(None) meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "access_time_format": {
          "aliases": [],
          "description": "When used with C(access_time), indicates the time format that must be used.\nBased on default Python format (see time.strftime doc).",
          "default": "%Y%m%d%H%M.%S",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "This flag indicates that filesystem links, if they exist, should be followed.\nPrevious to Ansible 2.5, this was C(no) by default.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Force the creation of the symlinks in two cases: the source file does not exist (but will appear later); the destination exists and is a file (so, we need to unlink the C(path) file and create symlink to the C(src) file in place of it).\n",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "modification_time": {
          "aliases": [],
          "description": "This parameter indicates the time the file's modification time should be set to.\nShould be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).\nDefault is None meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "modification_time_format": {
          "aliases": [],
          "description": "When used with C(modification_time), indicates the time format that must be used.\nBased on default Python format (see time.strftime doc).",
          "default": "%Y%m%d%H%M.%S",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "name"
          ],
          "description": "Path to the file being managed.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "recurse": {
          "aliases": [],
          "description": "Recursively set the specified file attributes on directory contents.\nThis applies only when C(state) is set to C(directory).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Path of the file to link to.\nThis applies only to C(state=link) and C(state=hard).\nFor C(state=link), this will also accept a non-existing path.\nRelative paths are relative to the file being created (C(path)) which is how the Unix command C(ln -s SRC DEST) treats relative paths.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "If C(absent), directories will be recursively deleted, and files or symlinks will be unlinked. In the case of a directory, if C(diff) is declared, you will see the files and folders deleted listed under C(path_contents). Note that C(absent) will not cause C(file) to fail if the C(path) does not exist as the state did not change.\nIf C(directory), all intermediate subdirectories will be created if they do not exist. Since Ansible 1.7 they will be created with the supplied permissions.\nIf C(file), with no other options, returns the current state of C(path).\nIf C(file), even with other options (such as C(mode)), the file will be modified if it exists but will NOT be created if it does not exist. Set to C(touch) or use the M(ansible.builtin.copy) or M(ansible.builtin.template) module if you want to create the file if it does not exist.\nIf C(hard), the hard link will be created or changed.\nIf C(link), the symbolic link will be created or changed.\nIf C(touch) (new in 1.4), an empty file will be created if the file does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way C(touch) works from the command line).",
          "default": "file",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "directory",
            "file",
            "hard",
            "link",
            "touch"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "short_description": "Manage files and file properties",
      "version_added": "historical"
    },
    "examples": "\n- name: Change file ownership, group and permissions\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    owner: foo\n    group: foo\n    mode: '0644'\n\n- name: Give insecure permissions to an existing file\n  ansible.builtin.file:\n    path: /work\n    owner: root\n    group: root\n    mode: '1777'\n\n- name: Create a symbolic link\n  ansible.builtin.file:\n    src: /file/to/link/to\n    dest: /path/to/symlink\n    owner: foo\n    group: foo\n    state: link\n\n- name: Create two hard links\n  ansible.builtin.file:\n    src: '/tmp/{{ item.src }}'\n    dest: '{{ item.dest }}'\n    state: hard\n  loop:\n    - { src: x, dest: y }\n    - { src: z, dest: k }\n\n- name: Touch a file, using symbolic modes to set the permissions (equivalent to 0644)\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u=rw,g=r,o=r\n\n- name: Touch the same file, but add/remove some permissions\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u+rw,g-wx,o-rwx\n\n- name: Touch again the same file, but do not change times this makes the task idempotent\n  ansible.builtin.file:\n    path: /etc/foo.conf\n    state: touch\n    mode: u+rw,g-wx,o-rwx\n    modification_time: preserve\n    access_time: preserve\n\n- name: Create a directory if it does not exist\n  ansible.builtin.file:\n    path: /etc/some_directory\n    state: directory\n    mode: '0755'\n\n- name: Update modification and access time of given file\n  ansible.builtin.file:\n    path: /etc/some_file\n    state: file\n    modification_time: now\n    access_time: now\n\n- name: Set access time based on seconds from epoch value\n  ansible.builtin.file:\n    path: /etc/another_file\n    state: file\n    access_time: '{{ \"%Y%m%d%H%M.%S\" | strftime(stat_var.stat.atime) }}'\n\n- name: Recursively change ownership of a directory\n  ansible.builtin.file:\n    path: /etc/foo\n    state: directory\n    recurse: yes\n    owner: foo\n    group: foo\n\n- name: Remove file (delete file)\n  ansible.builtin.file:\n    path: /etc/foo.txt\n    state: absent\n\n- name: Recursively remove directory\n  ansible.builtin.file:\n    path: /etc/foo\n    state: absent\n\n"
  },
  "find": {
    "doc": {
      "description": "Return a list of files based on specific criteria. Multiple criteria are AND'd together.\nFor Windows targets, use the M(ansible.windows.win_find) module instead.",
      "has_action": false,
      "options": {
        "age": {
          "aliases": [],
          "description": "Select files whose age is equal to or greater than the specified time.\nUse a negative age to find files equal to or less than the specified time.\nYou can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., \"1w\").",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "age_stamp": {
          "aliases": [],
          "description": "Choose the file property against which we compare age.",
          "default": "mtime",
          "type": "str",
          "required": false,
          "choices": [
            "atime",
            "ctime",
            "mtime"
          ],
          "suboptions": {}
        },
        "contains": {
          "aliases": [],
          "description": "A regular expression or pattern which should be matched against the file content.\nWorks only when I(file_type) is C(file).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "depth": {
          "aliases": [],
          "description": "Set the maximum number of levels to descend into.\nSetting recurse to C(no) will override this value, which is effectively depth 1.\nDefault is unlimited depth.",
          "type": "int",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "excludes": {
          "aliases": [
            "exclude"
          ],
          "description": "One or more (shell or regex) patterns, which type is controlled by C(use_regex) option.\nItems whose basenames match an C(excludes) pattern are culled from C(patterns) matches. Multiple patterns can be specified using a list.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.5",
          "suboptions": {}
        },
        "file_type": {
          "aliases": [],
          "description": "Type of file to select.\nThe 'link' and 'any' choices were added in Ansible 2.3.",
          "default": "file",
          "type": "str",
          "required": false,
          "choices": [
            "any",
            "directory",
            "file",
            "link"
          ],
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "Set this to C(yes) to follow symlinks in path for systems with python 2.6+.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "get_checksum": {
          "aliases": [],
          "description": "Set this to C(yes) to retrieve a file's SHA1 checksum.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "hidden": {
          "aliases": [],
          "description": "Set this to C(yes) to include hidden files, otherwise they will be ignored.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "paths": {
          "aliases": [
            "name",
            "path"
          ],
          "description": "List of paths of directories to search. All paths must be fully qualified.",
          "type": "list",
          "required": true,
          "elements": "str",
          "suboptions": {}
        },
        "patterns": {
          "aliases": [
            "pattern"
          ],
          "description": "One or more (shell or regex) patterns, which type is controlled by C(use_regex) option.\nThe patterns restrict the list of files to be returned to those whose basenames match at least one of the patterns specified. Multiple patterns can be specified using a list.\nThe pattern is matched against the file base name, excluding the directory.\nWhen using regexen, the pattern MUST match the ENTIRE file name, not just parts of it. So if you are looking to match all files ending in .default, you'd need to use '.*\\.default' as a regexp and not just '\\.default'.\nThis parameter expects a list, which can be either comma separated or YAML. If any of the patterns contain a comma, make sure to put them in a list to avoid splitting the patterns in undesirable ways.\nDefaults to '*' when C(use_regex=False), or '.*' when C(use_regex=True).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "read_whole_file": {
          "aliases": [],
          "description": "When doing a C(contains) search, determines whether the whole file should be read into memory or if the regex should be applied to the file line-by-line.\nSetting this to C(true) can have performance and memory implications for large files.\nThis uses C(re.search()) instead of C(re.match()).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "recurse": {
          "aliases": [],
          "description": "If target is a directory, recursively descend into the directory looking for files.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Select files whose size is equal to or greater than the specified size.\nUse a negative size to find files equal to or less than the specified size.\nUnqualified values are in bytes but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively.\nSize is not evaluated for directories.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_regex": {
          "aliases": [],
          "description": "If C(no), the patterns are file globs (shell).\nIf C(yes), they are python regexes.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Return a list of files based on specific criteria",
      "version_added": "2.0"
    },
    "examples": "\n- name: Recursively find /tmp files older than 2 days\n  find:\n    paths: /tmp\n    age: 2d\n    recurse: yes\n\n- name: Recursively find /tmp files older than 4 weeks and equal or greater than 1 megabyte\n  find:\n    paths: /tmp\n    age: 4w\n    size: 1m\n    recurse: yes\n\n- name: Recursively find /var/tmp files with last access time greater than 3600 seconds\n  find:\n    paths: /var/tmp\n    age: 3600\n    age_stamp: atime\n    recurse: yes\n\n- name: Find /var/log files equal or greater than 10 megabytes ending with .old or .log.gz\n  find:\n    paths: /var/log\n    patterns: '*.old,*.log.gz'\n    size: 10m\n\n# Note that YAML double quotes require escaping backslashes but yaml single quotes do not.\n- name: Find /var/log files equal or greater than 10 megabytes ending with .old or .log.gz via regex\n  find:\n    paths: /var/log\n    patterns: \"^.*?\\\\.(?:old|log\\\\.gz)$\"\n    size: 10m\n    use_regex: yes\n\n- name: Find /var/log all directories, exclude nginx and mysql\n  find:\n    paths: /var/log\n    recurse: no\n    file_type: directory\n    excludes: 'nginx,mysql'\n\n# When using patterns that contain a comma, make sure they are formatted as lists to avoid splitting the pattern\n- name: Use a single pattern that contains a comma formatted as a list\n  find:\n    paths: /var/log\n    file_type: file\n    use_regex: yes\n    patterns: ['^_[0-9]{2,4}_.*.log$']\n\n- name: Use multiple patterns that contain a comma formatted as a YAML list\n  find:\n    paths: /var/log\n    file_type: file\n    use_regex: yes\n    patterns:\n      - '^_[0-9]{2,4}_.*.log$'\n      - '^[a-z]{1,5}_.*log$'\n\n"
  },
  "gather_facts": {
    "doc": {
      "description": "This module takes care of executing the R(configured facts modules,FACTS_MODULES), the default is to use the M(ansible.builtin.setup) module.\nThis module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks.\nIt can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host.\nAnsible provides many I(facts) about the system, automatically.",
      "has_action": true,
      "notes": "This is mostly a wrapper around other fact gathering modules.\nOptions passed into this action must be supported by all the underlying fact modules configured.\nFacts returned by each module will be merged, conflicts will favor 'last merged'. Order is not guaranteed, when doing parallel gathering on multiple modules.",
      "options": {
        "parallel": {
          "aliases": [],
          "description": "A toggle that controls if the fact modules are executed in parallel or serially and in order. This can guarantee the merge order of module facts at the expense of performance.\nBy default it will be true if more than one fact module is used.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Gathers facts about remote hosts",
      "version_added": "2.8"
    },
    "examples": "\n# Display facts from all hosts and store them indexed by hostname at /tmp/facts.\n# ansible all -m gather_facts --tree /tmp/facts\n"
  },
  "get_url": {
    "doc": {
      "description": "Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.\nBy default, if an environment variable C(<protocol>_proxy) is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see R(setting the environment,playbooks_environment)), or by using the use_proxy option.\nHTTP redirects can redirect from HTTP to HTTPS so you should be sure that your proxy environment for both protocols is correct.\nFrom Ansible 2.4 when run with C(--check), it will do a HEAD request to validate the URL but will not download the entire file or verify it against hashes.\nFor Windows targets, use the M(ansible.windows.win_get_url) module instead.",
      "has_action": false,
      "notes": "For Windows targets, use the M(ansible.windows.win_get_url) module instead.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "checksum": {
          "aliases": [],
          "description": "If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorithm>:<checksum|url>, e.g. checksum=\"sha256:D98291AC[...]B6DC7B97\", checksum=\"sha256:http://example.com/path/sha256sum.txt\"\nIf you worry about portability, only the sha1 algorithm is available on all platforms and python versions.\nThe third party hashlib library can be installed for access to additional algorithms.\nAdditionally, if a checksum is passed to this parameter, and the file exist under the C(dest) location, the I(destination_checksum) would be calculated, and if checksum equals I(destination_checksum), the file download would be skipped (unless C(force) is true). If the checksum does not equal I(destination_checksum), the destination file is deleted.",
          "default": "",
          "type": "str",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [],
          "description": "PEM formatted certificate chain file to be used for SSL client authentication.\nThis file can also include the key as well, and if the key is included, C(client_key) is not required.",
          "type": "path",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "client_key": {
          "aliases": [],
          "description": "PEM formatted file that contains your private key to be used for SSL client authentication.\nIf C(client_cert) contains both the certificate and key, this option is not required.",
          "type": "path",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Absolute path of where to download the file to.\nIf C(dest) is a directory, either the server provided filename or, if none provided, the base name of the URL on the remote server will be used. If a directory, C(force) has no effect.\nIf C(dest) is a directory, the file will always be downloaded (regardless of the C(force) option), but replaced only if the contents changed..",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "force": {
          "aliases": [
            "thirsty"
          ],
          "description": "If C(yes) and C(dest) is not a directory, will download the file every time and replace the file if the contents change. If C(no), the file will only be downloaded if the destination does not exist. Generally should be C(yes) only for small local files.\nPrior to 0.6, this module behaved as if C(yes) was the default.\nAlias C(thirsty) has been deprecated and will be removed in 2.13.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "0.7",
          "suboptions": {}
        },
        "force_basic_auth": {
          "aliases": [],
          "description": "Force the sending of the Basic authentication header upon initial request.\nhttplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "Add custom HTTP headers to a request in hash/dict format.\nThe hash/dict format was added in Ansible 2.6.\nPrevious versions used a C(\"key:value,key:value\") string format.\nThe C(\"key:value,key:value\") string format is deprecated and has been removed in version 2.10.",
          "type": "dict",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "http_agent": {
          "aliases": [],
          "description": "Header to identify as, generally appears in web server logs.",
          "default": "ansible-httpget",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sha256sum": {
          "aliases": [],
          "description": "If a SHA-256 checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. This option is deprecated and will be removed in version 2.14. Use option C(checksum) instead.",
          "default": "",
          "type": "str",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "Timeout in seconds for URL request.",
          "default": "10",
          "type": "int",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        },
        "tmp_dest": {
          "aliases": [],
          "description": "Absolute path of where temporary file is downloaded to.\nWhen run on Ansible 2.5 or greater, path defaults to ansible's remote_tmp setting\nWhen run on Ansible prior to 2.5, it defaults to C(TMPDIR), C(TEMP) or C(TMP) env variables or a platform specific value.\nU(https://docs.python.org/3/library/tempfile.html#tempfile.tempdir)",
          "type": "path",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "unredirected_headers": {
          "aliases": [],
          "description": "A list of header names that will not be sent on subsequent redirected requests. This list is case insensitive. By default all headers will be redirected. In some cases it may be beneficial to list headers such as C(Authorization) here to avoid potential credential exposure.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.12",
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "url_password": {
          "aliases": [
            "password"
          ],
          "description": "The password for use in HTTP basic authentication.\nIf the C(url_username) parameter is not specified, the C(url_password) parameter will not be used.\nSince version 2.8 you can also use the 'password' alias for this option.",
          "type": "str",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "url_username": {
          "aliases": [
            "username"
          ],
          "description": "The username for use in HTTP basic authentication.\nThis parameter can be used without C(url_password) for sites that allow empty passwords.\nSince version 2.8 you can also use the C(username) alias for this option.",
          "type": "str",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "use_gssapi": {
          "aliases": [],
          "description": "Use GSSAPI to perform the authentication, typically this is for Kerberos or Kerberos through Negotiate authentication.\nRequires the Python library L(gssapi,https://github.com/pythongssapi/python-gssapi) to be installed.\nCredentials for GSSAPI can be specified with I(url_username)/I(url_password) or with the GSSAPI env var C(KRB5CCNAME) that specified a custom Kerberos credential cache.\nNTLM authentication is C(not) supported even if the GSSAPI mech for NTLM has been installed.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "use_proxy": {
          "aliases": [],
          "description": "if C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Downloads files from HTTP, HTTPS, or FTP to node",
      "version_added": "0.6"
    },
    "examples": "\n- name: Download foo.conf\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    mode: '0440'\n\n- name: Download file and force basic auth\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    force_basic_auth: yes\n\n- name: Download file with custom HTTP headers\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    headers:\n      key1: one\n      key2: two\n\n- name: Download file with check (sha256)\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: sha256:b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\n\n- name: Download file with check (md5)\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: md5:66dffb5228a211e61d6d7ef4a86f5758\n\n- name: Download file with checksum url (sha256)\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    checksum: sha256:http://example.com/path/sha256sum.txt\n\n- name: Download file from a file path\n  get_url:\n    url: file:///tmp/afile.txt\n    dest: /tmp/afilecopy.txt\n\n- name: < Fetch file that requires authentication.\n        username/password only available since 2.8, in older versions you need to use url_username/url_password\n  get_url:\n    url: http://example.com/path/file.conf\n    dest: /etc/foo.conf\n    username: bar\n    password: '{{ mysecret }}'\n"
  },
  "getent": {
    "doc": {
      "description": "Runs getent against one of it's various databases and returns information into the host's facts, in a getent_<database> prefixed variable.",
      "has_action": false,
      "notes": "Not all databases support enumeration, check system documentation for details.",
      "options": {
        "database": {
          "aliases": [],
          "description": "The name of a getent database supported by the target system (passwd, group, hosts, etc).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "fail_key": {
          "aliases": [],
          "description": "If a supplied key is missing this will make the task fail if C(yes).",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "key": {
          "aliases": [],
          "description": "Key from which to return values from the specified database, otherwise the full contents are returned.",
          "default": "",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "service": {
          "aliases": [],
          "description": "Override all databases with the specified service\nThe underlying system must support the service flag which is not always available.",
          "type": "str",
          "required": false,
          "version_added": "2.9",
          "suboptions": {}
        },
        "split": {
          "aliases": [],
          "description": "Character used to split the database values into lists/arrays such as ':' or '\t', otherwise  it will try to pick one depending on the database.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "A wrapper to the unix getent utility",
      "version_added": "1.8"
    },
    "examples": "\n- name: Get root user info\n  getent:\n    database: passwd\n    key: root\n- debug:\n    var: ansible_facts.getent_passwd\n\n- name: Get all groups\n  getent:\n    database: group\n    split: ':'\n- debug:\n    var: ansible_facts.getent_group\n\n- name: Get all hosts, split by tab\n  getent:\n    database: hosts\n- debug:\n    var: ansible_facts.getent_hosts\n\n- name: Get http service info, no error if missing\n  getent:\n    database: services\n    key: http\n    fail_key: False\n- debug:\n    var: ansible_facts.getent_services\n\n- name: Get user password hash (requires sudo/root)\n  getent:\n    database: shadow\n    key: www-data\n    split: ':'\n- debug:\n    var: ansible_facts.getent_shadow\n\n"
  },
  "git": {
    "doc": {
      "description": "Manage I(git) checkouts of repositories to deploy files or software.",
      "has_action": false,
      "notes": "If the task seems to be hanging, first verify remote host is in C(known_hosts). SSH will prompt user to authorize the first contact with a remote host.  To avoid this prompt, one solution is to use the option accept_hostkey. Another solution is to add the remote host public key in C(/etc/ssh/ssh_known_hosts) before calling the git module, with the following command: ssh-keyscan -H remote_host.com >> /etc/ssh/ssh_known_hosts.",
      "options": {
        "accept_hostkey": {
          "aliases": [],
          "description": "If C(yes), ensure that \"-o StrictHostKeyChecking=no\" is present as an ssh option.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "accept_newhostkey": {
          "aliases": [],
          "description": "As of OpenSSH 7.5, \"-o StrictHostKeyChecking=accept-new\" can be used which is safer and will only accepts host keys which are not present or are the same. if C(yes), ensure that \"-o StrictHostKeyChecking=accept-new\" is present as an ssh option.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "archive": {
          "aliases": [],
          "description": "Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats [\"zip\", \"tar.gz\", \"tar\", \"tgz\"].\nThis will clone and perform git archive from local directory as not all git servers support git archive.",
          "type": "path",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "archive_prefix": {
          "aliases": [],
          "description": "Specify a prefix to add to each file path in archive. Requires I(archive) to be specified.",
          "type": "str",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "bare": {
          "aliases": [],
          "description": "If C(yes), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "clone": {
          "aliases": [],
          "description": "If C(no), do not clone the repository even if it does not exist locally.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "1.9",
          "suboptions": {}
        },
        "depth": {
          "aliases": [],
          "description": "Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.",
          "type": "int",
          "required": false,
          "version_added": "1.2",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "The path of where the repository should be checked out. This is equivalent to C(git clone [repo_url] [directory]). The repository named in I(repo) is not appended to this path and the destination directory must be empty. This parameter is required, unless I(clone) is set to C(no).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
          "type": "path",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "If C(yes), any modified files in the working repository will be discarded.  Prior to 0.7, this was always C(yes) and could not be disabled.  Prior to 1.9, the default was C(yes).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "0.7",
          "suboptions": {}
        },
        "gpg_whitelist": {
          "aliases": [],
          "description": "A list of trusted GPG fingerprints to compare to the fingerprint of the GPG-signed commit.\nOnly used when I(verify_commit=yes).\nUse of this feature requires Git 2.6+ due to its reliance on git's C(--raw) flag to C(verify-commit) and C(verify-tag).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.9",
          "suboptions": {}
        },
        "key_file": {
          "aliases": [],
          "description": "Specify an optional private key file path, on the target host, to use for the checkout.",
          "type": "path",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "recursive": {
          "aliases": [],
          "description": "If C(no), repository will be cloned without the --recursive option, skipping sub-modules.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "reference": {
          "aliases": [],
          "description": "Reference repository (see \"git clone --reference ...\").",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "refspec": {
          "aliases": [],
          "description": "Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the C(git fetch) command. An example value could be \"refs/meta/config\".",
          "type": "str",
          "required": false,
          "version_added": "1.9",
          "suboptions": {}
        },
        "remote": {
          "aliases": [],
          "description": "Name of the remote.",
          "default": "origin",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "repo": {
          "aliases": [
            "name"
          ],
          "description": "git, SSH, or HTTP(S) protocol address of the git repository.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "separate_git_dir": {
          "aliases": [],
          "description": "The path to place the cloned repository. If specified, Git repository can be separated from working tree.",
          "type": "path",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "single_branch": {
          "aliases": [],
          "description": "Clone only the history leading to the tip of the specified revision.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "ssh_opts": {
          "aliases": [],
          "description": "Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be \"-o StrictHostKeyChecking=no\" (although this particular option is better set by I(accept_hostkey)).",
          "type": "str",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "track_submodules": {
          "aliases": [],
          "description": "If C(yes), submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If C(no), submodules will be kept at the revision specified by the main project. This is equivalent to specifying the --remote flag to git submodule update.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        },
        "umask": {
          "aliases": [],
          "description": "The umask to set before doing any checkouts, or any other repository maintenance.",
          "type": "raw",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "update": {
          "aliases": [],
          "description": "If C(no), do not retrieve new revisions from the origin repository.\nOperations like archive will work on the existing (old) repository and might not respond to changes to the options version or remote.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "1.2",
          "suboptions": {}
        },
        "verify_commit": {
          "aliases": [],
          "description": "If C(yes), when cloning or checking out a I(version) verify the signature of a GPG signed commit. This requires git version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be present in the GPG keyring.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "version": {
          "aliases": [],
          "description": "What version of the repository to check out. This can be the literal string C(HEAD), a branch name, a tag name. It can also be a I(SHA-1) hash, in which case I(refspec) needs to be specified if the given revision is not already available.",
          "default": "HEAD",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "git>=1.7.1 (the command line tool)"
      ],
      "short_description": "Deploy software (or files) from git checkouts",
      "version_added": "0.0.1"
    },
    "examples": "\n- name: Git checkout\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    version: release-0.22\n\n- name: Read-write git checkout from github\n  ansible.builtin.git:\n    repo: git@github.com:mylogin/hello.git\n    dest: /home/mylogin/hello\n\n- name: Just ensuring the repo checkout exists\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    update: no\n\n- name: Just get information about the repository whether or not it has already been cloned locally\n  ansible.builtin.git:\n    repo: 'https://foosball.example.org/path/to/repo.git'\n    dest: /srv/checkout\n    clone: no\n    update: no\n\n- name: Checkout a github repo and use refspec to fetch all pull requests\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    refspec: '+refs/pull/*:refs/heads/*'\n\n- name: Create git archive from repo\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    archive: /tmp/ansible-examples.zip\n\n- name: Clone a repo with separate git directory\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    separate_git_dir: /src/ansible-examples.git\n\n- name: Example clone of a single branch\n  ansible.builtin.git:\n    repo: https://github.com/ansible/ansible-examples.git\n    dest: /src/ansible-examples\n    single_branch: yes\n    version: master\n\n- name: Avoid hanging when http(s) password is missing\n  ansible.builtin.git:\n    repo: https://github.com/ansible/could-be-a-private-repo\n    dest: /src/from-private-repo\n  environment:\n    GIT_TERMINAL_PROMPT: 0 # reports \"terminal prompts disabled\" on missing password\n    # or GIT_ASKPASS: /bin/true # for git before version 2.3.0, reports \"Authentication failed\" on missing password\n"
  },
  "group": {
    "doc": {
      "description": "Manage presence of groups on a host.\nFor Windows targets, use the M(ansible.windows.win_group) module instead.",
      "has_action": false,
      "options": {
        "gid": {
          "aliases": [],
          "description": "Optional I(GID) to set for the group.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "local": {
          "aliases": [],
          "description": "Forces the use of \"local\" command alternatives on platforms that implement it.\nThis is useful in environments that use centralized authentication when you want to manipulate the local groups. (for example, it uses C(lgroupadd) instead of C(groupadd)).\nThis requires that these commands exist on the targeted host, otherwise it will be a fatal error.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the group to manage.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "non_unique": {
          "aliases": [],
          "description": "This option allows to change the group ID to a non-unique value. Requires C(gid).\nNot supported on macOS or BusyBox distributions.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the group should be present or not on the remote host.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "system": {
          "aliases": [],
          "description": "If I(yes), indicates that the group created is a system group.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "groupadd",
        "groupdel",
        "groupmod"
      ],
      "short_description": "Add or remove groups",
      "version_added": "0.0.2"
    },
    "examples": "\n- name: Ensure group \"somegroup\" exists\n  ansible.builtin.group:\n    name: somegroup\n    state: present\n\n- name: Ensure group \"docker\" exists with correct gid\n  ansible.builtin.group:\n    name: docker\n    state: present\n    gid: 1750\n"
  },
  "group_by": {
    "doc": {
      "description": "Use facts to create ad-hoc groups that can be used later in a playbook.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "Spaces in group names are converted to dashes '-'.\nThough this module does not change the remote host, we do provide 'changed' status as it can be useful for those trying to track inventory changes.",
      "options": {
        "key": {
          "aliases": [],
          "description": "The variables whose values will be used as groups.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "parents": {
          "aliases": [],
          "description": "The list of the parent groups.",
          "default": "all",
          "type": "list",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        }
      },
      "short_description": "Create Ansible groups based on facts",
      "version_added": "0.9"
    },
    "examples": "\n- name: Create groups based on the machine architecture\n  ansible.builtin.group_by:\n    key: machine_{{ ansible_machine }}\n\n- name: Create groups like 'virt_kvm_host'\n  ansible.builtin.group_by:\n    key: virt_{{ ansible_virtualization_type }}_{{ ansible_virtualization_role }}\n\n- name: Create nested groups\n  ansible.builtin.group_by:\n    key: el{{ ansible_distribution_major_version }}-{{ ansible_architecture }}\n    parents:\n      - el{{ ansible_distribution_major_version }}\n\n- name: Add all active hosts to a static group\n  ansible.builtin.group_by:\n    key: done\n"
  },
  "hostname": {
    "doc": {
      "description": "Set system's hostname. Supports most OSs/Distributions including those using C(systemd).\nWindows, HP-UX, and AIX are not currently supported.",
      "has_action": false,
      "notes": "This module does B(NOT) modify C(/etc/hosts). You need to modify it yourself using other modules such as M(ansible.builtin.template) or M(ansible.builtin.replace).\nOn macOS, this module uses C(scutil) to set C(HostName), C(ComputerName), and C(LocalHostName). Since C(LocalHostName) cannot contain spaces or most special characters, this module will replace characters when setting C(LocalHostName).",
      "options": {
        "name": {
          "aliases": [],
          "description": "Name of the host.\nIf the value is a fully qualified domain name that does not resolve from the given host, this will cause the module to hang for a few seconds while waiting for the name resolution attempt to timeout.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "use": {
          "aliases": [],
          "description": "Which strategy to use to update the hostname.\nIf not set we try to autodetect, but this can be problematic, particularly with containers as they can present misleading information.\nNote that 'systemd' should be specified for RHEL/EL/CentOS 7+. Older distributions should use 'redhat'.",
          "type": "str",
          "required": false,
          "choices": [
            "alpine",
            "debian",
            "freebsd",
            "generic",
            "macos",
            "macosx",
            "darwin",
            "openbsd",
            "openrc",
            "redhat",
            "sles",
            "solaris",
            "systemd"
          ],
          "version_added": "2.9",
          "suboptions": {}
        }
      },
      "requirements": [
        "hostname"
      ],
      "short_description": "Manage hostname",
      "version_added": "1.4"
    },
    "examples": "\n- name: Set a hostname\n  ansible.builtin.hostname:\n    name: web01\n\n- name: Set a hostname specifying strategy\n  ansible.builtin.hostname:\n    name: web01\n    use: systemd\n"
  },
  "import_playbook": {
    "doc": {
      "description": "Includes a file with a list of plays to be executed.\nFiles with a list of plays can only be included at the top level.\nYou cannot use this action inside a play.",
      "has_action": false,
      "notes": "This is a core feature of Ansible, rather than a module, and cannot be overridden like a module.",
      "options": {
        "free-form": {
          "aliases": [],
          "description": "The name of the imported playbook is specified directly without any other option.",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Import a playbook",
      "version_added": "2.4"
    },
    "examples": "\n- hosts: localhost\n  tasks:\n    - debug:\n        msg: play1\n\n- name: Include a play after another play\n  import_playbook: otherplays.yaml\n\n- name: Set variables on an imported playbook\n  import_playbook: otherplays.yml\n  vars:\n    service: httpd\n\n- name: This DOES NOT WORK\n  hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: This fails because I'm inside a play already\n      import_playbook: stuff.yaml\n"
  },
  "import_role": {
    "doc": {
      "description": "Much like the C(roles:) keyword, this task loads a role, but it allows you to control when the role tasks run in between other tasks of the play.\nMost keywords, loops and conditionals will only be applied to the imported tasks, not to this statement itself. If you want the opposite behavior, use M(ansible.builtin.include_role) instead.\nDoes not work in handlers.",
      "has_action": false,
      "notes": "Handlers are made available to the whole play.\nSince Ansible 2.7 variables defined in C(vars) and C(defaults) for the role are exposed to the play at playbook parsing time. Due to this, these variables will be accessible to roles and tasks executed before the location of the M(ansible.builtin.import_role) task.\nUnlike M(ansible.builtin.include_role) variable exposure is not configurable, and will always be exposed.",
      "options": {
        "allow_duplicates": {
          "aliases": [],
          "description": "Overrides the role's metadata setting to allow using a role more than once with the same parameters.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "defaults_from": {
          "aliases": [],
          "description": "File to load from a role's C(defaults/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "handlers_from": {
          "aliases": [],
          "description": "File to load from a role's C(handlers/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of the role to be executed.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "rolespec_validate": {
          "aliases": [],
          "description": "Perform role argument spec validation if an argument spec is defined.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "tasks_from": {
          "aliases": [],
          "description": "File to load from a role's C(tasks/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "vars_from": {
          "aliases": [],
          "description": "File to load from a role's C(vars/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Import a role into a play",
      "version_added": "2.4"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - import_role:\n        name: myrole\n\n    - name: Run tasks/other.yaml instead of 'main'\n      import_role:\n        name: myrole\n        tasks_from: other\n\n    - name: Pass variables to role\n      import_role:\n        name: myrole\n      vars:\n        rolevar1: value from task\n\n    - name: Apply condition to each task in role\n      import_role:\n        name: myrole\n      when: not idontwanttorun\n"
  },
  "import_tasks": {
    "doc": {
      "description": "Imports a list of tasks to be added to the current playbook for subsequent execution.",
      "has_action": false,
      "notes": "This is a core feature of Ansible, rather than a module, and cannot be overridden like a module",
      "options": {
        "free-form": {
          "aliases": [],
          "description": "The name of the imported file is specified directly without any other option.\nMost keywords, including loops and conditionals, only applied to the imported tasks, not to this statement itself.\nIf you need any of those to apply, use M(ansible.builtin.include_tasks) instead.",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Import a task list",
      "version_added": "2.4"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Include task list in play\n      import_tasks: stuff.yaml\n\n    - debug:\n        msg: task10\n\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Apply conditional to all imported tasks\n      import_tasks: stuff.yaml\n      when: hostvar is defined\n"
  },
  "include": {
    "doc": {
      "description": "Includes a file with a list of plays or tasks to be executed in the current playbook.\nFiles with a list of plays can only be included at the top level. Lists of tasks can only be included where tasks normally run (in play).\nBefore Ansible 2.0, all includes were 'static' and were executed when the play was compiled.\nStatic includes are not subject to most directives. For example, loops or conditionals are applied instead to each inherited task.\nSince Ansible 2.0, task includes are dynamic and behave more like real tasks. This means they can be looped, skipped and use variables from any source. Ansible tries to auto detect this, but you can use the C(static) directive (which was added in Ansible 2.1) to bypass autodetection.\nThis module is also supported for Windows targets.",
      "has_action": false,
      "notes": "This is a core feature of Ansible, rather than a module, and cannot be overridden like a module.\nInclude has some unintuitive behaviours depending on if it is running in a static or dynamic in play or in playbook context, in an effort to clarify behaviours we are moving to a new set modules (M(ansible.builtin.include_tasks), M(ansible.builtin.include_role), M(ansible.builtin.import_playbook), M(ansible.builtin.import_tasks)) that have well established and clear behaviours.\nB(This module will still be supported for some time but we are looking at deprecating it in the near future.)",
      "options": {
        "free-form": {
          "aliases": [],
          "description": "This module allows you to specify the name of the file directly without any other options.",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Include a play or task list",
      "version_added": "0.6"
    },
    "examples": "\n- hosts: localhost\n  tasks:\n    - debug:\n        msg: play1\n\n- name: Include a play after another play\n  include: otherplays.yaml\n\n\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Include task list in play\n      include: stuff.yaml\n\n    - debug:\n        msg: task10\n\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Include task list in play only if the condition is true\n      include: \"{{ hostvar }}.yaml\"\n      static: no\n      when: hostvar is defined\n"
  },
  "include_role": {
    "doc": {
      "description": "Dynamically loads and executes a specified role as a task.\nMay be used only where Ansible tasks are allowed - inside C(pre_tasks), C(tasks), or C(post_tasks) play objects, or as a task inside a role.\nTask-level keywords, loops, and conditionals apply only to the C(include_role) statement itself.\nTo apply keywords to the tasks within the role, pass them using the C(apply) option or use M(ansible.builtin.import_role) instead.\nIgnores some keywords, like C(until) and C(retries).\nThis module is also supported for Windows targets.\nDoes not work in handlers.",
      "has_action": false,
      "notes": "Handlers and are made available to the whole play.\nAfter Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.",
      "options": {
        "allow_duplicates": {
          "aliases": [],
          "description": "Overrides the role's metadata setting to allow using a role more than once with the same parameters.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "apply": {
          "aliases": [],
          "description": "Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to all tasks within the included role.",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "defaults_from": {
          "aliases": [],
          "description": "File to load from a role's C(defaults/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "handlers_from": {
          "aliases": [],
          "description": "File to load from a role's C(handlers/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of the role to be executed.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "public": {
          "aliases": [],
          "description": "This option dictates whether the role's C(vars) and C(defaults) are exposed to the play. If set to C(yes) the variables will be available to tasks following the C(include_role) task. This functionality differs from standard variable exposure for roles listed under the C(roles) header or C(import_role) as they are exposed to the play at playbook parsing time, and available to earlier roles and tasks as well.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "rolespec_validate": {
          "aliases": [],
          "description": "Perform role argument spec validation if an argument spec is defined.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "tasks_from": {
          "aliases": [],
          "description": "File to load from a role's C(tasks/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "vars_from": {
          "aliases": [],
          "description": "File to load from a role's C(vars/) directory.",
          "default": "main",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Load and execute a role",
      "version_added": "2.2"
    },
    "examples": "\n- include_role:\n    name: myrole\n\n- name: Run tasks/other.yaml instead of 'main'\n  include_role:\n    name: myrole\n    tasks_from: other\n\n- name: Pass variables to role\n  include_role:\n    name: myrole\n  vars:\n    rolevar1: value from task\n\n- name: Use role in loop\n  include_role:\n    name: '{{ roleinputvar }}'\n  loop:\n    - '{{ roleinput1 }}'\n    - '{{ roleinput2 }}'\n  loop_control:\n    loop_var: roleinputvar\n\n- name: Conditional role\n  include_role:\n    name: myrole\n  when: not idontwanttorun\n\n- name: Apply tags to tasks within included file\n  include_role:\n    name: install\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n"
  },
  "include_tasks": {
    "doc": {
      "description": "Includes a file with a list of tasks to be executed in the current playbook.",
      "has_action": false,
      "options": {
        "apply": {
          "aliases": [],
          "description": "Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "file": {
          "aliases": [],
          "description": "The name of the imported file is specified directly without any other option.\nUnlike M(ansible.builtin.import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.\nThe do until loop is not supported on M(ansible.builtin.include_tasks).",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "free-form": {
          "aliases": [],
          "description": "Supplying a file name via free-form C(- include_tasks: file.yml) of a file to be included is the equivalent\nof specifying an argument of I(file).\n",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Dynamically include a task list",
      "version_added": "2.4"
    },
    "examples": "\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Include task list in play\n      include_tasks: stuff.yaml\n\n    - debug:\n        msg: task10\n\n- hosts: all\n  tasks:\n    - debug:\n        msg: task1\n\n    - name: Include task list in play only if the condition is true\n      include_tasks: \"{{ hostvar }}.yaml\"\n      when: hostvar is defined\n\n- name: Apply tags to tasks within included file\n  include_tasks:\n    file: install.yml\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n\n- name: Apply tags to tasks within included file when using free-form\n  include_tasks: install.yml\n  args:\n    apply:\n      tags:\n        - install\n  tags:\n    - always\n"
  },
  "include_vars": {
    "doc": {
      "description": "Loads YAML/JSON variables dynamically from a file or directory, recursively, during task runtime.\nIf loading a directory, the files are sorted alphabetically before being loaded.\nThis module is also supported for Windows targets.\nTo assign included variables to a different host than C(inventory_hostname), use C(delegate_to) and set C(delegate_facts=yes).",
      "has_action": true,
      "options": {
        "depth": {
          "aliases": [],
          "description": "When using C(dir), this module will, by default, recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth.",
          "default": "0",
          "type": "int",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "dir": {
          "aliases": [],
          "description": "The directory name from which the variables should be loaded.\nIf the path is relative and the task is inside a role, it will look inside the role's vars/ subdirectory.\nIf the path is relative and not inside a role, it will be parsed relative to the playbook.",
          "type": "path",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "extensions": {
          "aliases": [],
          "description": "List of file extensions to read when using C(dir).",
          "default": "['json', 'yaml', 'yml']",
          "type": "list",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "file": {
          "aliases": [],
          "description": "The file name from which variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.",
          "type": "path",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "files_matching": {
          "aliases": [],
          "description": "Limit the files that are loaded within any directory to this regular expression.",
          "type": "str",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "free-form": {
          "aliases": [],
          "description": "This module allows you to specify the 'file' option directly without any other options.\nThere is no 'free-form' option, this is just an indicator, see example below.",
          "required": false,
          "suboptions": {}
        },
        "hash_behaviour": {
          "aliases": [],
          "description": "If set to C(merge), merges existing hash variables instead of overwriting them.\nIf omitted C(null), the behavior falls back to the global I(hash_behaviour) configuration.",
          "type": "str",
          "required": false,
          "choices": [
            "replace",
            "merge"
          ],
          "version_added": "2.12",
          "suboptions": {}
        },
        "ignore_files": {
          "aliases": [],
          "description": "List of file names to ignore.",
          "type": "list",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "ignore_unknown_extensions": {
          "aliases": [],
          "description": "Ignore unknown file extensions within the directory.\nThis allows users to specify a directory containing vars files that are intermingled with non-vars files extension types (e.g. a directory with a README in it and vars files).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of a variable into which assign the included vars.\nIf omitted (null) they will be made top level vars.",
          "type": "str",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "short_description": "Load variables from files, dynamically within a task",
      "version_added": "1.4"
    },
    "examples": "\n- name: Include vars of stuff.yaml into the 'stuff' variable (2.2).\n  include_vars:\n    file: stuff.yaml\n    name: stuff\n\n- name: Conditionally decide to load in variables into 'plans' when x is 0, otherwise do not. (2.2)\n  include_vars:\n    file: contingency_plan.yaml\n    name: plans\n  when: x == 0\n\n- name: Load a variable file based on the OS type, or a default if not found. Using free-form to specify the file.\n  include_vars: \"{{ lookup('first_found', params) }}\"\n  vars:\n    params:\n      files:\n        - '{{ansible_distribution}}.yaml'\n        - '{{ansible_os_family}}.yaml'\n        - default.yaml\n      paths:\n        - 'vars'\n\n- name: Bare include (free-form)\n  include_vars: myvars.yaml\n\n- name: Include all .json and .jsn files in vars/all and all nested directories (2.3)\n  include_vars:\n    dir: vars/all\n    extensions:\n      - 'json'\n      - 'jsn'\n\n- name: Include all default extension files in vars/all and all nested directories and save the output in test. (2.2)\n  include_vars:\n    dir: vars/all\n    name: test\n\n- name: Include default extension files in vars/services (2.2)\n  include_vars:\n    dir: vars/services\n    depth: 1\n\n- name: Include only files matching bastion.yaml (2.2)\n  include_vars:\n    dir: vars\n    files_matching: bastion.yaml\n\n- name: Include all .yaml files except bastion.yaml (2.3)\n  include_vars:\n    dir: vars\n    ignore_files:\n      - 'bastion.yaml'\n    extensions:\n      - 'yaml'\n\n- name: Ignore warnings raised for files with unknown extensions while loading (2.7)\n  include_vars:\n    dir: vars\n    ignore_unknown_extensions: True\n    extensions:\n      - ''\n      - 'yaml'\n      - 'yml'\n      - 'json'\n"
  },
  "iptables": {
    "doc": {
      "description": "C(iptables) is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.\nThis module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the C(iptables) and C(ip6tables) command which this module uses internally.",
      "has_action": false,
      "notes": "This module just deals with individual rules. If you need advanced chaining of rules the recommended way is to template the iptables restore file.",
      "options": {
        "action": {
          "aliases": [],
          "description": "Whether the rule should be appended at the bottom or inserted at the top.\nIf the rule already exists the chain will not be modified.",
          "default": "append",
          "type": "str",
          "required": false,
          "choices": [
            "append",
            "insert"
          ],
          "version_added": "2.2",
          "suboptions": {}
        },
        "chain": {
          "aliases": [],
          "description": "Specify the iptables chain to modify.\nThis could be a user-defined chain or one of the standard iptables chains, like C(INPUT), C(FORWARD), C(OUTPUT), C(PREROUTING), C(POSTROUTING), C(SECMARK) or C(CONNSECMARK).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "comment": {
          "aliases": [],
          "description": "This specifies a comment that will be added to the rule.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ctstate": {
          "aliases": [],
          "description": "A list of the connection states to match in the conntrack module.\nPossible values are C(INVALID), C(NEW), C(ESTABLISHED), C(RELATED), C(UNTRACKED), C(SNAT), C(DNAT).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "destination": {
          "aliases": [],
          "description": "Destination specification.\nAddress can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.\nHostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.\nThe mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "destination_port": {
          "aliases": [],
          "description": "Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "destination_ports": {
          "aliases": [],
          "description": "This specifies multiple destination port numbers or port ranges to match in the multiport module.\nIt can only be used in conjunction with the protocols tcp, udp, udplite, dccp and sctp.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.11",
          "suboptions": {}
        },
        "dst_range": {
          "aliases": [],
          "description": "Specifies the destination IP range to match in the iprange module.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "flush": {
          "aliases": [],
          "description": "Flushes the specified table and chain of all rules.\nIf no chain is specified then the entire table is purged.\nIgnores all other parameters.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "fragment": {
          "aliases": [],
          "description": "This means that the rule only refers to second and further fragments of fragmented packets.\nSince there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them.\nWhen the \"!\" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "gateway": {
          "aliases": [],
          "description": "This specifies the IP address of host to send the cloned packets.\nThis option is only valid when C(jump) is set to C(TEE).",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "gid_owner": {
          "aliases": [],
          "description": "Specifies the GID or group to use in match by owner rule.",
          "type": "str",
          "required": false,
          "version_added": "2.9",
          "suboptions": {}
        },
        "goto": {
          "aliases": [],
          "description": "This specifies that the processing should continue in a user specified chain.\nUnlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "icmp_type": {
          "aliases": [],
          "description": "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'",
          "type": "str",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "in_interface": {
          "aliases": [],
          "description": "Name of an interface via which a packet was received (only for packets entering the C(INPUT), C(FORWARD) and C(PREROUTING) chains).\nWhen the C(!) argument is used before the interface name, the sense is inverted.\nIf the interface name ends in a C(+), then any interface which begins with this name will match.\nIf this option is omitted, any interface name will match.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ip_version": {
          "aliases": [],
          "description": "Which version of the IP protocol this rule should apply to.",
          "default": "ipv4",
          "type": "str",
          "required": false,
          "choices": [
            "ipv4",
            "ipv6"
          ],
          "suboptions": {}
        },
        "jump": {
          "aliases": [],
          "description": "This specifies the target of the rule; i.e., what to do if the packet matches it.\nThe target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).\nIf this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "limit": {
          "aliases": [],
          "description": "Specifies the maximum average number of matches to allow per second.\nThe number can specify units explicitly, using C(/second), C(/minute), C(/hour) or C(/day), or parts of them (so C(5/second) is the same as C(5/s)).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "limit_burst": {
          "aliases": [],
          "description": "Specifies the maximum burst before the above limit kicks in.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "log_level": {
          "aliases": [],
          "description": "Logging level according to the syslogd-defined priorities.\nThe value can be strings or numbers from 1-8.\nThis parameter is only applicable if C(jump) is set to C(LOG).",
          "type": "str",
          "required": false,
          "choices": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "emerg",
            "alert",
            "crit",
            "error",
            "warning",
            "notice",
            "info",
            "debug"
          ],
          "version_added": "2.8",
          "suboptions": {}
        },
        "log_prefix": {
          "aliases": [],
          "description": "Specifies a log text for the rule. Only make sense with a LOG jump.",
          "type": "str",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "match": {
          "aliases": [],
          "description": "Specifies a match to use, that is, an extension module that tests for a specific property.\nThe set of matches make up the condition under which a target is invoked.\nMatches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "match_set": {
          "aliases": [],
          "description": "Specifies a set name which can be defined by ipset.\nMust be used together with the match_set_flags parameter.\nWhen the C(!) argument is prepended then it inverts the rule.\nUses the iptables set extension.",
          "type": "str",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "match_set_flags": {
          "aliases": [],
          "description": "Specifies the necessary flags for the match_set parameter.\nMust be used together with the match_set parameter.\nUses the iptables set extension.",
          "type": "str",
          "required": false,
          "choices": [
            "src",
            "dst",
            "src,dst",
            "dst,src"
          ],
          "version_added": "2.11",
          "suboptions": {}
        },
        "out_interface": {
          "aliases": [],
          "description": "Name of an interface via which a packet is going to be sent (for packets entering the C(FORWARD), C(OUTPUT) and C(POSTROUTING) chains).\nWhen the C(!) argument is used before the interface name, the sense is inverted.\nIf the interface name ends in a C(+), then any interface which begins with this name will match.\nIf this option is omitted, any interface name will match.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "policy": {
          "aliases": [],
          "description": "Set the policy for the chain to the given target.\nOnly built-in chains can have policies.\nThis parameter requires the C(chain) parameter.\nIf you specify this parameter, all other parameters will be ignored.\nThis parameter is used to set default policy for the given C(chain). Do not confuse this with C(jump) parameter.",
          "type": "str",
          "required": false,
          "choices": [
            "ACCEPT",
            "DROP",
            "QUEUE",
            "RETURN"
          ],
          "version_added": "2.2",
          "suboptions": {}
        },
        "protocol": {
          "aliases": [],
          "description": "The protocol of the rule or of the packet to check.\nThe specified protocol can be one of C(tcp), C(udp), C(udplite), C(icmp), C(ipv6-icmp) or C(icmpv6), C(esp), C(ah), C(sctp) or the special keyword C(all), or it can be a numeric value, representing one of these protocols or a different one.\nA protocol name from I(/etc/protocols) is also allowed.\nA C(!) argument before the protocol inverts the test.\nThe number zero is equivalent to all.\nC(all) will match with all protocols and is taken as default when this option is omitted.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "reject_with": {
          "aliases": [],
          "description": "Specifies the error packet type to return while rejecting. It implies \"jump: REJECT\".",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "rule_num": {
          "aliases": [],
          "description": "Insert the rule as the given rule number.\nThis works only with C(action=insert).",
          "type": "str",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "set_counters": {
          "aliases": [],
          "description": "This enables the administrator to initialize the packet and byte counters of a rule (during C(INSERT), C(APPEND), C(REPLACE) operations).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "set_dscp_mark": {
          "aliases": [],
          "description": "This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.\nMutually exclusive with C(set_dscp_mark_class).",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "set_dscp_mark_class": {
          "aliases": [],
          "description": "This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.\nMutually exclusive with C(set_dscp_mark).",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "source": {
          "aliases": [],
          "description": "Source specification.\nAddress can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.\nHostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.\nThe mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "source_port": {
          "aliases": [],
          "description": "Source port or port range specification.\nThis can either be a service name or a port number.\nAn inclusive range can also be specified, using the format C(first:last).\nIf the first port is omitted, C(0) is assumed; if the last is omitted, C(65535) is assumed.\nIf the first port is greater than the second one they will be swapped.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src_range": {
          "aliases": [],
          "description": "Specifies the source IP range to match in the iprange module.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the rule should be absent or present.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "syn": {
          "aliases": [],
          "description": "This allows matching packets that have the SYN bit set and the ACK and RST bits unset.\nWhen negated, this matches all packets with the RST or the ACK bits set.",
          "default": "ignore",
          "type": "str",
          "required": false,
          "choices": [
            "ignore",
            "match",
            "negate"
          ],
          "version_added": "2.5",
          "suboptions": {}
        },
        "table": {
          "aliases": [],
          "description": "This option specifies the packet matching table which the command should operate on.\nIf the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.",
          "default": "filter",
          "type": "str",
          "required": false,
          "choices": [
            "filter",
            "nat",
            "mangle",
            "raw",
            "security"
          ],
          "suboptions": {}
        },
        "tcp_flags": {
          "aliases": [],
          "description": "TCP flags specification.\nC(tcp_flags) expects a dict with the two keys C(flags) and C(flags_set).",
          "default": "{}",
          "type": "dict",
          "required": false,
          "version_added": "2.4",
          "suboptions": {
            "flags": {
              "aliases": [],
              "description": "List of flags you want to examine.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            },
            "flags_set": {
              "aliases": [],
              "description": "Flags to be set.",
              "type": "list",
              "required": false,
              "elements": "str",
              "suboptions": {}
            }
          }
        },
        "to_destination": {
          "aliases": [],
          "description": "This specifies a destination address to use with C(DNAT).\nWithout this, the destination address is never altered.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "to_ports": {
          "aliases": [],
          "description": "This specifies a destination port or range of ports to use, without this, the destination port is never altered.\nThis is only valid if the rule also specifies one of the protocol C(tcp), C(udp), C(dccp) or C(sctp).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "to_source": {
          "aliases": [],
          "description": "This specifies a source address to use with C(SNAT).\nWithout this, the source address is never altered.",
          "type": "str",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "uid_owner": {
          "aliases": [],
          "description": "Specifies the UID or username to use in match by owner rule.\nFrom Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "wait": {
          "aliases": [],
          "description": "Wait N seconds for the xtables lock to prevent multiple instances of the program from running concurrently.",
          "type": "str",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        }
      },
      "short_description": "Modify iptables rules",
      "version_added": "2.0"
    },
    "examples": "\n- name: Block specific IP\n  ansible.builtin.iptables:\n    chain: INPUT\n    source: 8.8.8.8\n    jump: DROP\n  become: yes\n\n- name: Forward port 80 to 8600\n  ansible.builtin.iptables:\n    table: nat\n    chain: PREROUTING\n    in_interface: eth0\n    protocol: tcp\n    match: tcp\n    destination_port: 80\n    jump: REDIRECT\n    to_ports: 8600\n    comment: Redirect web traffic to port 8600\n  become: yes\n\n- name: Allow related and established connections\n  ansible.builtin.iptables:\n    chain: INPUT\n    ctstate: ESTABLISHED,RELATED\n    jump: ACCEPT\n  become: yes\n\n- name: Allow new incoming SYN packets on TCP port 22 (SSH)\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_port: 22\n    ctstate: NEW\n    syn: match\n    jump: ACCEPT\n    comment: Accept new SSH connections.\n\n- name: Match on IP ranges\n  ansible.builtin.iptables:\n    chain: FORWARD\n    src_range: 192.168.1.100-192.168.1.199\n    dst_range: 10.0.0.1-10.0.0.50\n    jump: ACCEPT\n\n- name: Allow source IPs defined in ipset \"admin_hosts\" on port 22\n  ansible.builtin.iptables:\n    chain: INPUT\n    match_set: admin_hosts\n    match_set_flags: src\n    destination_port: 22\n    jump: ALLOW\n\n- name: Tag all outbound tcp packets with DSCP mark 8\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DSCP\n    table: mangle\n    set_dscp_mark: 8\n    protocol: tcp\n\n- name: Tag all outbound tcp packets with DSCP DiffServ class CS1\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DSCP\n    table: mangle\n    set_dscp_mark_class: CS1\n    protocol: tcp\n\n- name: Insert a rule on line 5\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_port: 8080\n    jump: ACCEPT\n    action: insert\n    rule_num: 5\n\n# Think twice before running following task as this may lock target system\n- name: Set the policy for the INPUT chain to DROP\n  ansible.builtin.iptables:\n    chain: INPUT\n    policy: DROP\n\n- name: Reject tcp with tcp-reset\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    reject_with: tcp-reset\n    ip_version: ipv4\n\n- name: Set tcp flags\n  ansible.builtin.iptables:\n    chain: OUTPUT\n    jump: DROP\n    protocol: tcp\n    tcp_flags:\n      flags: ALL\n      flags_set:\n        - ACK\n        - RST\n        - SYN\n        - FIN\n\n- name: Iptables flush filter\n  ansible.builtin.iptables:\n    chain: \"{{ item }}\"\n    flush: yes\n  with_items:  [ 'INPUT', 'FORWARD', 'OUTPUT' ]\n\n- name: Iptables flush nat\n  ansible.builtin.iptables:\n    table: nat\n    chain: '{{ item }}'\n    flush: yes\n  with_items: [ 'INPUT', 'OUTPUT', 'PREROUTING', 'POSTROUTING' ]\n\n- name: Log packets arriving into an user-defined chain\n  ansible.builtin.iptables:\n    chain: LOGGING\n    action: append\n    state: present\n    limit: 2/second\n    limit_burst: 20\n    log_prefix: \"IPTABLES:INFO: \"\n    log_level: info\n\n- name: Allow connections on multiple ports\n  ansible.builtin.iptables:\n    chain: INPUT\n    protocol: tcp\n    destination_ports:\n      - \"80\"\n      - \"443\"\n      - \"8081:8083\"\n    jump: ACCEPT\n"
  },
  "known_hosts": {
    "doc": {
      "description": "The C(known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.\nStarting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(ansible.builtin.git) module over ssh, for example.\nIf you have a very large number of host keys to manage, you will find the M(ansible.builtin.template) module more useful.",
      "has_action": false,
      "options": {
        "hash_host": {
          "aliases": [],
          "description": "Hash the hostname in the known_hosts file.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "key": {
          "aliases": [],
          "description": "The SSH public host key, as a string.\nRequired if C(state=present), optional when C(state=absent), in which case all keys for the host are removed.\nThe key must be in the right format for SSH (see sshd(8), section \"SSH_KNOWN_HOSTS FILE FORMAT\").\nSpecifically, the key should not match the format that is found in an SSH pubkey file, but should rather have the hostname prepended to a line that includes the pubkey, the same way that it would appear in the known_hosts file. The value prepended to the line must also match the value of the name parameter.\nShould be of format C(<hostname[,IP]> ssh-rsa <pubkey>).\nFor custom SSH port, C(key) needs to specify port as well. See example section.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "host"
          ],
          "description": "The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.\nMust match with <hostname> or <ip> present in key attribute.\nFor custom SSH port, C(name) needs to specify port as well. See example section.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The known_hosts file to edit.\nThe known_hosts file will be created if needed. The rest of the path must exist prior to running the module.",
          "default": "~/.ssh/known_hosts",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "I(present) to add the host key.\nI(absent) to remove it.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Add or remove a host from the C(known_hosts) file",
      "version_added": "1.9"
    },
    "examples": "\n- name: Tell the host about our servers it might want to ssh to\n  known_hosts:\n    path: /etc/ssh/ssh_known_hosts\n    name: foo.com.invalid\n    key: \"{{ lookup('file', 'pubkeys/foo.com.invalid') }}\"\n\n- name: Another way to call known_hosts\n  known_hosts:\n    name: host1.example.com   # or 10.9.8.77\n    key: host1.example.com,10.9.8.77 ssh-rsa ASDeararAIUHI324324  # some key gibberish\n    path: /etc/ssh/ssh_known_hosts\n    state: present\n\n- name: Add host with custom SSH port\n  known_hosts:\n    name: '[host1.example.com]:2222'\n    key: '[host1.example.com]:2222 ssh-rsa ASDeararAIUHI324324' # some key gibberish\n    path: /etc/ssh/ssh_known_hosts\n    state: present\n"
  },
  "lineinfile": {
    "doc": {
      "description": "This module ensures a particular line is in a file, or replace an existing line using a back-referenced regular expression.\nThis is primarily useful when you want to change a single line in a file only.\nSee the M(ansible.builtin.replace) module if you want to change multiple, similar lines or check M(ansible.builtin.blockinfile) if you want to insert/update/remove a block of lines in a file. For other cases, see the M(ansible.builtin.copy) or M(ansible.builtin.template) modules.",
      "has_action": false,
      "notes": "As of Ansible 2.3, the I(dest) option has been changed to I(path) as default, but I(dest) still works as well.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backrefs": {
          "aliases": [],
          "description": "Used with C(state=present).\nIf set, C(line) can contain backreferences (both positional and named) that will get populated if the C(regexp) matches.\nThis parameter changes the operation of the module slightly; C(insertbefore) and C(insertafter) will be ignored, and if the C(regexp) does not match anywhere in the file, the file will be left unchanged.\nIf the C(regexp) does match, the last matching line will be replaced by the expanded line parameter.\nMutually exclusive with C(search_string).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "create": {
          "aliases": [],
          "description": "Used with C(state=present).\nIf specified, the file will be created if it does not already exist.\nBy default it will fail if the file is missing.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "firstmatch": {
          "aliases": [],
          "description": "Used with C(insertafter) or C(insertbefore).\nIf set, C(insertafter) and C(insertbefore) will work with the first line that matches the given regular expression.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "insertafter": {
          "aliases": [],
          "description": "Used with C(state=present).\nIf specified, the line will be inserted after the last match of specified regular expression.\nIf the first match is required, use(firstmatch=yes).\nA special value is available; C(EOF) for inserting the line at the end of the file.\nIf specified regular expression has no matches, EOF will be used instead.\nIf C(insertbefore) is set, default value C(EOF) will be ignored.\nIf regular expressions are passed to both C(regexp) and C(insertafter), C(insertafter) is only honored if no match for C(regexp) is found.\nMay not be used with C(backrefs) or C(insertbefore).",
          "default": "EOF",
          "type": "str",
          "required": false,
          "choices": [
            "EOF",
            "*regex*"
          ],
          "suboptions": {}
        },
        "insertbefore": {
          "aliases": [],
          "description": "Used with C(state=present).\nIf specified, the line will be inserted before the last match of specified regular expression.\nIf the first match is required, use C(firstmatch=yes).\nA value is available; C(BOF) for inserting the line at the beginning of the file.\nIf specified regular expression has no matches, the line will be inserted at the end of the file.\nIf regular expressions are passed to both C(regexp) and C(insertbefore), C(insertbefore) is only honored if no match for C(regexp) is found.\nMay not be used with C(backrefs) or C(insertafter).",
          "type": "str",
          "required": false,
          "choices": [
            "BOF",
            "*regex*"
          ],
          "version_added": "1.1",
          "suboptions": {}
        },
        "line": {
          "aliases": [
            "value"
          ],
          "description": "The line to insert/replace into the file.\nRequired for C(state=present).\nIf C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "others": {
          "aliases": [],
          "description": "All arguments accepted by the M(ansible.builtin.file) module also work here.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "destfile",
            "name"
          ],
          "description": "The file to modify.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "regexp": {
          "aliases": [
            "regex"
          ],
          "description": "The regular expression to look for in every line of the file.\nFor C(state=present), the pattern to replace if found. Only the last line found will be replaced.\nFor C(state=absent), the pattern of the line(s) to remove.\nIf the regular expression is not matched, the line will be added to the file in keeping with C(insertbefore) or C(insertafter) settings.\nWhen modifying a line the regexp should typically match both the initial state of the line as well as its state after replacement by C(line) to ensure idempotence.\nUses Python regular expressions. See U(https://docs.python.org/3/library/re.html).",
          "type": "str",
          "required": false,
          "version_added": "1.7",
          "suboptions": {}
        },
        "search_string": {
          "aliases": [],
          "description": "The literal string to look for in every line of the file. This does not have to match the entire line.\nFor C(state=present), the line to replace if the string is found in the file. Only the last line found will be replaced.\nFor C(state=absent), the line(s) to remove if the string is in the line.\nIf the literal expression is not matched, the line will be added to the file in keeping with C(insertbefore) or C(insertafter) settings.\nMutually exclusive with C(backrefs) and C(regexp).",
          "type": "str",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the line should be there or not.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying the updated file into the final destination.\nA temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.\nAlso, the command is passed securely so shell features such as expansion and pipes will not work.\nFor an example on how to handle more complex validation than what this option provides, see L(Complex configuration validation,https://docs.ansible.com/ansible/devel/reference_appendices/faq.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage lines in text files",
      "version_added": "0.7"
    },
    "examples": "\n# NOTE: Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'\n- name: Ensure SELinux is set to enforcing mode\n  ansible.builtin.lineinfile:\n    path: /etc/selinux/config\n    regexp: '^SELINUX='\n    line: SELINUX=enforcing\n\n- name: Make sure group wheel is not in the sudoers configuration\n  ansible.builtin.lineinfile:\n    path: /etc/sudoers\n    state: absent\n    regexp: '^%wheel'\n\n- name: Replace a localhost entry with our own\n  ansible.builtin.lineinfile:\n    path: /etc/hosts\n    regexp: '^127\\.0\\.0\\.1'\n    line: 127.0.0.1 localhost\n    owner: root\n    group: root\n    mode: '0644'\n\n- name: Replace a localhost entry searching for a literal string to avoid escaping\n  lineinfile:\n    path: /etc/hosts\n    search_string: '127.0.0.1'\n    line: 127.0.0.1 localhost\n    owner: root\n    group: root\n    mode: '0644'\n\n- name: Ensure the default Apache port is 8080\n  ansible.builtin.lineinfile:\n    path: /etc/httpd/conf/httpd.conf\n    regexp: '^Listen '\n    insertafter: '^#Listen '\n    line: Listen 8080\n\n- name: Ensure php extension matches new pattern\n  lineinfile:\n    path: /etc/httpd/conf/httpd.conf\n    search_string: '<FilesMatch \".php[45]?$\">'\n    insertafter: '^\\t<Location \\/>\\n'\n    line: '        <FilesMatch \".php[34]?$\">'\n\n- name: Ensure we have our own comment added to /etc/services\n  ansible.builtin.lineinfile:\n    path: /etc/services\n    regexp: '^# port for http'\n    insertbefore: '^www.*80/tcp'\n    line: '# port for http by default'\n\n- name: Add a line to a file if the file does not exist, without passing regexp\n  ansible.builtin.lineinfile:\n    path: /tmp/testfile\n    line: 192.168.1.99 foo.lab.net foo\n    create: yes\n\n# NOTE: Yaml requires escaping backslashes in double quotes but not in single quotes\n- name: Ensure the JBoss memory settings are exactly as needed\n  ansible.builtin.lineinfile:\n    path: /opt/jboss-as/bin/standalone.conf\n    regexp: '^(.*)Xms(\\d+)m(.*)$'\n    line: '\\1Xms${xms}m\\3'\n    backrefs: yes\n\n# NOTE: Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.\n- name: Validate the sudoers file before saving\n  ansible.builtin.lineinfile:\n    path: /etc/sudoers\n    state: present\n    regexp: '^%ADMIN ALL='\n    line: '%ADMIN ALL=(ALL) NOPASSWD: ALL'\n    validate: /usr/sbin/visudo -cf %s\n\n# See https://docs.python.org/3/library/re.html for further details on syntax\n- name: Use backrefs with alternative group syntax to avoid conflicts with variable values\n  ansible.builtin.lineinfile:\n    path: /tmp/config\n    regexp: ^(host=).*\n    line: \\g<1>{{ hostname }}\n    backrefs: yes\n"
  },
  "meta": {
    "doc": {
      "description": "Meta tasks are a special kind of task which can influence Ansible internal execution or state.\nMeta tasks can be used anywhere within your playbook.\nThis module is also supported for Windows targets.",
      "has_action": false,
      "notes": "C(clear_facts) will remove the persistent facts from M(ansible.builtin.set_fact) using C(cacheable=True), but not the current host variable it creates for the current run.\nSkipping C(meta) tasks with tags is not supported before Ansible 2.11.",
      "options": {
        "free_form": {
          "aliases": [],
          "description": "This module takes a free form command, as a string. There is not an actual option named \"free form\".  See the examples!\nC(flush_handlers) makes Ansible run any handler tasks which have thus far been notified. Ansible inserts these tasks internally at certain points to implicitly trigger handler runs (after pre/post tasks, the final role execution, and the main tasks section of your plays).\nC(refresh_inventory) (added in Ansible 2.0) forces the reload of the inventory, which in the case of dynamic inventory scripts means they will be re-executed. If the dynamic inventory script is using a cache, Ansible cannot know this and has no way of refreshing it (you can disable the cache or, if available for your specific inventory datasource (e.g. aws), you can use the an inventory plugin instead of an inventory script). This is mainly useful when additional hosts are created and users wish to use them instead of using the M(ansible.builtin.add_host) module.\nC(noop) (added in Ansible 2.0) This literally does 'nothing'. It is mainly used internally and not recommended for general use.\nC(clear_facts) (added in Ansible 2.1) causes the gathered facts for the hosts specified in the play's list of hosts to be cleared, including the fact cache.\nC(clear_host_errors) (added in Ansible 2.1) clears the failed state (if any) from hosts specified in the play's list of hosts.\nC(end_play) (added in Ansible 2.2) causes the play to end without failing the host(s). Note that this affects all hosts.\nC(reset_connection) (added in Ansible 2.3) interrupts a persistent connection (i.e. ssh + control persist)\nC(end_host) (added in Ansible 2.8) is a per-host variation of C(end_play). Causes the play to end for the current host without failing it.\nC(end_batch) (added in Ansible 2.12) causes the current batch (see C(serial)) to end without failing the host(s). Note that with C(serial=0) or undefined this behaves the same as C(end_play).",
          "required": true,
          "choices": [
            "clear_facts",
            "clear_host_errors",
            "end_host",
            "end_play",
            "flush_handlers",
            "noop",
            "refresh_inventory",
            "reset_connection",
            "end_batch"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Execute Ansible 'actions'",
      "version_added": "1.2"
    },
    "examples": "\n# Example showing flushing handlers on demand, not at end of play\n- template:\n    src: new.j2\n    dest: /etc/config.txt\n  notify: myhandler\n\n- name: Force all notified handlers to run at this point, not waiting for normal sync points\n  meta: flush_handlers\n\n# Example showing how to refresh inventory during play\n- name: Reload inventory, useful with dynamic inventories when play makes changes to the existing hosts\n  cloud_guest:            # this is fake module\n    name: newhost\n    state: present\n\n- name: Refresh inventory to ensure new instances exist in inventory\n  meta: refresh_inventory\n\n# Example showing how to clear all existing facts of targetted hosts\n- name: Clear gathered facts from all currently targeted hosts\n  meta: clear_facts\n\n# Example showing how to continue using a failed target\n- name: Bring host back to play after failure\n  copy:\n    src: file\n    dest: /etc/file\n  remote_user: imightnothavepermission\n\n- meta: clear_host_errors\n\n# Example showing how to reset an existing connection\n- user:\n    name: '{{ ansible_user }}'\n    groups: input\n\n- name: Reset ssh connection to allow user changes to affect 'current login user'\n  meta: reset_connection\n\n# Example showing how to end the play for specific targets\n- name: End the play for hosts that run CentOS 6\n  meta: end_host\n  when:\n  - ansible_distribution == 'CentOS'\n  - ansible_distribution_major_version == '6'\n"
  },
  "package": {
    "doc": {
      "description": "This modules manages packages on a target without specifying a package manager module (like M(ansible.builtin.yum), M(ansible.builtin.apt), ...). It is convenient to use in an heterogeneous environment of machines without having to create a specific task for each package manager. C(package) calls behind the module for the package manager used by the operating system discovered by the module M(ansible.builtin.setup).  If C(setup) was not yet run, C(package) will run it.\nThis module acts as a proxy to the underlying package manager module. While all arguments will be passed to the underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection of module arguments that all packaging modules support.\nFor Windows targets, use the M(ansible.windows.win_package) module instead.",
      "has_action": true,
      "notes": "While C(package) abstracts package managers to ease dealing with multiple distributions, package name often differs for the same software.",
      "options": {
        "name": {
          "aliases": [],
          "description": "Package name, or package specifier with version.\nSyntax varies with package manager. For example C(name-1.0) or C(name=1.0).\nPackage names also vary with package manager; this module will not \"translate\" them per distro. For example C(libyaml-dev), C(libyaml-devel).",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nYou can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed.",
          "required": true,
          "suboptions": {}
        },
        "use": {
          "aliases": [],
          "description": "The required package manager module to use (C(yum), C(apt), and so on). The default 'auto' will use existing facts or try to autodetect it.\nYou should only use this field if the automatic selection is not working for some reason.",
          "default": "auto",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "Whatever is required for the package plugins specific for each system."
      ],
      "short_description": "Generic OS package manager",
      "version_added": "2.0"
    },
    "examples": "\n- name: Install ntpdate\n  ansible.builtin.package:\n    name: ntpdate\n    state: present\n\n# This uses a variable as this changes per distribution.\n- name: Remove the apache package\n  ansible.builtin.package:\n    name: \"{{ apache }}\"\n    state: absent\n\n- name: Install the latest version of Apache and MariaDB\n  ansible.builtin.package:\n    name:\n      - httpd\n      - mariadb-server\n    state: latest\n"
  },
  "package_facts": {
    "doc": {
      "description": "Return information about installed packages as facts.",
      "has_action": false,
      "options": {
        "manager": {
          "aliases": [],
          "description": "The package manager used by the system so we can query the package information.\nSince 2.8 this is a list and can support multiple package managers per system.\nThe 'portage' and 'pkg' options were added in version 2.8.\nThe 'apk' option was added in version 2.11.",
          "default": "['auto']",
          "type": "list",
          "required": false,
          "choices": [
            "auto",
            "rpm",
            "apt",
            "portage",
            "pkg",
            "pacman",
            "apk"
          ],
          "elements": "str",
          "suboptions": {}
        },
        "strategy": {
          "aliases": [],
          "description": "This option controls how the module queries the package managers on the system. C(first) means it will return only information for the first supported package manager available. C(all) will return information for all supported and available package managers on the system.",
          "default": "first",
          "type": "str",
          "required": false,
          "choices": [
            "first",
            "all"
          ],
          "version_added": "2.8",
          "suboptions": {}
        }
      },
      "requirements": [
        "For 'portage' support it requires the C(qlist) utility, which is part of 'app-portage/portage-utils'.",
        "For Debian-based systems C(python-apt) package must be installed on targeted hosts."
      ],
      "short_description": "Package information as facts",
      "version_added": "2.5"
    },
    "examples": "\n- name: Gather the package facts\n  ansible.builtin.package_facts:\n    manager: auto\n\n- name: Print the package facts\n  ansible.builtin.debug:\n    var: ansible_facts.packages\n\n- name: Check whether a package called foobar is installed\n  ansible.builtin.debug:\n    msg: \"{{ ansible_facts.packages['foobar'] | length }} versions of foobar are installed!\"\n  when: \"'foobar' in ansible_facts.packages\"\n\n"
  },
  "pause": {
    "doc": {
      "description": "Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.\nTo pause/wait/sleep per host, use the M(ansible.builtin.wait_for) module.\nYou can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early press C(ctrl+c) and then C(c). To abort a playbook press C(ctrl+c) and then C(a).\nThe pause module integrates into async/parallelized playbooks without any special considerations (see Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "Starting in 2.2,  if you specify 0 or negative for minutes or seconds, it will wait for 1 second, previously it would wait indefinitely.\nUser input is not captured or echoed, regardless of echo setting, when minutes or seconds is specified.",
      "options": {
        "echo": {
          "aliases": [],
          "description": "Controls whether or not keyboard input is shown when typing.\nHas no effect if 'seconds' or 'minutes' is set.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "minutes": {
          "aliases": [],
          "description": "A positive number of minutes to pause for.",
          "required": false,
          "suboptions": {}
        },
        "prompt": {
          "aliases": [],
          "description": "Optional text to use for the prompt message.",
          "required": false,
          "suboptions": {}
        },
        "seconds": {
          "aliases": [],
          "description": "A positive number of seconds to pause for.",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Pause playbook execution",
      "version_added": "0.8"
    },
    "examples": "\n- name: Pause for 5 minutes to build app cache\n  pause:\n    minutes: 5\n\n- name: Pause until you can verify updates to an application were successful\n  pause:\n\n- name: A helpful reminder of what to look out for post-update\n  pause:\n    prompt: \"Make sure org.foo.FooOverload exception is not present\"\n\n- name: Pause to get some sensitive input\n  pause:\n    prompt: \"Enter a secret\"\n    echo: no\n"
  },
  "ping": {
    "doc": {
      "description": "A trivial test module, this module always returns C(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable Python is configured.\nThis is NOT ICMP ping, this is just a trivial test module that requires Python on the remote-node.\nFor Windows targets, use the M(ansible.windows.win_ping) module instead.\nFor Network targets, use the M(ansible.netcommon.net_ping) module instead.",
      "has_action": false,
      "options": {
        "data": {
          "aliases": [],
          "description": "Data to return for the C(ping) return value.\nIf this parameter is set to C(crash), the module will cause an exception.",
          "default": "pong",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Try to connect to host, verify a usable python and return C(pong) on success",
      "version_added": "historical"
    },
    "examples": "\n# Test we can logon to 'webservers' and execute python with json lib.\n# ansible webservers -m ping\n\n- name: Example from an Ansible Playbook\n  ansible.builtin.ping:\n\n- name: Induce an exception to see what happens\n  ansible.builtin.ping:\n    data: crash\n"
  },
  "pip": {
    "doc": {
      "description": "Manage Python library dependencies. To use this module, one of the following keys is required: C(name) or C(requirements).",
      "has_action": false,
      "notes": "The virtualenv (U(http://www.virtualenv.org/)) must be installed on the remote host if the virtualenv parameter is specified and the virtualenv needs to be created.\nAlthough it executes using the Ansible Python interpreter, the pip module shells out to run the actual pip command, so it can use any pip version you specify with I(executable). By default, it uses the pip version for the Ansible Python interpreter. For example, pip3 on python 3, and pip2 or pip on python 2.\nThe interpreter used by Ansible (see R(ansible_python_interpreter, ansible_python_interpreter)) requires the setuptools package, regardless of the version of pip set with the I(executable) option.",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "cd into this directory before running the command",
          "type": "path",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "editable": {
          "aliases": [],
          "description": "Pass the editable flag.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "The explicit executable or pathname for the pip executable, if different from the Ansible Python interpreter. For example C(pip3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation.\nMutually exclusive with I(virtualenv) (added in 2.1).\nDoes not affect the Ansible Python interpreter.\nThe setuptools package must be installed for both the Ansible Python interpreter and for the version of Python specified by this option.",
          "type": "path",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "extra_args": {
          "aliases": [],
          "description": "Extra arguments passed to pip.",
          "type": "str",
          "required": false,
          "version_added": "1.0",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.\nThis can be a list (since 2.2) and contain version specifiers (since 2.7).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "requirements": {
          "aliases": [],
          "description": "The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The state of module\nThe 'forcereinstall' option is only available in Ansible 2.1 and above.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "forcereinstall",
            "latest",
            "present"
          ],
          "suboptions": {}
        },
        "umask": {
          "aliases": [],
          "description": "The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., \"0077\") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., \"0022\").",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "version": {
          "aliases": [],
          "description": "The version number to install of the Python library specified in the I(name) parameter.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "virtualenv": {
          "aliases": [],
          "description": "An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "virtualenv_command": {
          "aliases": [],
          "description": "The command or a pathname to the command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2), C(~/bin/virtualenv), C(/usr/local/bin/virtualenv).",
          "default": "virtualenv",
          "type": "path",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "virtualenv_python": {
          "aliases": [],
          "description": "The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.",
          "type": "str",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "virtualenv_site_packages": {
          "aliases": [],
          "description": "Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.0",
          "suboptions": {}
        }
      },
      "requirements": [
        "pip",
        "virtualenv",
        "setuptools"
      ],
      "short_description": "Manages Python library dependencies",
      "version_added": "0.7"
    },
    "examples": "\n- name: Install bottle python package\n  pip:\n    name: bottle\n\n- name: Install bottle python package on version 0.11\n  pip:\n    name: bottle==0.11\n\n- name: Install bottle python package with version specifiers\n  pip:\n    name: bottle>0.10,<0.20,!=0.11\n\n- name: Install multi python packages with version specifiers\n  pip:\n    name:\n      - django>1.11.0,<1.12.0\n      - bottle>0.10,<0.20,!=0.11\n\n- name: Install python package using a proxy\n  # Pip doesn't use the standard environment variables, please use the CAPITALIZED ones below\n  pip:\n    name: six\n  environment:\n    HTTP_PROXY: '127.0.0.1:8080'\n    HTTPS_PROXY: '127.0.0.1:8080'\n\n# You do not have to supply '-e' option in extra_args\n- name: Install MyApp using one of the remote protocols (bzr+,hg+,git+,svn+)\n  pip:\n    name: svn+http://myrepo/svn/MyApp#egg=MyApp\n\n- name: Install MyApp using one of the remote protocols (bzr+,hg+,git+)\n  pip:\n    name: git+http://myrepo/app/MyApp\n\n- name: Install MyApp from local tarball\n  pip:\n    name: file:///path/to/MyApp.tar.gz\n\n- name: Install bottle into the specified (virtualenv), inheriting none of the globally installed modules\n  pip:\n    name: bottle\n    virtualenv: /my_app/venv\n\n- name: Install bottle into the specified (virtualenv), inheriting globally installed modules\n  pip:\n    name: bottle\n    virtualenv: /my_app/venv\n    virtualenv_site_packages: yes\n\n- name: Install bottle into the specified (virtualenv), using Python 2.7\n  pip:\n    name: bottle\n    virtualenv: /my_app/venv\n    virtualenv_command: virtualenv-2.7\n\n- name: Install bottle within a user home directory\n  pip:\n    name: bottle\n    extra_args: --user\n\n- name: Install specified python requirements\n  pip:\n    requirements: /my_app/requirements.txt\n\n- name: Install specified python requirements in indicated (virtualenv)\n  pip:\n    requirements: /my_app/requirements.txt\n    virtualenv: /my_app/venv\n\n- name: Install specified python requirements and custom Index URL\n  pip:\n    requirements: /my_app/requirements.txt\n    extra_args: -i https://example.com/pypi/simple\n\n- name: Install specified python requirements offline from a local directory with downloaded packages\n  pip:\n    requirements: /my_app/requirements.txt\n    extra_args: \"--no-index --find-links=file:///my_downloaded_packages_dir\"\n\n- name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable\n  pip:\n    name: bottle\n    executable: pip3.3\n\n- name: Install bottle, forcing reinstallation if it's already installed\n  pip:\n    name: bottle\n    state: forcereinstall\n\n- name: Install bottle while ensuring the umask is 0022 (to ensure other users can use it)\n  pip:\n    name: bottle\n    umask: \"0022\"\n  become: True\n"
  },
  "raw": {
    "doc": {
      "description": "Executes a low-down and dirty SSH command, not going through the module subsystem.\nThis is useful and should only be done in a few cases. A common case is installing C(python) on a system without python installed by default. Another is speaking to any devices such as routers that do not have any Python installed. In any other case, using the M(ansible.builtin.shell) or M(ansible.builtin.command) module is much more appropriate.\nArguments given to C(raw) are run directly through the configured remote shell.\nStandard output, error output and return code are returned when available.\nThere is no change handler support for this module.\nThis module does not require python on the remote system, much like the M(ansible.builtin.script) module.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "If using raw from a playbook, you may need to disable fact gathering using C(gather_facts: no) if you're using C(raw) to bootstrap python onto the machine.\nIf you want to execute a command securely and predictably, it may be better to use the M(ansible.builtin.command) or M(ansible.builtin.shell) modules instead.\nThe C(environment) keyword does not work with raw normally, it requires a shell which means it only works if C(executable) is set or using the module with privilege escalation (C(become)).",
      "options": {
        "executable": {
          "aliases": [],
          "description": "Change the shell used to execute the command. Should be an absolute path to the executable.\nWhen using privilege escalation (C(become)) a default shell will be assigned if one is not provided as privilege escalation requires a shell.",
          "required": false,
          "version_added": "1.0",
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "The raw module takes a free form command to run.\nThere is no parameter actually named 'free form'; see the examples!",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Executes a low-down and dirty command",
      "version_added": "historical"
    },
    "examples": "\n- name: Bootstrap a host without python2 installed\n  raw: dnf install -y python2 python2-dnf libselinux-python\n\n- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)\n  raw: cat < /tmp/*txt\n  args:\n    executable: /bin/bash\n\n- name: Safely use templated variables. Always use quote filter to avoid injection issues.\n  raw: \"{{ package_mgr|quote }} {{ pkg_flags|quote }} install {{ python|quote }}\"\n\n- name: List user accounts on a Windows system\n  raw: Get-WmiObject -Class Win32_UserAccount\n"
  },
  "reboot": {
    "doc": {
      "description": "Reboot a machine, wait for it to go down, come back up, and respond to commands.\nFor Windows targets, use the M(ansible.windows.win_reboot) module instead.",
      "has_action": true,
      "notes": "C(PATH) is ignored on the remote node when searching for the C(shutdown) command. Use C(search_paths) to specify locations to search if the default paths do not work.",
      "options": {
        "boot_time_command": {
          "aliases": [],
          "description": "Command to run that returns a unique string indicating the last time the system was booted.\nSetting this to a command that has different output each time it is run will cause the task to fail.",
          "default": "cat /proc/sys/kernel/random/boot_id",
          "type": "str",
          "required": false,
          "version_added": "2.10",
          "suboptions": {}
        },
        "connect_timeout": {
          "aliases": [],
          "description": "Maximum seconds to wait for a successful connection to the managed hosts before trying again.\nIf unspecified, the default setting for the underlying connection plugin is used.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "msg": {
          "aliases": [],
          "description": "Message to display to users before reboot.",
          "default": "Reboot initiated by Ansible",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "post_reboot_delay": {
          "aliases": [],
          "description": "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.\nThis is useful if you want wait for something to settle despite your connection already working.",
          "default": "0",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "pre_reboot_delay": {
          "aliases": [],
          "description": "Seconds to wait before reboot. Passed as a parameter to the reboot command.\nOn Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.\nOn Solaris and FreeBSD, this will be seconds.",
          "default": "0",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "reboot_command": {
          "aliases": [],
          "description": "Command to run that reboots the system, including any parameters passed to the command.\nCan be an absolute path to the command or just the command name. If an absolute path to the command is not given, C(search_paths) on the target system will be searched to find the absolute path.\nThis will cause C(pre_reboot_delay), C(post_reboot_delay), and C(msg) to be ignored.",
          "default": "[determined based on target OS]",
          "type": "str",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "reboot_timeout": {
          "aliases": [],
          "description": "Maximum seconds to wait for machine to reboot and respond to a test command.\nThis timeout is evaluated separately for both reboot verification and test command success so the maximum execution time for the module is twice this amount.",
          "default": "600",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "search_paths": {
          "aliases": [],
          "description": "Paths to search on the remote machine for the C(shutdown) command.\nI(Only) these paths will be searched for the C(shutdown) command. C(PATH) is ignored in the remote node when searching for the C(shutdown) command.",
          "default": "['/sbin', '/bin', '/usr/sbin', '/usr/bin', '/usr/local/sbin']",
          "type": "list",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "test_command": {
          "aliases": [],
          "description": "Command to run on the rebooted host and expect success from to determine the machine is ready for further tasks.",
          "default": "whoami",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Reboot a machine",
      "version_added": "2.7"
    },
    "examples": "\n- name: Unconditionally reboot the machine with all defaults\n  reboot:\n\n- name: Reboot a slow machine that might have lots of updates to apply\n  reboot:\n    reboot_timeout: 3600\n\n- name: Reboot a machine with shutdown command in unusual place\n  reboot:\n    search_paths:\n     - '/lib/molly-guard'\n\n- name: Reboot machine using a custom reboot command\n  reboot:\n    reboot_command: launchctl reboot userspace\n    boot_time_command: uptime | cut -d ' ' -f 5\n\n"
  },
  "replace": {
    "doc": {
      "description": "This module will replace all instances of a pattern within a file.\nIt is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made.",
      "has_action": false,
      "notes": "As of Ansible 2.3, the I(dest) option has been changed to I(path) as default, but I(dest) still works as well.\nAs of Ansible 2.7.10, the combined use of I(before) and I(after) works properly. If you were relying on the previous incorrect behavior, you may be need to adjust your tasks. See U(https://github.com/ansible/ansible/issues/31354) for details.\nOption I(follow) has been removed in Ansible 2.5, because this module modifies the contents of the file so I(follow=no) doesn't make sense.",
      "options": {
        "after": {
          "aliases": [],
          "description": "If specified, only content after this match will be replaced/removed.\nCan be used in combination with C(before).\nUses Python regular expressions; see U(https://docs.python.org/3/library/re.html).\nUses DOTALL, which means the C(.) special character I(can match newlines).",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "before": {
          "aliases": [],
          "description": "If specified, only content before this match will be replaced/removed.\nCan be used in combination with C(after).\nUses Python regular expressions; see U(https://docs.python.org/3/library/re.html).\nUses DOTALL, which means the C(.) special character I(can match newlines).",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "encoding": {
          "aliases": [],
          "description": "The character encoding for reading and writing the file.",
          "default": "utf-8",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "others": {
          "aliases": [],
          "description": "All arguments accepted by the M(ansible.builtin.file) module also work here.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "destfile",
            "name"
          ],
          "description": "The file to modify.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name).",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "regexp": {
          "aliases": [],
          "description": "The regular expression to look for in the contents of the file.\nUses Python regular expressions; see U(https://docs.python.org/3/library/re.html).\nUses MULTILINE mode, which means C(^) and C($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.\nDoes not use DOTALL, which means the C(.) special character matches any character I(except newlines). A common mistake is to assume that a negated character set like C([^#]) will also not match newlines.\nIn order to exclude newlines, they must be added to the set like C([^#\\n]).\nNote that, as of Ansible 2.0, short form tasks should have any escape sequences backslash-escaped in order to prevent them being parsed as string literal escapes. See the examples.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "replace": {
          "aliases": [],
          "description": "The string to replace regexp matches.\nMay contain backreferences that will get expanded with the regexp capture groups if the regexp matches.\nIf not set, matches are removed entirely.\nBackreferences can be used ambiguously like C(\\1), or explicitly like C(\\g<1>).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying the updated file into the final destination.\nA temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.\nAlso, the command is passed securely so shell features such as expansion and pipes will not work.\nFor an example on how to handle more complex validation than what this option provides, see L(Complex configuration validation,https://docs.ansible.com/ansible/devel/reference_appendices/faq.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Replace all instances of a particular string in a file using a back-referenced regular expression",
      "version_added": "1.6"
    },
    "examples": "\n- name: Before Ansible 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'\n  ansible.builtin.replace:\n    path: /etc/hosts\n    regexp: '(\\s+)old\\.host\\.name(\\s+.*)?$'\n    replace: '\\1new.host.name\\2'\n\n- name: Replace after the expression till the end of the file (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/apache2/sites-available/default.conf\n    after: 'NameVirtualHost [*]'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n- name: Replace before the expression till the begin of the file (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/apache2/sites-available/default.conf\n    before: '# live site config'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n# Prior to Ansible 2.7.10, using before and after in combination did the opposite of what was intended.\n# see https://github.com/ansible/ansible/issues/31354 for details.\n- name: Replace between the expressions (requires Ansible >= 2.4)\n  ansible.builtin.replace:\n    path: /etc/hosts\n    after: '<VirtualHost [*]>'\n    before: '</VirtualHost>'\n    regexp: '^(.+)$'\n    replace: '# \\1'\n\n- name: Supports common file attributes\n  ansible.builtin.replace:\n    path: /home/jdoe/.ssh/known_hosts\n    regexp: '^old\\.host\\.name[^\\n]*\\n'\n    owner: jdoe\n    group: jdoe\n    mode: '0644'\n\n- name: Supports a validate command\n  ansible.builtin.replace:\n    path: /etc/apache/ports\n    regexp: '^(NameVirtualHost|Listen)\\s+80\\s*$'\n    replace: '\\1 127.0.0.1:8080'\n    validate: '/usr/sbin/apache2ctl -f %s -t'\n\n- name: Short form task (in ansible 2+) necessitates backslash-escaped sequences\n  ansible.builtin.replace: path=/etc/hosts regexp='\\\\b(localhost)(\\\\d*)\\\\b' replace='\\\\1\\\\2.localdomain\\\\2 \\\\1\\\\2'\n\n- name: Long form task does not\n  ansible.builtin.replace:\n    path: /etc/hosts\n    regexp: '\\b(localhost)(\\d*)\\b'\n    replace: '\\1\\2.localdomain\\2 \\1\\2'\n\n- name: Explicitly specifying positional matched groups in replacement\n  ansible.builtin.replace:\n    path: /etc/ssh/sshd_config\n    regexp: '^(ListenAddress[ ]+)[^\\n]+$'\n    replace: '\\g<1>0.0.0.0'\n\n- name: Explicitly specifying named matched groups\n  ansible.builtin.replace:\n    path: /etc/ssh/sshd_config\n    regexp: '^(?P<dctv>ListenAddress[ ]+)(?P<host>[^\\n]+)$'\n    replace: '#\\g<dctv>\\g<host>\\n\\g<dctv>0.0.0.0'\n"
  },
  "rpm_key": {
    "doc": {
      "description": "Adds or removes (rpm --import) a gpg key to your rpm database.",
      "has_action": false,
      "options": {
        "fingerprint": {
          "aliases": [],
          "description": "The long-form fingerprint of the key being imported.\nThis will be used to verify the specified key.",
          "type": "str",
          "required": false,
          "version_added": "2.9",
          "suboptions": {}
        },
        "key": {
          "aliases": [],
          "description": "Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key already exists in the database.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "If the key will be imported or removed from the rpm db.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Adds or removes a gpg key from the rpm db",
      "version_added": "1.3"
    },
    "examples": "\n- name: Import a key from a url\n  ansible.builtin.rpm_key:\n    state: present\n    key: http://apt.sw.be/RPM-GPG-KEY.dag.txt\n\n- name: Import a key from a file\n  ansible.builtin.rpm_key:\n    state: present\n    key: /path/to/key.gpg\n\n- name: Ensure a key is not present in the db\n  ansible.builtin.rpm_key:\n    state: absent\n    key: DEADB33F\n\n- name: Verify the key, using a fingerprint, before import\n  ansible.builtin.rpm_key:\n    key: /path/to/RPM-GPG-KEY.dag.txt\n    fingerprint: EBC6 E12C 62B1 C734 026B  2122 A20E 5214 6B8D 79E6\n"
  },
  "script": {
    "doc": {
      "description": "The C(script) module takes the script name followed by a list of space-delimited arguments.\nEither a free form command or C(cmd) parameter is required, see the examples.\nThe local script at path will be transferred to the remote node and then executed.\nThe given script will be processed through the shell environment on the remote node.\nThis module does not require python on the remote system, much like the M(ansible.builtin.raw) module.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "It is usually preferable to write Ansible modules rather than pushing scripts. Convert your script to an Ansible module for bonus points!\nThe C(ssh) connection plugin will force pseudo-tty allocation via C(-tt) when scripts are executed. Pseudo-ttys do not have a stderr channel and all stderr is sent to stdout. If you depend on separated stdout and stderr result keys, please switch to a copy+command set of tasks instead of using script.\nIf the path to the local script contains spaces, it needs to be quoted.\nThis module is also supported for Windows targets.",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "Change into this directory on the remote node before running the script.",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "cmd": {
          "aliases": [],
          "description": "Path to the local script to run followed by optional arguments.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename on the remote node, when it already exists, this step will B(not) be run.",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "decrypt": {
          "aliases": [],
          "description": "This option controls the autodecryption of source files using vault.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "Name or path of a executable to invoke the script with.",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "Path to the local script file followed by optional arguments.",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename on the remote node, when it does not exist, this step will B(not) be run.",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        }
      },
      "short_description": "Runs a local script on a remote node after transferring it",
      "version_added": "0.9"
    },
    "examples": "\n- name: Run a script with arguments (free form)\n  ansible.builtin.script: /some/local/script.sh --some-argument 1234\n\n- name: Run a script with arguments (using 'cmd' parameter)\n  ansible.builtin.script:\n    cmd: /some/local/script.sh --some-argument 1234\n\n- name: Run a script only if file.txt does not exist on the remote node\n  ansible.builtin.script: /some/local/create_file.sh --some-argument 1234\n  args:\n    creates: /the/created/file.txt\n\n- name: Run a script only if file.txt exists on the remote node\n  ansible.builtin.script: /some/local/remove_file.sh --some-argument 1234\n  args:\n    removes: /the/removed/file.txt\n\n- name: Run a script using an executable in a non-system path\n  ansible.builtin.script: /some/local/script\n  args:\n    executable: /some/remote/executable\n\n- name: Run a script using an executable in a system path\n  ansible.builtin.script: /some/local/script.py\n  args:\n    executable: python3\n"
  },
  "service": {
    "doc": {
      "description": "Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.\nThis module acts as a proxy to the underlying service manager module. While all arguments will be passed to the underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection of module arguments that all service manager modules support.\nThis module is a proxy for multiple more specific service manager modules (such as M(ansible.builtin.systemd) and M(ansible.builtin.sysvinit)). This allows management of a heterogeneous environment of machines without creating a specific task for each service manager. The module to be executed is determined by the I(use) option, which defaults to the service manager discovered by M(ansible.builtin.setup).  If C(setup) was not yet run, this module may run it.\nFor Windows targets, use the M(ansible.windows.win_service) module instead.",
      "has_action": true,
      "notes": "For AIX, group subsystem names can be used.",
      "options": {
        "arguments": {
          "aliases": [
            "args"
          ],
          "description": "Additional arguments provided on the command line.\nWhile using remote hosts with systemd this setting will be ignored.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "enabled": {
          "aliases": [],
          "description": "Whether the service should start on boot.\nB(At least one of state and enabled are required.)",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the service.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "pattern": {
          "aliases": [],
          "description": "If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.\nIf the string is found, the service will be assumed to be started.\nWhile using remote hosts with systemd this setting will be ignored.",
          "type": "str",
          "required": false,
          "version_added": "0.7",
          "suboptions": {}
        },
        "runlevel": {
          "aliases": [],
          "description": "For OpenRC init scripts (e.g. Gentoo) only.\nThe runlevel that this service belongs to.\nWhile using remote hosts with systemd this setting will be ignored.",
          "default": "default",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sleep": {
          "aliases": [],
          "description": "If the service is being C(restarted) then sleep this many seconds between the stop and start command.\nThis helps to work around badly-behaving init scripts that exit immediately after signaling a process to stop.\nNot all service managers support sleep, i.e when using systemd this setting will be ignored.",
          "type": "int",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.\nC(restarted) will always bounce the service.\nC(reloaded) will always reload.\nB(At least one of state and enabled are required.)\nNote that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally.",
          "type": "str",
          "required": false,
          "choices": [
            "reloaded",
            "restarted",
            "started",
            "stopped"
          ],
          "suboptions": {}
        },
        "use": {
          "aliases": [],
          "description": "The service module actually uses system specific modules, normally through auto detection, this setting can force a specific module.\nNormally it uses the value of the 'ansible_service_mgr' fact and falls back to the old 'service' module when none matching is found.",
          "default": "auto",
          "type": "str",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "short_description": "Manage services",
      "version_added": "0.1"
    },
    "examples": "\n- name: Start service httpd, if not started\n  ansible.builtin.service:\n    name: httpd\n    state: started\n\n- name: Stop service httpd, if started\n  ansible.builtin.service:\n    name: httpd\n    state: stopped\n\n- name: Restart service httpd, in all cases\n  ansible.builtin.service:\n    name: httpd\n    state: restarted\n\n- name: Reload service httpd, in all cases\n  ansible.builtin.service:\n    name: httpd\n    state: reloaded\n\n- name: Enable service httpd, and not touch the state\n  ansible.builtin.service:\n    name: httpd\n    enabled: yes\n\n- name: Start service foo, based on running process /usr/bin/foo\n  ansible.builtin.service:\n    name: foo\n    pattern: /usr/bin/foo\n    state: started\n\n- name: Restart network service for interface eth0\n  ansible.builtin.service:\n    name: network\n    state: restarted\n    args: eth0\n"
  },
  "service_facts": {
    "doc": {
      "description": "Return service state information as fact data for various service management utilities.",
      "has_action": false,
      "notes": "When accessing the C(ansible_facts.services) facts collected by this module, it is recommended to not use \"dot notation\" because services can have a C(-) character in their name which would result in invalid \"dot notation\", such as C(ansible_facts.services.zuul-gateway). It is instead recommended to using the string value of the service name as the key in order to obtain the fact data value like C(ansible_facts.services['zuul-gateway'])\nAIX SRC was added in version 2.11.",
      "requirements": [
        "Any of the following supported init systems: systemd, sysv, upstart, AIX SRC"
      ],
      "short_description": "Return service state information as fact data",
      "version_added": "2.5"
    },
    "examples": "\n- name: Populate service facts\n  ansible.builtin.service_facts:\n\n- name: Print service facts\n  ansible.builtin.debug:\n    var: ansible_facts.services\n"
  },
  "set_fact": {
    "doc": {
      "description": "This action allows setting variables associated to the current host.\nThese variables will be available to subsequent plays during an ansible-playbook run via the host they were set on.\nSet C(cacheable) to C(yes) to save variables across executions using a fact cache. Variables will keep the set_fact precedence for the current run, but will used 'cached fact' precedence for subsequent ones.\nPer the standard Ansible variable precedence rules, other types of variables have a higher priority, so this value may be overridden.",
      "has_action": true,
      "notes": "Because of the nature of tasks, set_fact will produce 'static' values for a variable. Unlike normal 'lazy' variables, the value gets evaluated and templated on assignment.\nSome boolean values (yes, no, true, false) will always be converted to boolean type, unless C(DEFAULT_JINJA2_NATIVE) is enabled.  This is done so the C(var=value) booleans, otherwise it would only be able to create strings, but it also prevents using those values to create YAML strings. Using the setting will restrict k=v to strings, but will allow you to specify string or boolean in YAML.\nTo create lists/arrays or dictionary/hashes use YAML notation C(var: [val1, val2]).\nSince 'cacheable' is now a module param, 'cacheable' is no longer a valid fact name.",
      "options": {
        "cacheable": {
          "aliases": [],
          "description": "This boolean converts the variable into an actual 'fact' which will also be added to the fact cache. It does not enable fact caching across runs, it just means it will work with it if already enabled.\nNormally this module creates 'host level variables' and has much higher precedence, this option changes the nature and precedence (by 7 steps) of the variable created. U(https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)\nThis actually creates 2 copies of the variable, a normal 'set_fact' host variable with high precedence and a lower 'ansible_fact' one that is available for persistance via the facts cache plugin. This creates a possibly confusing interaction with C(meta: clear_facts) as it will remove the 'ansible_fact' but not the host variable.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "key_value": {
          "aliases": [],
          "description": "The C(set_fact) module takes C(key=value) pairs or C(key: value) (YAML notation) as variables to set in the playbook scope. The 'key' is the resulting variable name and the value is, of course, the value of said variable.\nYou can create multiple variables at once, by supplying multiple pairs, but do NOT mix notations.",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Set host variable(s) and fact(s).",
      "version_added": "1.2"
    },
    "examples": "\n- name: Setting host facts using key=value pairs, this format can only create strings or booleans\n  set_fact: one_fact=\"something\" other_fact=\"{{ local_var }}\"\n\n- name: Setting host facts using complex arguments\n  set_fact:\n    one_fact: something\n    other_fact: \"{{ local_var * 2 }}\"\n    another_fact: \"{{ some_registered_var.results | map(attribute='ansible_facts.some_fact') | list }}\"\n\n- name: Setting facts so that they will be persisted in the fact cache\n  set_fact:\n    one_fact: something\n    other_fact: \"{{ local_var * 2 }}\"\n    cacheable: yes\n\n- name: Creating list and dictionary variables\n  set_fact:\n    one_dict:\n        something: here\n        other: there\n    one_list:\n        - a\n        - b\n        - c\n\n- name: Creating list and dictionary variables using 'shorthand' YAML\n  set_fact:\n    two_dict: {'something': here2, 'other': somewhere}\n    two_list: [1,2,3]\n"
  },
  "set_stats": {
    "doc": {
      "description": "This module allows setting/accumulating stats on the current ansible run, either per host or for all hosts in the run.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "notes": "In order for custom stats to be displayed, you must set C(show_custom_stats) in section C([defaults]) in C(ansible.cfg) or by defining environment variable C(ANSIBLE_SHOW_CUSTOM_STATS) to C(yes). See the C(default) callback plugin for details.",
      "options": {
        "aggregate": {
          "aliases": [],
          "description": "Whether the provided value is aggregated to the existing stat C(yes) or will replace it C(no).",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "data": {
          "aliases": [],
          "description": "A dictionary of which each key represents a stat (or variable) you want to keep track of.",
          "type": "dict",
          "required": true,
          "suboptions": {}
        },
        "per_host": {
          "aliases": [],
          "description": "whether the stats are per host or for all hosts in the run.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Define and display stats for the current ansible run",
      "version_added": "2.3"
    },
    "examples": "\n- name: Aggregating packages_installed stat per host\n  ansible.builtin.set_stats:\n    data:\n      packages_installed: 31\n    per_host: yes\n\n- name: Aggregating random stats for all hosts using complex arguments\n  ansible.builtin.set_stats:\n    data:\n      one_stat: 11\n      other_stat: \"{{ local_var * 2 }}\"\n      another_stat: \"{{ some_registered_var.results | map(attribute='ansible_facts.some_fact') | list }}\"\n    per_host: no\n\n- name: Setting stats (not aggregating)\n  ansible.builtin.set_stats:\n    data:\n      the_answer: 42\n    aggregate: no\n"
  },
  "setup": {
    "doc": {
      "description": "This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.\nThis module is also supported for Windows targets.",
      "has_action": false,
      "notes": "More ansible facts will be added with successive releases. If I(facter) or I(ohai) are installed, variables from these programs will also be snapshotted into the JSON file for usage in templating. These variables are prefixed with C(facter_) and C(ohai_) so it's easy to tell their source. All variables are bubbled up to the caller. Using the ansible facts and choosing to not install I(facter) and I(ohai) means you can avoid Ruby-dependencies on your remote systems. (See also M(community.general.facter) and M(community.general.ohai).)\nThe filter option filters only the first level subkey below ansible_facts.\nIf the target host is Windows, you will not currently have the ability to use C(filter) as this is provided by a simpler implementation of the module.\nThis module should be run with elevated privileges on BSD systems to gather facts like ansible_product_version.\nFor more information about delegated facts, please check U(https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#delegating-facts).",
      "options": {
        "fact_path": {
          "aliases": [],
          "description": "Path used for local ansible facts (C(*.fact)) - files in this dir will be run (if executable) and their results be added to C(ansible_local) facts. If a file is not executable it is read instead. File/results format can be JSON or INI-format. The default C(fact_path) can be specified in C(ansible.cfg) for when setup is automatically called as part of C(gather_facts). NOTE - For windows clients, the results will be added to a variable named after the local file (without extension suffix), rather than C(ansible_local).\nSince Ansible 2.1, Windows hosts can use C(fact_path). Make sure that this path exists on the target host. Files in this path MUST be PowerShell scripts C(.ps1) which outputs an object. This object will be formatted by Ansible as json so the script should be outputting a raw hashtable, array, or other primitive object.",
          "default": "/etc/ansible/facts.d",
          "type": "path",
          "required": false,
          "version_added": "1.3",
          "suboptions": {}
        },
        "filter": {
          "aliases": [],
          "description": "If supplied, only return facts that match one of the shell-style (fnmatch) pattern. An empty list basically means 'no filter'. As of Ansible 2.11, the type has changed from string to list and the default has became an empty list. A simple string is still accepted and works as a single pattern. The behaviour prior to Ansible 2.11 remains.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "1.1",
          "suboptions": {}
        },
        "gather_subset": {
          "aliases": [],
          "description": "If supplied, restrict the additional facts collected to the given subset. Possible values: C(all), C(min), C(hardware), C(network), C(virtual), C(ohai), and C(facter). Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: C(!hardware,!network,!virtual,!ohai,!facter). If C(!all) is specified then only the min subset is collected. To avoid collecting even the min subset, specify C(!all,!min). To collect only specific facts, use C(!all,!min), and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts.",
          "default": "all",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.1",
          "suboptions": {}
        },
        "gather_timeout": {
          "aliases": [],
          "description": "Set the default timeout in seconds for individual fact gathering.",
          "default": "10",
          "type": "int",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "short_description": "Gathers facts about remote hosts",
      "version_added": "historical"
    },
    "examples": "\n# Display facts from all hosts and store them indexed by I(hostname) at C(/tmp/facts).\n# ansible all -m ansible.builtin.setup --tree /tmp/facts\n\n# Display only facts regarding memory found by ansible on all hosts and output them.\n# ansible all -m ansible.builtin.setup -a 'filter=ansible_*_mb'\n\n# Display only facts returned by facter.\n# ansible all -m ansible.builtin.setup -a 'filter=facter_*'\n\n# Collect only facts returned by facter.\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,!any,facter'\n\n- name: Collect only facts returned by facter\n  ansible.builtin.setup:\n    gather_subset:\n      - '!all'\n      - '!any'\n      - facter\n\n- name: Collect only selected facts\n  ansible.builtin.setup:\n    filter:\n      - 'ansible_distribution'\n      - 'ansible_machine_id'\n      - 'ansible_*_mb'\n\n# Display only facts about certain interfaces.\n# ansible all -m ansible.builtin.setup -a 'filter=ansible_eth[0-2]'\n\n# Restrict additional gathered facts to network and virtual (includes default minimum facts)\n# ansible all -m ansible.builtin.setup -a 'gather_subset=network,virtual'\n\n# Collect only network and virtual (excludes default minimum facts)\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,!any,network,virtual'\n\n# Do not call puppet facter or ohai even if present.\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!facter,!ohai'\n\n# Only collect the default minimum amount of facts:\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all'\n\n# Collect no facts, even the default minimum subset of facts:\n# ansible all -m ansible.builtin.setup -a 'gather_subset=!all,!min'\n\n# Display facts from Windows hosts with custom facts stored in C(C:\\custom_facts).\n# ansible windows -m ansible.builtin.setup -a \"fact_path='c:\\custom_facts'\"\n\n# Gathers facts for the machines in the dbservers group (a.k.a Delegating facts)\n- hosts: app_servers\n  tasks:\n    - name: Gather facts from db servers\n      ansible.builtin.setup:\n      delegate_to: \"{{ item }}\"\n      delegate_facts: true\n      loop: \"{{ groups['dbservers'] }}\"\n"
  },
  "shell": {
    "doc": {
      "description": "The C(shell) module takes the command name followed by a list of space-delimited arguments.\nEither a free form command or C(cmd) parameter is required, see the examples.\nIt is almost exactly like the M(ansible.builtin.command) module but runs the command through a shell (C(/bin/sh)) on the remote node.\nFor Windows targets, use the M(ansible.windows.win_shell) module instead.",
      "has_action": true,
      "notes": "If you want to execute a command securely and predictably, it may be better to use the M(ansible.builtin.command) module instead. Best practices when writing playbooks will follow the trend of using M(ansible.builtin.command) unless the M(ansible.builtin.shell) module is explicitly required. When running ad-hoc commands, use your best judgement.\nTo sanitize any variables passed to the shell module, you should use C({{ var | quote }}) instead of just C({{ var }}) to make sure they do not include evil things like semicolons.\nAn alternative to using inline shell scripts with this module is to use the M(ansible.builtin.script) module possibly together with the M(ansible.builtin.template) module.\nFor rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "Change into this directory before running the command.",
          "type": "path",
          "required": false,
          "version_added": "0.6",
          "suboptions": {}
        },
        "cmd": {
          "aliases": [],
          "description": "The command to run followed by optional arguments.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename, when it already exists, this step will B(not) be run.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "Change the shell used to execute the command.\nThis expects an absolute path to the executable.",
          "type": "path",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "The shell module takes a free form command to run, as a string.\nThere is no actual parameter named 'free form'.\nSee the examples on how to use this module.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename, when it does not exist, this step will B(not) be run.",
          "type": "path",
          "required": false,
          "version_added": "0.8",
          "suboptions": {}
        },
        "stdin": {
          "aliases": [],
          "description": "Set the stdin of the command directly to the specified value.",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "stdin_add_newline": {
          "aliases": [],
          "description": "Whether to append a newline to stdin data.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "warn": {
          "aliases": [],
          "description": "Whether to enable task warnings.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        }
      },
      "short_description": "Execute shell commands on targets",
      "version_added": "0.2"
    },
    "examples": "\n- name: Execute the command in remote shell; stdout goes to the specified file on the remote\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n\n- name: Change the working directory to somedir/ before executing the command\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n  args:\n    chdir: somedir/\n\n# You can also use the 'args' form to provide the options.\n- name: This command will change the working directory to somedir/ and will only run when somedir/somelog.txt doesn't exist\n  ansible.builtin.shell: somescript.sh >> somelog.txt\n  args:\n    chdir: somedir/\n    creates: somelog.txt\n\n# You can also use the 'cmd' parameter instead of free form format.\n- name: This command will change the working directory to somedir/\n  ansible.builtin.shell:\n    cmd: ls -l | grep log\n    chdir: somedir/\n\n- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)\n  ansible.builtin.shell: cat < /tmp/*txt\n  args:\n    executable: /bin/bash\n\n- name: Run a command using a templated variable (always use quote filter to avoid injection)\n  ansible.builtin.shell: cat {{ myfile|quote }}\n\n# You can use shell to run other executables to perform actions inline\n- name: Run expect to wait for a successful PXE boot via out-of-band CIMC\n  ansible.builtin.shell: |\n    set timeout 300\n    spawn ssh admin@{{ cimc_host }}\n\n    expect \"password:\"\n    send \"{{ cimc_password }}\\n\"\n\n    expect \"\\n{{ cimc_name }}\"\n    send \"connect host\\n\"\n\n    expect \"pxeboot.n12\"\n    send \"\\n\"\n\n    exit 0\n  args:\n    executable: /usr/bin/expect\n  delegate_to: localhost\n\n# Disabling warnings\n- name: Using curl to connect to a host via SOCKS proxy (unsupported in uri). Ordinarily this would throw a warning\n  ansible.builtin.shell: curl --socks5 localhost:9000 http://www.ansible.com\n  args:\n    warn: no\n"
  },
  "slurp": {
    "doc": {
      "description": "This module works like M(ansible.builtin.fetch). It is used for fetching a base64- encoded blob containing the data in a remote file.\nThis module is also supported for Windows targets.",
      "has_action": false,
      "notes": "This module returns an 'in memory' base64 encoded version of the file, take into account that this will require at least twice the RAM as the original file size.",
      "options": {
        "src": {
          "aliases": [
            "path"
          ],
          "description": "The file on the remote system to fetch. This I(must) be a file, not a directory.",
          "type": "path",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Slurps a file from remote nodes",
      "version_added": "historical"
    },
    "examples": "\n- name: Find out what the remote machine's mounts are\n  ansible.builtin.slurp:\n    src: /proc/mounts\n  register: mounts\n\n- name: Print returned information\n  ansible.builtin.debug:\n    msg: \"{{ mounts['content'] | b64decode }}\"\n\n# From the commandline, find the pid of the remote machine's sshd\n# $ ansible host -m slurp -a 'src=/var/run/sshd.pid'\n# host | SUCCESS => {\n#     \"changed\": false,\n#     \"content\": \"MjE3OQo=\",\n#     \"encoding\": \"base64\",\n#     \"source\": \"/var/run/sshd.pid\"\n# }\n# $ echo MjE3OQo= | base64 -d\n# 2179\n"
  },
  "stat": {
    "doc": {
      "description": "Retrieves facts for a file similar to the Linux/Unix 'stat' command.\nFor Windows targets, use the M(ansible.windows.win_stat) module instead.",
      "has_action": false,
      "options": {
        "checksum_algorithm": {
          "aliases": [
            "checksum",
            "checksum_algo"
          ],
          "description": "Algorithm to determine checksum of file.\nWill throw an error if the host is unable to use specified algorithm.\nThe remote host has to support the hashing method specified, C(md5) can be unavailable if the host is FIPS-140 compliant.",
          "default": "sha1",
          "type": "str",
          "required": false,
          "choices": [
            "md5",
            "sha1",
            "sha224",
            "sha256",
            "sha384",
            "sha512"
          ],
          "version_added": "2.0",
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "Whether to follow symlinks.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "get_attributes": {
          "aliases": [
            "attr",
            "attributes"
          ],
          "description": "Get file attributes using lsattr tool if present.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "get_checksum": {
          "aliases": [],
          "description": "Whether to return a checksum of the file.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.8",
          "suboptions": {}
        },
        "get_mime": {
          "aliases": [
            "mime",
            "mime_type",
            "mime-type"
          ],
          "description": "Use file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.\nThis will add both C(mime_type) and C(charset) fields to the return, if possible.\nIn Ansible 2.3 this option changed from I(mime) to I(get_mime) and the default changed to C(yes).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "name"
          ],
          "description": "The full path of the file/object to get the facts of.",
          "type": "path",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Retrieve file or file system status",
      "version_added": "1.3"
    },
    "examples": "\n# Obtain the stats of /etc/foo.conf, and check that the file still belongs\n# to 'root'. Fail otherwise.\n- name: Get stats of a file\n  ansible.builtin.stat:\n    path: /etc/foo.conf\n  register: st\n- name: Fail if the file does not belong to 'root'\n  ansible.builtin.fail:\n    msg: \"Whoops! file ownership has changed\"\n  when: st.stat.pw_name != 'root'\n\n# Determine if a path exists and is a symlink. Note that if the path does\n# not exist, and we test sym.stat.islnk, it will fail with an error. So\n# therefore, we must test whether it is defined.\n# Run this to understand the structure, the skipped ones do not pass the\n# check performed by 'when'\n- name: Get stats of the FS object\n  ansible.builtin.stat:\n    path: /path/to/something\n  register: sym\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"islnk isn't defined (path doesn't exist)\"\n  when: sym.stat.islnk is not defined\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"islnk is defined (path must exist)\"\n  when: sym.stat.islnk is defined\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and is a symlink\"\n  when: sym.stat.islnk is defined and sym.stat.islnk\n\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and isn't a symlink\"\n  when: sym.stat.islnk is defined and sym.stat.islnk == False\n\n\n# Determine if a path exists and is a directory.  Note that we need to test\n# both that p.stat.isdir actually exists, and also that it's set to true.\n- name: Get stats of the FS object\n  ansible.builtin.stat:\n    path: /path/to/something\n  register: p\n- name: Print a debug message\n  ansible.builtin.debug:\n    msg: \"Path exists and is a directory\"\n  when: p.stat.isdir is defined and p.stat.isdir\n\n- name: Don not do checksum\n  ansible.builtin.stat:\n    path: /path/to/myhugefile\n    get_checksum: no\n\n- name: Use sha256 to calculate checksum\n  ansible.builtin.stat:\n    path: /path/to/something\n    checksum_algorithm: sha256\n"
  },
  "subversion": {
    "doc": {
      "description": "Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout.",
      "has_action": false,
      "notes": "This module does not handle externals.",
      "options": {
        "checkout": {
          "aliases": [],
          "description": "If C(no), do not check out the repository if it does not exist locally.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Absolute path where the repository should be deployed.\nThe destination directory must be specified unless I(checkout=no), I(update=no), and I(export=no).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
          "type": "path",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "export": {
          "aliases": [],
          "description": "If C(yes), do export instead of checkout/update.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "If C(yes), modified files will be discarded. If C(no), module will fail if it encounters modified files. Prior to 1.9 the default was C(yes).",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "in_place": {
          "aliases": [],
          "description": "If the directory exists, then the working copy will be checked-out over-the-top using svn checkout --force; if force is specified then existing files with different content are reverted.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "C(--password) parameter passed to svn when svn is less than version 1.10.0. This is not secure and the password will be leaked to argv.\nC(--password-from-stdin) parameter when svn is greater or equal to version 1.10.0.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "repo": {
          "aliases": [
            "name",
            "repository"
          ],
          "description": "The subversion URL to the repository.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "revision": {
          "aliases": [
            "rev",
            "version"
          ],
          "description": "Specific revision to checkout.",
          "default": "HEAD",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "switch": {
          "aliases": [],
          "description": "If C(no), do not call svn switch before update.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "update": {
          "aliases": [],
          "description": "If C(no), do not retrieve new revisions from the origin repository.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "username": {
          "aliases": [],
          "description": "C(--username) parameter passed to svn.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), passes the C(--trust-server-cert) flag to svn.\nIf C(yes), does not pass the flag.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        }
      },
      "requirements": [
        "subversion (the command line tool with C(svn) entrypoint)"
      ],
      "short_description": "Deploys a subversion repository",
      "version_added": "0.7"
    },
    "examples": "\n- name: Checkout subversion repository to specified folder\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/checkout\n\n- name: Export subversion directory to folder\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/export\n    export: yes\n\n- name: Get information about the repository whether or not it has already been cloned locally\n  ansible.builtin.subversion:\n    repo: svn+ssh://an.example.org/path/to/repo\n    dest: /src/checkout\n    checkout: no\n    update: no\n"
  },
  "systemd": {
    "doc": {
      "description": "Controls systemd units (services, timers, and so on) on remote hosts.",
      "has_action": false,
      "notes": "Since 2.4, one of the following options is required C(state), C(enabled), C(masked), C(daemon_reload), (C(daemon_reexec) since 2.8), and all except C(daemon_reload) and (C(daemon_reexec) since 2.8) also require C(name).\nBefore 2.4 you always required C(name).\nGlobs are not supported in name, i.e C(postgres*.service).\nThe service names might vary by specific OS/distribution",
      "options": {
        "daemon_reexec": {
          "aliases": [
            "daemon-reexec"
          ],
          "description": "Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "daemon_reload": {
          "aliases": [
            "daemon-reload"
          ],
          "description": "Run daemon-reload before doing any other operations, to make sure systemd has read any changes.\nWhen set to C(true), runs daemon-reload even if the module does not start or stop anything.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "enabled": {
          "aliases": [],
          "description": "Whether the unit should start on boot. B(At least one of state and enabled are required.)",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Whether to override existing symlinks.",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "masked": {
          "aliases": [],
          "description": "Whether the unit should be masked or not, a masked unit is impossible to start.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "service",
            "unit"
          ],
          "description": "Name of the unit. This parameter takes the name of exactly one unit to work with.\nWhen no extension is given, it is implied to a C(.service) as systemd.\nWhen using in a chroot environment you always need to specify the name of the unit with the extension. For example, C(crond.service).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "no_block": {
          "aliases": [],
          "description": "Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "scope": {
          "aliases": [],
          "description": "Run systemctl within a given service manager scope, either as the default system scope C(system), the current user's scope C(user), or the scope of all users C(global).\nFor systemd to work with 'user', the executing user must have its own instance of dbus started and accessible (systemd requirement).\nThe user dbus process is normally started during normal login, but not during the run of Ansible tasks. Otherwise you will probably get a 'Failed to connect to bus: no such file or directory' error.\nThe user must have access, normally given via setting the C(XDG_RUNTIME_DIR) variable, see example below.",
          "default": "system",
          "type": "str",
          "required": false,
          "choices": [
            "system",
            "user",
            "global"
          ],
          "version_added": "2.7",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the unit. C(reloaded) will always reload.",
          "type": "str",
          "required": false,
          "choices": [
            "reloaded",
            "restarted",
            "started",
            "stopped"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "A system managed by systemd."
      ],
      "short_description": "Manage systemd units",
      "version_added": "2.2"
    },
    "examples": "\n- name: Make sure a service unit is running\n  ansible.builtin.systemd:\n    state: started\n    name: httpd\n\n- name: Stop service cron on debian, if running\n  ansible.builtin.systemd:\n    name: cron\n    state: stopped\n\n- name: Restart service cron on centos, in all cases, also issue daemon-reload to pick up config changes\n  ansible.builtin.systemd:\n    state: restarted\n    daemon_reload: yes\n    name: crond\n\n- name: Reload service httpd, in all cases\n  ansible.builtin.systemd:\n    name: httpd.service\n    state: reloaded\n\n- name: Enable service httpd and ensure it is not masked\n  ansible.builtin.systemd:\n    name: httpd\n    enabled: yes\n    masked: no\n\n- name: Enable a timer unit for dnf-automatic\n  ansible.builtin.systemd:\n    name: dnf-automatic.timer\n    state: started\n    enabled: yes\n\n- name: Just force systemd to reread configs (2.4 and above)\n  ansible.builtin.systemd:\n    daemon_reload: yes\n\n- name: Just force systemd to re-execute itself (2.8 and above)\n  ansible.builtin.systemd:\n    daemon_reexec: yes\n\n- name: Run a user service when XDG_RUNTIME_DIR is not set on remote login\n  ansible.builtin.systemd:\n    name: myservice\n    state: started\n    scope: user\n  environment:\n    XDG_RUNTIME_DIR: \"/run/user/{{ myuid }}\"\n"
  },
  "sysvinit": {
    "doc": {
      "description": "Controls services on target hosts that use the SysV init system.",
      "has_action": false,
      "notes": "One option other than name is required.\nThe service names might vary by specific OS/distribution",
      "options": {
        "arguments": {
          "aliases": [
            "args"
          ],
          "description": "Additional arguments provided on the command line that some init scripts accept.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "daemonize": {
          "aliases": [],
          "description": "Have the module daemonize as the service itself might not do so properly.\nThis is useful with badly written init scripts or daemons, which commonly manifests as the task hanging as it is still holding the tty or the service dying when the task is over as the connection closes the session.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "enabled": {
          "aliases": [],
          "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "service"
          ],
          "description": "Name of the service.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "pattern": {
          "aliases": [],
          "description": "A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.\nIf the string is found, the service will be assumed to be running.\nThis option is mainly for use with init scripts that don't support the 'status' option.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "runlevels": {
          "aliases": [],
          "description": "The runlevels this script should be enabled/disabled from.\nUse this to override the defaults set by the package or init script itself.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "sleep": {
          "aliases": [],
          "description": "If the service is being C(restarted) or C(reloaded) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving services.",
          "default": "1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. Not all init scripts support C(restarted) nor C(reloaded) natively, so these will both trigger a stop and start as needed.",
          "type": "str",
          "required": false,
          "choices": [
            "started",
            "stopped",
            "restarted",
            "reloaded"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "That the service managed has a corresponding init script."
      ],
      "short_description": "Manage SysV services.",
      "version_added": "2.6"
    },
    "examples": "\n- name: Make sure apache2 is started\n  sysvinit:\n      name: apache2\n      state: started\n      enabled: yes\n\n- name: Make sure apache2 is started on runlevels 3 and 5\n  sysvinit:\n      name: apache2\n      state: started\n      enabled: yes\n      runlevels:\n        - 3\n        - 5\n"
  },
  "tempfile": {
    "doc": {
      "description": "The C(tempfile) module creates temporary files and directories. C(mktemp) command takes different parameters on various systems, this module helps to avoid troubles related to that. Files/directories created by module are accessible only by creator. In case you need to make them world-accessible you need to use M(ansible.builtin.file) module.\nFor Windows targets, use the M(ansible.windows.win_tempfile) module instead.",
      "has_action": false,
      "options": {
        "path": {
          "aliases": [],
          "description": "Location where temporary file or directory should be created.\nIf path is not specified, the default system temporary directory will be used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "prefix": {
          "aliases": [],
          "description": "Prefix of file/directory name created by module.",
          "default": "ansible.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to create file or directory.",
          "default": "file",
          "type": "str",
          "required": false,
          "choices": [
            "directory",
            "file"
          ],
          "suboptions": {}
        },
        "suffix": {
          "aliases": [],
          "description": "Suffix of file/directory name created by module.",
          "default": "",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Creates temporary files and directories",
      "version_added": "2.3"
    },
    "examples": "\n- name: Create temporary build directory\n  ansible.builtin.tempfile:\n    state: directory\n    suffix: build\n\n- name: Create temporary file\n  ansible.builtin.tempfile:\n    state: file\n    suffix: temp\n  register: tempfile_1\n\n- name: Use the registered var and the file module to remove the temporary file\n  ansible.builtin.file:\n    path: \"{{ tempfile_1.path }}\"\n    state: absent\n  when: tempfile_1.path is defined\n"
  },
  "template": {
    "doc": {
      "description": "Templates are processed by the L(Jinja2 templating language,http://jinja.pocoo.org/docs/).\nDocumentation on the template formatting can be found in the L(Template Designer Documentation,http://jinja.pocoo.org/docs/templates/).\nAdditional variables listed below can be used in templates.\nC(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid.\nC(template_host) contains the node name of the template's machine.\nC(template_uid) is the numeric user id of the owner.\nC(template_path) is the path of the template.\nC(template_fullpath) is the absolute path of the template.\nC(template_destpath) is the path of the template on the remote system (added in 2.8).\nC(template_run_date) is the date that the template was rendered.",
      "has_action": true,
      "notes": "For Windows you can use M(ansible.windows.win_template) which uses '\\\\r\\\\n' as C(newline_sequence) by default.\nIncluding a string that uses a date in the template will result in the template being marked 'changed' each time.\nSince Ansible 0.9, templates are loaded with C(trim_blocks=True).\nAlso, you can override jinja2 settings by adding a special header to template file. i.e. C(#jinja2:variable_start_string:'[%', variable_end_string:'%]', trim_blocks: False) which changes the variable interpolation markers to C([% var %]) instead of C({{ var }}). This is the best way to prevent evaluation of things that look like, but should not be Jinja2.\n\nUsing raw/endraw in Jinja2 will not work as you expect because templates in Ansible are recursively evaluated.\nTo find Byte Order Marks in files, use C(Format-Hex <file> -Count 16) on Windows, and use C(od -a -t x1 -N 16 <file>) on Linux.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "backup": {
          "aliases": [],
          "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "block_end_string": {
          "aliases": [],
          "description": "The string marking the end of a block.",
          "default": "%}",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "block_start_string": {
          "aliases": [],
          "description": "The string marking the beginning of a block.",
          "default": "{%",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "comment_end_string": {
          "aliases": [],
          "description": "The string marking the end of a comment statement.",
          "type": "str",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "comment_start_string": {
          "aliases": [],
          "description": "The string marking the beginning of a comment statement.",
          "type": "str",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Location to render the template to on the remote machine.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "Determine whether symbolic links should be followed.\nWhen set to C(yes) symbolic links will be followed, if they exist.\nWhen set to C(no) symbolic links will not be followed.\nPrevious to Ansible 2.4, this was hardcoded as C(yes).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Determine when the file is being transferred if the destination already exists.\nWhen set to C(yes), replace the remote file when contents are different than the source.\nWhen set to C(no), the file will only be transferred if the destination does not exist.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "lstrip_blocks": {
          "aliases": [],
          "description": "Determine when leading spaces and tabs should be stripped.\nWhen set to C(yes) leading spaces and tabs are stripped from the start of a line to a block.\nThis functionality requires Jinja 2.7 or newer.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "newline_sequence": {
          "aliases": [],
          "description": "Specify the newline sequence to use for templating files.",
          "default": "\\n",
          "type": "str",
          "required": false,
          "choices": [
            "\\n",
            "\\r",
            "\\r\\n"
          ],
          "version_added": "2.4",
          "suboptions": {}
        },
        "output_encoding": {
          "aliases": [],
          "description": "Overrides the encoding used to write the template file defined by C(dest).\nIt defaults to C(utf-8), but any encoding supported by python can be used.\nThe source template file must always be encoded using C(utf-8), for homogeneity.",
          "default": "utf-8",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Path of a Jinja2 formatted template on the Ansible controller.\nThis can be a relative or an absolute path.\nThe file must be encoded with C(utf-8) but I(output_encoding) can be used to control the encoding of the output template.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "trim_blocks": {
          "aliases": [],
          "description": "Determine when newlines should be removed from blocks.\nWhen set to C(yes) the first newline after a block is removed (block, not variable tag!).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate": {
          "aliases": [],
          "description": "The validation command to run before copying the updated file into the final destination.\nA temporary file path is used to validate, passed in through '%s' which must be present as in the examples below.\nAlso, the command is passed securely so shell features such as expansion and pipes will not work.\nFor an example on how to handle more complex validation than what this option provides, see L(Complex configuration validation,https://docs.ansible.com/ansible/devel/reference_appendices/faq.html).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "variable_end_string": {
          "aliases": [],
          "description": "The string marking the end of a print statement.",
          "default": "}}",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "variable_start_string": {
          "aliases": [],
          "description": "The string marking the beginning of a print statement.",
          "default": "{{",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        }
      },
      "short_description": "Template a file out to a target host",
      "version_added": "historical"
    },
    "examples": "\n- name: Template a file to /etc/file.conf\n  ansible.builtin.template:\n    src: /mytemplates/foo.j2\n    dest: /etc/file.conf\n    owner: bin\n    group: wheel\n    mode: '0644'\n\n- name: Template a file, using symbolic modes (equivalent to 0644)\n  ansible.builtin.template:\n    src: /mytemplates/foo.j2\n    dest: /etc/file.conf\n    owner: bin\n    group: wheel\n    mode: u=rw,g=r,o=r\n\n- name: Copy a version of named.conf that is dependent on the OS. setype obtained by doing ls -Z /etc/named.conf on original file\n  ansible.builtin.template:\n    src: named.conf_{{ ansible_os_family }}.j2\n    dest: /etc/named.conf\n    group: named\n    setype: named_conf_t\n    mode: 0640\n\n- name: Create a DOS-style text file from a template\n  ansible.builtin.template:\n    src: config.ini.j2\n    dest: /share/windows/config.ini\n    newline_sequence: '\\r\\n'\n\n- name: Copy a new sudoers file into place, after passing validation with visudo\n  ansible.builtin.template:\n    src: /mine/sudoers\n    dest: /etc/sudoers\n    validate: /usr/sbin/visudo -cf %s\n\n- name: Update sshd configuration safely, avoid locking yourself out\n  ansible.builtin.template:\n    src: etc/ssh/sshd_config.j2\n    dest: /etc/ssh/sshd_config\n    owner: root\n    group: root\n    mode: '0600'\n    validate: /usr/sbin/sshd -t -f %s\n    backup: yes\n"
  },
  "unarchive": {
    "doc": {
      "description": "The C(unarchive) module unpacks an archive. It will not unpack a compressed file that does not contain an archive.\nBy default, it will copy the source file from the local system to the target before unpacking.\nSet C(remote_src=yes) to unpack an archive which already exists on the target.\nIf checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).\nFor Windows targets, use the M(community.windows.win_unzip) module instead.",
      "has_action": true,
      "notes": "Requires C(zipinfo) and C(gtar)/C(unzip) command on target host.\nRequires C(zstd) command on target host to expand I(.tar.zst) files.\nCan handle I(.zip) files using C(unzip) as well as I(.tar), I(.tar.gz), I(.tar.bz2), I(.tar.xz), and I(.tar.zst) files using C(gtar).\nDoes not handle I(.gz) files, I(.bz2) files, I(.xz), or I(.zst) files that do not contain a I(.tar) archive.\nExisting files/directories in the destination which are not in the archive are not touched. This is the same behavior as a normal archive extraction.\nExisting files/directories in the destination which are not in the archive are ignored for purposes of deciding if the archive should be unpacked or not.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "copy": {
          "aliases": [],
          "description": "If true, the file is copied from local controller to the managed (remote) node, otherwise, the plugin will look for src archive on the managed machine.\nThis option has been deprecated in favor of C(remote_src).\nThis option is mutually exclusive with C(remote_src).",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "If the specified absolute path (file or directory) already exists, this step will B(not) be run.",
          "type": "path",
          "required": false,
          "version_added": "1.6",
          "suboptions": {}
        },
        "decrypt": {
          "aliases": [],
          "description": "This option controls the autodecryption of source files using vault.",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Remote absolute path where the archive should be unpacked.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "exclude": {
          "aliases": [],
          "description": "List the directory and file entries that you would like to exclude from the unarchive action.\nMutually exclusive with C(include).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.1",
          "suboptions": {}
        },
        "extra_opts": {
          "aliases": [],
          "description": "Specify additional options by passing in an array.\nEach space-separated command-line option should be a new element of the array. See examples.\nCommand-line options with multiple elements must use multiple lines in the array, one for each element.",
          "default": "",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.1",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "include": {
          "aliases": [],
          "description": "List of directory and file entries that you would like to extract from the archive. Only files listed here will be extracted.\nMutually exclusive with C(exclude).",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.11",
          "suboptions": {}
        },
        "io_buffer_size": {
          "aliases": [],
          "description": "Size of the volatile memory buffer that is used for extracting files from the archive in bytes.",
          "default": "65536",
          "type": "int",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "keep_newer": {
          "aliases": [],
          "description": "Do not replace existing files that are newer than files from the archive.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "list_files": {
          "aliases": [],
          "description": "If set to True, return the list of files that are contained in the tarball.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "remote_src": {
          "aliases": [],
          "description": "Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.\nThis option is mutually exclusive with C(copy).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.\nIf C(remote_src=yes) and C(src) contains C(://), the remote machine will download the file from the URL first. (version_added 2.0). This is only for simple cases, for full download support use the M(ansible.builtin.get_url) module.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "This only applies if using a https URL as the source of the file.\nThis should only set to C(no) used on personally controlled sites using self-signed certificate.\nPrior to 2.2 the code worked as if this was set to C(yes).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        }
      },
      "short_description": "Unpacks an archive after (optionally) copying it from the local machine",
      "version_added": "1.4"
    },
    "examples": "\n- name: Extract foo.tgz into /var/lib/foo\n  ansible.builtin.unarchive:\n    src: foo.tgz\n    dest: /var/lib/foo\n\n- name: Unarchive a file that is already on the remote machine\n  ansible.builtin.unarchive:\n    src: /tmp/foo.zip\n    dest: /usr/local/bin\n    remote_src: yes\n\n- name: Unarchive a file that needs to be downloaded (added in 2.0)\n  ansible.builtin.unarchive:\n    src: https://example.com/example.zip\n    dest: /usr/local/bin\n    remote_src: yes\n\n- name: Unarchive a file with extra options\n  ansible.builtin.unarchive:\n    src: /tmp/foo.zip\n    dest: /usr/local/bin\n    extra_opts:\n    - --transform\n    - s/^xxx/yyy/\n"
  },
  "uri": {
    "doc": {
      "description": "Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.\nFor Windows targets, use the M(ansible.windows.win_uri) module instead.",
      "has_action": true,
      "notes": "The dependency on httplib2 was removed in Ansible 2.1.\nThe module returns all the HTTP headers in lower-case.\nFor Windows targets, use the M(ansible.windows.win_uri) module instead.",
      "options": {
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "body": {
          "aliases": [],
          "description": "The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.\nIf C(body_format) is set to 'form-urlencoded' it will convert a dictionary or list of tuples into an 'application/x-www-form-urlencoded' string. (Added in v2.7)\nIf C(body_format) is set to 'form-multipart' it will convert a dictionary into 'multipart/form-multipart' body. (Added in v2.10)",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "body_format": {
          "aliases": [],
          "description": "The serialization format of the body. When set to C(json), C(form-multipart), or C(form-urlencoded), encodes the body argument, if needed, and automatically sets the Content-Type header accordingly.\nAs of v2.3 it is possible to override the C(Content-Type) header, when set to C(json) or C(form-urlencoded) via the I(headers) option.\nThe 'Content-Type' header cannot be overridden when using C(form-multipart)\nC(form-urlencoded) was added in v2.7.\nC(form-multipart) was added in v2.10.",
          "default": "raw",
          "type": "str",
          "required": false,
          "choices": [
            "form-urlencoded",
            "json",
            "raw",
            "form-multipart"
          ],
          "version_added": "2.0",
          "suboptions": {}
        },
        "ca_path": {
          "aliases": [],
          "description": "PEM formatted file that contains a CA certificate to be used for validation",
          "type": "path",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [],
          "description": "PEM formatted certificate chain file to be used for SSL client authentication.\nThis file can also include the key as well, and if the key is included, I(client_key) is not required",
          "type": "path",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "client_key": {
          "aliases": [],
          "description": "PEM formatted file that contains your private key to be used for SSL client authentication.\nIf I(client_cert) contains both the certificate and key, this option is not required.",
          "type": "path",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename, when it already exists, this step will not be run.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "A path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "follow_redirects": {
          "aliases": [],
          "description": "Whether or not the URI module should follow redirects. C(all) will follow all redirects. C(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a GET or HEAD on the URI to which it is being redirected. C(none) will not follow any redirects. Note that C(yes) and C(no) choices are accepted for backwards compatibility, where C(yes) is the equivalent of C(all) and C(no) is the equivalent of C(safe). C(yes) and C(no) are deprecated and will be removed in some future version of Ansible.",
          "default": "safe",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "no",
            "none",
            "safe",
            "urllib2",
            "yes"
          ],
          "suboptions": {}
        },
        "force": {
          "aliases": [
            "thirsty"
          ],
          "description": "If C(yes) do not get a cached copy.\nAlias C(thirsty) has been deprecated and will be removed in 2.13.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force_basic_auth": {
          "aliases": [],
          "description": "Force the sending of the Basic authentication header upon initial request.\nThe library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) or C(form-urlencoded) for I(body_format).",
          "type": "dict",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "http_agent": {
          "aliases": [],
          "description": "Header to identify as, generally appears in web server logs.",
          "default": "ansible-httpget",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "method": {
          "aliases": [],
          "description": "The HTTP method of the request or response.\nIn more recent versions we do not restrict the method at the module level anymore but it still must be a valid method accepted by the service handling the request.",
          "default": "GET",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "remote_src": {
          "aliases": [],
          "description": "If C(no), the module will search for the C(src) on the controller node.\nIf C(yes), the module will search for the C(src) on the managed (remote) node.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename, when it does not exist, this step will not be run.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "Whether or not to return the body of the response as a \"content\" key in the dictionary result no matter it succeeded or failed.\nIndependently of this option, if the reported Content-type is \"application/json\", then the JSON is always loaded into a key called C(json) in the dictionary results.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Path to file to be submitted to the remote server.\nCannot be used with I(body).",
          "type": "path",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "status_code": {
          "aliases": [],
          "description": "A list of valid, numeric, HTTP status codes that signifies success of the request.",
          "default": "[200]",
          "type": "list",
          "required": false,
          "elements": "int",
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "The socket level timeout in seconds",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "unix_socket": {
          "aliases": [],
          "description": "Path to Unix domain socket to use for connection",
          "type": "path",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "unredirected_headers": {
          "aliases": [],
          "description": "A list of header names that will not be sent on subsequent redirected requests. This list is case insensitive. By default all headers will be redirected. In some cases it may be beneficial to list headers such as C(Authorization) here to avoid potential credential exposure.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.12",
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "url_password": {
          "aliases": [
            "password"
          ],
          "description": "A password for the module to use for Digest, Basic or WSSE authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_username": {
          "aliases": [
            "user"
          ],
          "description": "A username for the module to use for Digest, Basic or WSSE authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_gssapi": {
          "aliases": [],
          "description": "Use GSSAPI to perform the authentication, typically this is for Kerberos or Kerberos through Negotiate authentication.\nRequires the Python library L(gssapi,https://github.com/pythongssapi/python-gssapi) to be installed.\nCredentials for GSSAPI can be specified with I(url_username)/I(url_password) or with the GSSAPI env var C(KRB5CCNAME) that specified a custom Kerberos credential cache.\nNTLM authentication is C(not) supported even if the GSSAPI mech for NTLM has been installed.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "use_proxy": {
          "aliases": [],
          "description": "If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.\nPrior to 1.9.2 the code defaulted to C(no).",
          "default": "True",
          "type": "bool",
          "required": false,
          "version_added": "1.9.2",
          "suboptions": {}
        }
      },
      "short_description": "Interacts with webservices",
      "version_added": "1.1"
    },
    "examples": "\n- name: Check that you can connect (GET) to a page and it returns a status 200\n  uri:\n    url: http://www.example.com\n\n- name: Check that a page returns a status 200 and fail if the word AWESOME is not in the page contents\n  uri:\n    url: http://www.example.com\n    return_content: yes\n  register: this\n  failed_when: \"'AWESOME' not in this.content\"\n\n- name: Create a JIRA issue\n  uri:\n    url: https://your.jira.example.com/rest/api/2/issue/\n    user: your_username\n    password: your_pass\n    method: POST\n    body: \"{{ lookup('file','issue.json') }}\"\n    force_basic_auth: yes\n    status_code: 201\n    body_format: json\n\n- name: Login to a form based webpage, then use the returned cookie to access the app in later tasks\n  uri:\n    url: https://your.form.based.auth.example.com/index.php\n    method: POST\n    body_format: form-urlencoded\n    body:\n      name: your_username\n      password: your_password\n      enter: Sign in\n    status_code: 302\n  register: login\n\n- name: Login to a form based webpage using a list of tuples\n  uri:\n    url: https://your.form.based.auth.example.com/index.php\n    method: POST\n    body_format: form-urlencoded\n    body:\n    - [ name, your_username ]\n    - [ password, your_password ]\n    - [ enter, Sign in ]\n    status_code: 302\n  register: login\n\n- name: Upload a file via multipart/form-multipart\n  uri:\n    url: https://httpbin.org/post\n    method: POST\n    body_format: form-multipart\n    body:\n      file1:\n        filename: /bin/true\n        mime_type: application/octet-stream\n      file2:\n        content: text based file content\n        filename: fake.txt\n        mime_type: text/plain\n      text_form_field: value\n\n- name: Connect to website using a previously stored cookie\n  uri:\n    url: https://your.form.based.auth.example.com/dashboard.php\n    method: GET\n    return_content: yes\n    headers:\n      Cookie: \"{{ login.cookies_string }}\"\n\n- name: Queue build of a project in Jenkins\n  uri:\n    url: http://{{ jenkins.host }}/job/{{ jenkins.job }}/build?token={{ jenkins.token }}\n    user: \"{{ jenkins.user }}\"\n    password: \"{{ jenkins.password }}\"\n    method: GET\n    force_basic_auth: yes\n    status_code: 201\n\n- name: POST from contents of local file\n  uri:\n    url: https://httpbin.org/post\n    method: POST\n    src: file.json\n\n- name: POST from contents of remote file\n  uri:\n    url: https://httpbin.org/post\n    method: POST\n    src: /path/to/my/file.json\n    remote_src: yes\n\n- name: Create workspaces in Log analytics Azure\n  uri:\n    url: https://www.mms.microsoft.com/Embedded/Api/ConfigDataSources/LogManagementData/Save\n    method: POST\n    body_format: json\n    status_code: [200, 202]\n    return_content: true\n    headers:\n      Content-Type: application/json\n      x-ms-client-workspace-path: /subscriptions/{{ sub_id }}/resourcegroups/{{ res_group }}/providers/microsoft.operationalinsights/workspaces/{{ w_spaces }}\n      x-ms-client-platform: ibiza\n      x-ms-client-auth-token: \"{{ token_az }}\"\n    body:\n\n- name: Pause play until a URL is reachable from this host\n  uri:\n    url: \"http://192.0.2.1/some/test\"\n    follow_redirects: none\n    method: GET\n  register: _result\n  until: _result.status == 200\n  retries: 720 # 720 * 5 seconds = 1hour (60*60/5)\n  delay: 5 # Every 5 seconds\n\n# There are issues in a supporting Python library that is discussed in\n# https://github.com/ansible/ansible/issues/52705 where a proxy is defined\n# but you want to bypass proxy use on CIDR masks by using no_proxy\n- name: Work around a python issue that doesn't support no_proxy envvar\n  uri:\n    follow_redirects: none\n    validate_certs: false\n    timeout: 5\n    url: \"http://{{ ip_address }}:{{ port | default(80) }}\"\n  register: uri_data\n  failed_when: false\n  changed_when: false\n  vars:\n    ip_address: 192.0.2.1\n  environment: |\n      {\n        {% for no_proxy in (lookup('env', 'no_proxy') | regex_replace('\\s*,\\s*', ' ') ).split() %}\n          {% if no_proxy | regex_search('\\/') and\n                no_proxy | ipaddr('net') != '' and\n                no_proxy | ipaddr('net') != false and\n                ip_address | ipaddr(no_proxy) is not none and\n                ip_address | ipaddr(no_proxy) != false %}\n            'no_proxy': '{{ ip_address }}'\n          {% elif no_proxy | regex_search(':') != '' and\n                  no_proxy | regex_search(':') != false and\n                  no_proxy == ip_address + ':' + (port | default(80)) %}\n            'no_proxy': '{{ ip_address }}:{{ port | default(80) }}'\n          {% elif no_proxy | ipaddr('host') != '' and\n                  no_proxy | ipaddr('host') != false and\n                  no_proxy == ip_address %}\n            'no_proxy': '{{ ip_address }}'\n          {% elif no_proxy | regex_search('^(\\*|)\\.') != '' and\n                  no_proxy | regex_search('^(\\*|)\\.') != false and\n                  no_proxy | regex_replace('\\*', '') in ip_address %}\n            'no_proxy': '{{ ip_address }}'\n          {% endif %}\n        {% endfor %}\n      }\n"
  },
  "user": {
    "doc": {
      "description": "Manage user accounts and user attributes.\nFor Windows targets, use the M(ansible.windows.win_user) module instead.",
      "has_action": false,
      "notes": "There are specific requirements per platform on user management utilities. However they generally come pre-installed with the system and Ansible will require they are present at runtime. If they are not, a descriptive error message will be shown.\nOn SunOS platforms, the shadow file is backed up automatically since this module edits it directly. On other platforms, the shadow file is backed up by the underlying tools used by this module.\nOn macOS, this module uses C(dscl) to create, modify, and delete accounts. C(dseditgroup) is used to modify group membership. Accounts are hidden from the login window by modifying C(/Library/Preferences/com.apple.loginwindow.plist).\nOn FreeBSD, this module uses C(pw useradd) and C(chpass) to create, C(pw usermod) and C(chpass) to modify, C(pw userdel) remove, C(pw lock) to lock, and C(pw unlock) to unlock accounts.\nOn all other platforms, this module uses C(useradd) to create, C(usermod) to modify, and C(userdel) to remove accounts.",
      "options": {
        "append": {
          "aliases": [],
          "description": "If C(yes), add the user to the groups specified in C(groups).\nIf C(no), user will only be added to the groups specified in C(groups), removing them from all other groups.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "authorization": {
          "aliases": [],
          "description": "Sets the authorization of the user.\nDoes nothing when used with other platforms.\nCan set multiple authorizations using comma separation.\nTo delete all authorizations, use C(authorization='').\nCurrently supported on Illumos/Solaris.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "comment": {
          "aliases": [],
          "description": "Optionally sets the description (aka I(GECOS)) of user account.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "create_home": {
          "aliases": [
            "createhome"
          ],
          "description": "Unless set to C(no), a home directory will be made for the user when the account is created or if the home directory does not exist.\nChanged from C(createhome) to C(create_home) in Ansible 2.5.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "expires": {
          "aliases": [],
          "description": "An expiry time for the user in epoch, it will be ignored on platforms that do not support this.\nCurrently supported on GNU/Linux, FreeBSD, and DragonFlyBSD.\nSince Ansible 2.6 you can remove the expiry time by specifying a negative value. Currently supported on GNU/Linux and FreeBSD.",
          "type": "float",
          "required": false,
          "version_added": "1.9",
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "This only affects C(state=absent), it forces removal of the user and associated directories on supported platforms.\nThe behavior is the same as C(userdel --force), check the man page for C(userdel) on your system for details and support.\nWhen used with C(generate_ssh_key=yes) this forces an existing key to be overwritten.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "generate_ssh_key": {
          "aliases": [],
          "description": "Whether to generate a SSH key for the user in question.\nThis will B(not) overwrite an existing SSH key unless used with C(force=yes).",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Optionally sets the user's primary group (takes a group name).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "groups": {
          "aliases": [],
          "description": "List of groups user will be added to. When set to an empty string C(''), the user is removed from all groups except the primary group.\nBefore Ansible 2.3, the only input format allowed was a comma separated string.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "hidden": {
          "aliases": [],
          "description": "macOS only, optionally hide the user from the login window and system preferences.\nThe default will be C(yes) if the I(system) option is used.",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "home": {
          "aliases": [],
          "description": "Optionally set the user's home directory.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "local": {
          "aliases": [],
          "description": "Forces the use of \"local\" command alternatives on platforms that implement it.\nThis is useful in environments that use centralized authentication when you want to manipulate the local users (in other words, it uses C(luseradd) instead of C(useradd)).\nThis will check C(/etc/passwd) for an existing account before invoking commands. If the local account database exists somewhere other than C(/etc/passwd), this setting will not work properly.\nThis requires that the above commands as well as C(/etc/passwd) must exist on the target host, otherwise it will be a fatal error.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "login_class": {
          "aliases": [],
          "description": "Optionally sets the user's login class, a feature of most BSD OSs.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "move_home": {
          "aliases": [],
          "description": "If set to C(yes) when used with C(home: ), attempt to move the user's old home directory to the specified directory if it isn't there already and the old home exists.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "user"
          ],
          "description": "Name of the user to create, remove or modify.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "non_unique": {
          "aliases": [],
          "description": "Optionally when used with the -u option, this option allows to change the user ID to a non-unique value.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.1",
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "Optionally set the user's password to this crypted value.\nOn macOS systems, this value has to be cleartext. Beware of security issues.\nTo create a disabled account on Linux systems, set this to C('!') or C('*').\nTo create a disabled account on OpenBSD, set this to C('*************').\nSee L(FAQ entry,https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#how-do-i-generate-encrypted-passwords-for-the-user-module) for details on various ways to generate these password values.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "password_expire_max": {
          "aliases": [],
          "description": "Maximum number of days between password change.\nSupported on Linux only.",
          "type": "int",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "password_expire_min": {
          "aliases": [],
          "description": "Minimum number of days between password change.\nSupported on Linux only.",
          "type": "int",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "password_lock": {
          "aliases": [],
          "description": "Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).\nImplementation differs by platform. This option does not always mean the user cannot login using other methods.\nThis option does not disable the user, only lock the password.\nThis must be set to C(False) in order to unlock a currently locked password. The absence of this parameter will not unlock a password.\nCurrently supported on Linux, FreeBSD, DragonFlyBSD, NetBSD, OpenBSD.",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "profile": {
          "aliases": [],
          "description": "Sets the profile of the user.\nDoes nothing when used with other platforms.\nCan set multiple profiles using comma separation.\nTo delete all the profiles, use C(profile='').\nCurrently supported on Illumos/Solaris.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "remove": {
          "aliases": [],
          "description": "This only affects C(state=absent), it attempts to remove directories associated with the user.\nThe behavior is the same as C(userdel --remove), check the man page for details and support.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "role": {
          "aliases": [],
          "description": "Sets the role of the user.\nDoes nothing when used with other platforms.\nCan set multiple roles using comma separation.\nTo delete all roles, use C(role='').\nCurrently supported on Illumos/Solaris.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "Optionally sets the seuser type (user_u) on selinux enabled systems.",
          "type": "str",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        },
        "shell": {
          "aliases": [],
          "description": "Optionally set the user's shell.\nOn macOS, before Ansible 2.5, the default shell for non-system users was C(/usr/bin/false). Since Ansible 2.5, the default shell for non-system users on macOS is C(/bin/bash).\nSee notes for details on how other operating systems determine the default shell by the underlying tool.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "skeleton": {
          "aliases": [],
          "description": "Optionally set a home skeleton directory.\nRequires C(create_home) option!",
          "type": "str",
          "required": false,
          "version_added": "2.0",
          "suboptions": {}
        },
        "ssh_key_bits": {
          "aliases": [],
          "description": "Optionally specify number of bits in SSH key to create.",
          "default": "default set by ssh-keygen",
          "type": "int",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "ssh_key_comment": {
          "aliases": [],
          "description": "Optionally define the comment for the SSH key.",
          "default": "ansible-generated on $HOSTNAME",
          "type": "str",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "ssh_key_file": {
          "aliases": [],
          "description": "Optionally specify the SSH key filename.\nIf this is a relative filename then it will be relative to the user's home directory.\nThis parameter defaults to I(.ssh/id_rsa).",
          "type": "path",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "ssh_key_passphrase": {
          "aliases": [],
          "description": "Set a passphrase for the SSH key.\nIf no passphrase is provided, the SSH key will default to having no passphrase.",
          "type": "str",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "ssh_key_type": {
          "aliases": [],
          "description": "Optionally specify the type of SSH key to generate.\nAvailable SSH key types will depend on implementation present on target host.",
          "default": "rsa",
          "type": "str",
          "required": false,
          "version_added": "0.9",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the account should exist or not, taking action if the state is different from what is stated.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "system": {
          "aliases": [],
          "description": "When creating an account C(state=present), setting this to C(yes) makes the user a system account.\nThis setting cannot be changed on existing users.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "uid": {
          "aliases": [],
          "description": "Optionally sets the I(UID) of the user.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "umask": {
          "aliases": [],
          "description": "Sets the umask of the user.\nDoes nothing when used with other platforms.\nCurrently supported on Linux.\nRequires C(local) is omitted or False.",
          "type": "str",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "update_password": {
          "aliases": [],
          "description": "C(always) will update passwords if they differ.\nC(on_create) will only set the password for newly created users.",
          "default": "always",
          "type": "str",
          "required": false,
          "choices": [
            "always",
            "on_create"
          ],
          "version_added": "1.3",
          "suboptions": {}
        }
      },
      "short_description": "Manage user accounts",
      "version_added": "0.2"
    },
    "examples": "\n- name: Add the user 'johnd' with a specific uid and a primary group of 'admin'\n  ansible.builtin.user:\n    name: johnd\n    comment: John Doe\n    uid: 1040\n    group: admin\n\n- name: Add the user 'james' with a bash shell, appending the group 'admins' and 'developers' to the user's groups\n  ansible.builtin.user:\n    name: james\n    shell: /bin/bash\n    groups: admins,developers\n    append: yes\n\n- name: Remove the user 'johnd'\n  ansible.builtin.user:\n    name: johnd\n    state: absent\n    remove: yes\n\n- name: Create a 2048-bit SSH key for user jsmith in ~jsmith/.ssh/id_rsa\n  ansible.builtin.user:\n    name: jsmith\n    generate_ssh_key: yes\n    ssh_key_bits: 2048\n    ssh_key_file: .ssh/id_rsa\n\n- name: Added a consultant whose account you want to expire\n  ansible.builtin.user:\n    name: james18\n    shell: /bin/zsh\n    groups: developers\n    expires: 1422403387\n\n- name: Starting at Ansible 2.6, modify user, remove expiry time\n  ansible.builtin.user:\n    name: james18\n    expires: -1\n\n- name: Set maximum expiration date for password\n  user:\n    name: ram19\n    password_expire_max: 10\n\n- name: Set minimum expiration date for password\n  user:\n    name: pushkar15\n    password_expire_min: 5\n"
  },
  "validate_argument_spec": {
    "doc": {
      "description": "This module validates role arguments with a defined argument specification.",
      "has_action": true,
      "options": {
        "argument_spec": {
          "aliases": [],
          "description": "A dictionary like AnsibleModule argument_spec",
          "required": true,
          "suboptions": {}
        },
        "provided_arguments": {
          "aliases": [],
          "description": "A dictionary of the arguments that will be validated according to argument_spec",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Validate role argument specs.",
      "version_added": "2.11"
    },
    "examples": "\n- name: verify vars needed for this task file are present when included\n  validate_argument_spec:\n        argument_spec: '{{required_data}}'\n  vars:\n    required_data:\n        # unlike spec file, just put the options in directly\n        stuff:\n            description: stuff\n            type: str\n            choices: ['who', 'knows', 'what']\n            default: what\n        but:\n            description: i guess we need one\n            type: str\n            required: true\n\n\n- name: verify vars needed for this task file are present when included, with spec from a spec file\n  validate_argument_spec:\n        argument_spec: \"{{lookup('file', 'myargspec.yml')['specname']['options']}}\"\n\n\n- name: verify vars needed for next include and not from inside it, also with params i'll only define there\n  block:\n    - validate_argument_spec:\n        argument_spec: \"{{lookup('file', 'nakedoptions.yml'}}\"\n        provided_arguments:\n            but: \"that i can define on the include itself, like in it's C(vars:) keyword\"\n\n    - name: the include itself\n      vars:\n        stuff: knows\n        but: nobuts!\n"
  },
  "wait_for": {
    "doc": {
      "description": "You can wait for a set amount of time C(timeout), this is the default if nothing is specified or just C(timeout) is specified. This does not produce an error.\nWaiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.\nIt is also useful when starting guests with the M(community.libvirt.virt) module and needing to pause until they are ready.\nThis module can also be used to wait for a regex match a string to be present in a file.\nIn Ansible 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.\nIn Ansible 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.\nFor Windows targets, use the M(ansible.windows.win_wait_for) module instead.",
      "has_action": false,
      "notes": "The ability to use search_regex with a port connection was added in Ansible 1.7.\nPrior to Ansible 2.4, testing for the absence of a directory or UNIX socket did not work correctly.\nPrior to Ansible 2.4, testing for the presence of a file did not work correctly if the remote user did not have read access to that file.\nUnder some circumstances when using mandatory access control, a path may always be treated as being absent even if it exists, but can't be modified or created by the remote user either.\nWhen waiting for a path, symbolic links will be followed.  Many other modules that manipulate files do not follow symbolic links, so operations on the path using other modules may not work exactly as expected.",
      "options": {
        "active_connection_states": {
          "aliases": [],
          "description": "The list of TCP connection states which are counted as active connections.",
          "default": "['ESTABLISHED', 'FIN_WAIT1', 'FIN_WAIT2', 'SYN_RECV', 'SYN_SENT', 'TIME_WAIT']",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.3",
          "suboptions": {}
        },
        "connect_timeout": {
          "aliases": [],
          "description": "Maximum number of seconds to wait for a connection to happen before closing and retrying.",
          "default": "5",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "delay": {
          "aliases": [],
          "description": "Number of seconds to wait before starting to poll.",
          "default": "0",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "exclude_hosts": {
          "aliases": [],
          "description": "List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "1.8",
          "suboptions": {}
        },
        "host": {
          "aliases": [],
          "description": "A resolvable hostname or IP address to wait for.",
          "default": "127.0.0.1",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "msg": {
          "aliases": [],
          "description": "This overrides the normal error message from a failure to meet the required conditions.",
          "type": "str",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Path to a file on the filesystem that must exist before continuing.\nC(path) and C(port) are mutually exclusive parameters.",
          "type": "path",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "port": {
          "aliases": [],
          "description": "Port number to poll.\nC(path) and C(port) are mutually exclusive parameters.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "search_regex": {
          "aliases": [],
          "description": "Can be used to match a string in either a file or a socket connection.\nDefaults to a multiline regex.",
          "type": "str",
          "required": false,
          "version_added": "1.4",
          "suboptions": {}
        },
        "sleep": {
          "aliases": [],
          "description": "Number of seconds to sleep between checks.\nBefore Ansible 2.3 this was hardcoded to 1 second.",
          "default": "1",
          "type": "int",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Either C(present), C(started), or C(stopped), C(absent), or C(drained).\nWhen checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections.\nWhen checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed.",
          "default": "started",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "drained",
            "present",
            "started",
            "stopped"
          ],
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "Maximum number of seconds to wait for, when used with another condition it will force an error.\nWhen used without other conditions it is equivalent of just sleeping.",
          "default": "300",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Waits for a condition before continuing",
      "version_added": "0.7"
    },
    "examples": "\n- name: Sleep for 300 seconds and continue with play\n  wait_for:\n    timeout: 300\n  delegate_to: localhost\n\n- name: Wait for port 8000 to become open on the host, don't start checking for 10 seconds\n  wait_for:\n    port: 8000\n    delay: 10\n\n- name: Waits for port 8000 of any IP to close active connections, don't start checking for 10 seconds\n  wait_for:\n    host: 0.0.0.0\n    port: 8000\n    delay: 10\n    state: drained\n\n- name: Wait for port 8000 of any IP to close active connections, ignoring connections for specified hosts\n  wait_for:\n    host: 0.0.0.0\n    port: 8000\n    state: drained\n    exclude_hosts: 10.2.1.2,10.2.1.3\n\n- name: Wait until the file /tmp/foo is present before continuing\n  wait_for:\n    path: /tmp/foo\n\n- name: Wait until the string \"completed\" is in the file /tmp/foo before continuing\n  wait_for:\n    path: /tmp/foo\n    search_regex: completed\n\n- name: Wait until regex pattern matches in the file /tmp/foo and print the matched group\n  wait_for:\n    path: /tmp/foo\n    search_regex: completed (?P<task>\\w+)\n  register: waitfor\n- debug:\n    msg: Completed {{ waitfor['match_groupdict']['task'] }}\n\n- name: Wait until the lock file is removed\n  wait_for:\n    path: /var/lock/file.lock\n    state: absent\n\n- name: Wait until the process is finished and pid was destroyed\n  wait_for:\n    path: /proc/3466/status\n    state: absent\n\n- name: Output customized message when failed\n  wait_for:\n    path: /tmp/foo\n    state: present\n    msg: Timeout to find file /tmp/foo\n\n# Do not assume the inventory_hostname is resolvable and delay 10 seconds at start\n- name: Wait 300 seconds for port 22 to become open and contain \"OpenSSH\"\n  wait_for:\n    port: 22\n    host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'\n    search_regex: OpenSSH\n    delay: 10\n  connection: local\n\n# Same as above but you normally have ansible_connection set in inventory, which overrides 'connection'\n- name: Wait 300 seconds for port 22 to become open and contain \"OpenSSH\"\n  wait_for:\n    port: 22\n    host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'\n    search_regex: OpenSSH\n    delay: 10\n  vars:\n    ansible_connection: local\n"
  },
  "wait_for_connection": {
    "doc": {
      "description": "Waits for a total of C(timeout) seconds.\nRetries the transport connection after a timeout of C(connect_timeout).\nTests the transport connection every C(sleep) seconds.\nThis module makes use of internal ansible transport (and configuration) and the ping/win_ping module to guarantee correct end-to-end functioning.\nThis module is also supported for Windows targets.",
      "has_action": true,
      "options": {
        "connect_timeout": {
          "aliases": [],
          "description": "Maximum number of seconds to wait for a connection to happen before closing and retrying.",
          "default": "5",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "delay": {
          "aliases": [],
          "description": "Number of seconds to wait before starting to poll.",
          "default": "0",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "sleep": {
          "aliases": [],
          "description": "Number of seconds to sleep between checks.",
          "default": "1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "Maximum number of seconds to wait for.",
          "default": "600",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Waits until remote system is reachable/usable",
      "version_added": "2.3"
    },
    "examples": "\n- name: Wait 600 seconds for target connection to become reachable/usable\n  wait_for_connection:\n\n- name: Wait 300 seconds, but only start checking after 60 seconds\n  wait_for_connection:\n    delay: 60\n    timeout: 300\n\n# Wake desktops, wait for them to become ready and continue playbook\n- hosts: all\n  gather_facts: no\n  tasks:\n  - name: Send magic Wake-On-Lan packet to turn on individual systems\n    wakeonlan:\n      mac: '{{ mac }}'\n      broadcast: 192.168.0.255\n    delegate_to: localhost\n\n  - name: Wait for system to become reachable\n    wait_for_connection:\n\n  - name: Gather facts for first time\n    setup:\n\n# Build a new VM, wait for it to become ready and continue playbook\n- hosts: all\n  gather_facts: no\n  tasks:\n  - name: Clone new VM, if missing\n    vmware_guest:\n      hostname: '{{ vcenter_ipaddress }}'\n      name: '{{ inventory_hostname_short }}'\n      template: Windows 2012R2\n      customization:\n        hostname: '{{ vm_shortname }}'\n        runonce:\n        - powershell.exe -ExecutionPolicy Unrestricted -File C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1 -ForceNewSSLCert -EnableCredSSP\n    delegate_to: localhost\n\n  - name: Wait for system to become reachable over WinRM\n    wait_for_connection:\n      timeout: 900\n\n  - name: Gather facts for first time\n    setup:\n"
  },
  "yum": {
    "doc": {
      "description": "Installs, upgrade, downgrades, removes, and lists packages and groups with the I(yum) package manager.\nThis module only works on Python 2. If you require Python 3 support see the M(ansible.builtin.dnf) module.",
      "has_action": true,
      "notes": "When used with a C(loop:) each package will be processed individually, it is much more efficient to pass the list directly to the I(name) option.\nIn versions prior to 1.9.2 this module installed and removed each package given to the yum module separately. This caused problems when packages specified by filename or url had to be installed or removed together. In 1.9.2 this was fixed so that packages are installed in one yum transaction. However, if one of the packages adds a new yum repository that the other packages come from (such as epel-release) then that package needs to be installed in a separate task. This mimics yum's command line behaviour.\nYum itself has two types of groups.  \"Package groups\" are specified in the rpm itself while \"environment groups\" are specified in a separate file (usually by the distribution).  Unfortunately, this division becomes apparent to ansible users because ansible needs to operate on the group of packages in a single transaction and yum requires groups to be specified in different ways when used in that way.  Package groups are specified as \"@development-tools\" and environment groups are \"@^gnome-desktop-environment\". Use the \"yum group list hidden ids\" command to see which category of group the group you want to install falls into.\nThe yum module does not support clearing yum cache in an idempotent way, so it was decided not to implement it, the only method is to use command and call the yum command directly, namely \"command: yum clean all\" https://github.com/ansible/ansible/pull/31450#issuecomment-352889579",
      "options": {
        "allow_downgrade": {
          "aliases": [],
          "description": "Specify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "autoremove": {
          "aliases": [],
          "description": "If C(yes), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when state is I(absent)\nNOTE: This feature requires yum >= 3.4.3 (RHEL/CentOS 7+)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "bugfix": {
          "aliases": [],
          "description": "If set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.6",
          "suboptions": {}
        },
        "cacheonly": {
          "aliases": [],
          "description": "Tells yum to run entirely from system cache; does not download or update metadata.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.12",
          "suboptions": {}
        },
        "conf_file": {
          "aliases": [],
          "description": "The remote yum configuration file to use for the transaction.",
          "type": "str",
          "required": false,
          "version_added": "0.6",
          "suboptions": {}
        },
        "disable_excludes": {
          "aliases": [],
          "description": "Disable the excludes defined in YUM config files.\nIf set to C(all), disables all excludes.\nIf set to C(main), disable excludes defined in [main] in yum.conf.\nIf set to C(repoid), disable excludes defined for given repo id.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "disable_gpg_check": {
          "aliases": [],
          "description": "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.2",
          "suboptions": {}
        },
        "disable_plugin": {
          "aliases": [],
          "description": "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.5",
          "suboptions": {}
        },
        "disablerepo": {
          "aliases": [],
          "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(\",\").\nAs of Ansible 2.7, this can alternatively be a list instead of C(\",\") separated string",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "0.9",
          "suboptions": {}
        },
        "download_dir": {
          "aliases": [],
          "description": "Specifies an alternate directory to store packages.\nHas an effect only if I(download_only) is specified.",
          "type": "str",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "download_only": {
          "aliases": [],
          "description": "Only download the packages, do not install them.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "enable_plugin": {
          "aliases": [],
          "description": "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.5",
          "suboptions": {}
        },
        "enablerepo": {
          "aliases": [],
          "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(\",\").\nAs of Ansible 2.7, this can alternatively be a list instead of C(\",\") separated string",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "0.9",
          "suboptions": {}
        },
        "exclude": {
          "aliases": [],
          "description": "Package name(s) to exclude when state=present, or latest",
          "type": "list",
          "required": false,
          "elements": "str",
          "version_added": "2.0",
          "suboptions": {}
        },
        "install_repoquery": {
          "aliases": [],
          "description": "If repoquery is not available, install yum-utils. If the system is registered to RHN or an RHN Satellite, repoquery allows for querying all channels assigned to the system. It is also required to use the 'list' parameter.\nNOTE: This will run and be logged as a separate yum transation which takes place before any other installation or removal.\nNOTE: This will use the system's default enabled repositories without regard for disablerepo/enablerepo given to the module.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "1.5",
          "suboptions": {}
        },
        "install_weak_deps": {
          "aliases": [],
          "description": "Will also install all packages linked by a weak dependency relation.\nNOTE: This feature requires yum >= 4 (RHEL/CentOS 8+)",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "installroot": {
          "aliases": [],
          "description": "Specifies an alternative installroot, relative to which all packages will be installed.",
          "default": "/",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "list": {
          "aliases": [],
          "description": "Package name to run the equivalent of yum list C(--show-duplicates <package>) against. In addition to listing packages, use can also list the following: C(installed), C(updates), C(available) and C(repos).\nThis parameter is mutually exclusive with I(name).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "lock_timeout": {
          "aliases": [],
          "description": "Amount of time to wait for the yum lockfile to be freed.",
          "default": "30",
          "type": "int",
          "required": false,
          "version_added": "2.8",
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "pkg"
          ],
          "description": "A package name or package specifier with version, like C(name-1.0).\nComparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name>=1.0)\nIf a previous version is specified, the task also needs to turn C(allow_downgrade) on. See the C(allow_downgrade) documentation for caveats with downgrading packages.\nWhen using state=latest, this can be C('*') which means run C(yum -y update).\nYou can also pass a url or a local path to a rpm file (using state=present). To operate on several packages this can accept a comma separated string of packages or (as of 2.0) a list of packages.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "releasever": {
          "aliases": [],
          "description": "Specifies an alternative release from which all packages will be installed.",
          "type": "str",
          "required": false,
          "version_added": "2.7",
          "suboptions": {}
        },
        "security": {
          "aliases": [],
          "description": "If set to C(yes), and C(state=latest) then only installs updates that have been marked security related.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.4",
          "suboptions": {}
        },
        "skip_broken": {
          "aliases": [],
          "description": "Skip all unavailable packages or packages with broken dependencies without raising an error. Equivalent to passing the --skip-broken option.",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to install (C(present) or C(installed), C(latest)), or remove (C(absent) or C(removed)) a package.\nC(present) and C(installed) will simply ensure that a desired package is installed.\nC(latest) will update the specified package if it's not of the latest available version.\nC(absent) and C(removed) will remove the specified package.\nDefault is C(None), however in effect the default action is C(present) unless the C(autoremove) option is enabled for this module, then C(absent) is inferred.",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "installed",
            "latest",
            "present",
            "removed"
          ],
          "suboptions": {}
        },
        "update_cache": {
          "aliases": [
            "expire-cache"
          ],
          "description": "Force yum to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest).",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "1.9",
          "suboptions": {}
        },
        "update_only": {
          "aliases": [],
          "description": "When using latest, only update installed packages. Do not install packages.\nHas an effect only if state is I(latest)",
          "default": "no",
          "type": "bool",
          "required": false,
          "version_added": "2.5",
          "suboptions": {}
        },
        "use_backend": {
          "aliases": [],
          "description": "This module supports C(yum) (as it always has), this is known as C(yum3)/C(YUM3)/C(yum-deprecated) by upstream yum developers. As of Ansible 2.7+, this module also supports C(YUM4), which is the \"new yum\" and it has an C(dnf) backend.\nBy default, this module will select the backend based on the C(ansible_pkg_mgr) fact.",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "yum",
            "yum4",
            "dnf"
          ],
          "version_added": "2.7",
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\nPrior to 2.1 the code worked as if this was set to C(yes).",
          "default": "yes",
          "type": "bool",
          "required": false,
          "version_added": "2.1",
          "suboptions": {}
        }
      },
      "requirements": [
        "yum"
      ],
      "short_description": "Manages packages with the I(yum) package manager",
      "version_added": "historical"
    },
    "examples": "\n- name: Install the latest version of Apache\n  yum:\n    name: httpd\n    state: latest\n\n- name: Install Apache >= 2.4\n  yum:\n    name: httpd>=2.4\n    state: present\n\n- name: Install a list of packages (suitable replacement for 2.11 loop deprecation warning)\n  yum:\n    name:\n      - nginx\n      - postgresql\n      - postgresql-server\n    state: present\n\n- name: Install a list of packages with a list variable\n  yum:\n    name: \"{{ packages }}\"\n  vars:\n    packages:\n    - httpd\n    - httpd-tools\n\n- name: Remove the Apache package\n  yum:\n    name: httpd\n    state: absent\n\n- name: Install the latest version of Apache from the testing repo\n  yum:\n    name: httpd\n    enablerepo: testing\n    state: present\n\n- name: Install one specific version of Apache\n  yum:\n    name: httpd-2.2.29-1.4.amzn1\n    state: present\n\n- name: Upgrade all packages\n  yum:\n    name: '*'\n    state: latest\n\n- name: Upgrade all packages, excluding kernel & foo related packages\n  yum:\n    name: '*'\n    state: latest\n    exclude: kernel*,foo*\n\n- name: Install the nginx rpm from a remote repo\n  yum:\n    name: http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm\n    state: present\n\n- name: Install nginx rpm from a local file\n  yum:\n    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm\n    state: present\n\n- name: Install the 'Development tools' package group\n  yum:\n    name: \"@Development tools\"\n    state: present\n\n- name: Install the 'Gnome desktop' environment group\n  yum:\n    name: \"@^gnome-desktop-environment\"\n    state: present\n\n- name: List ansible packages and register result to print with debug later\n  yum:\n    list: ansible\n  register: result\n\n- name: Install package with multiple repos enabled\n  yum:\n    name: sos\n    enablerepo: \"epel,ol7_latest\"\n\n- name: Install package with multiple repos disabled\n  yum:\n    name: sos\n    disablerepo: \"epel,ol7_latest\"\n\n- name: Download the nginx package but do not install it\n  yum:\n    name:\n      - nginx\n    state: latest\n    download_only: true\n"
  },
  "yum_repository": {
    "doc": {
      "description": "Add or remove YUM repositories in RPM-based Linux distributions.\nIf you wish to update an existing repository definition use M(community.general.ini_file) instead.",
      "has_action": false,
      "notes": "All comments will be removed if modifying an existing repo file.\nSection order is preserved in an existing repo file.\nParameters in a section are ordered alphabetically in an existing repo file.\nThe repo file will be automatically deleted if it contains no repository.\nWhen removing a repository, beware that the metadata cache may still remain on disk until you run C(yum clean all). Use a notification handler for this.\nThe C(params) parameter was removed in Ansible 2.5 due to circumventing Ansible's parameter handling",
      "options": {
        "async": {
          "aliases": [],
          "description": "If set to C(yes) Yum will download packages and metadata from this repo in parallel, if possible.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "attributes": {
          "aliases": [
            "attr"
          ],
          "description": "The attributes the resulting filesystem object should have.\nTo get supported flags look at the man page for I(chattr) on the target system.\nThis string should contain the attributes in the same order as the one displayed by I(lsattr).\nThe C(=) operator is assumed as default, otherwise C(+) or C(-) operators need to be included in the string.",
          "type": "str",
          "required": false,
          "version_added": "2.3",
          "suboptions": {}
        },
        "bandwidth": {
          "aliases": [],
          "description": "Maximum available network bandwidth in bytes/second. Used with the I(throttle) option.\nIf I(throttle) is a percentage and bandwidth is C(0) then bandwidth throttling will be disabled. If I(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is C(0) (no bandwidth throttling).",
          "default": "0",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "baseurl": {
          "aliases": [],
          "description": "URL to the directory where the yum repository's 'repodata' directory lives.\nIt can also be a list of multiple URLs.\nThis, the I(metalink) or I(mirrorlist) parameters are required if I(state) is set to C(present).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "cost": {
          "aliases": [],
          "description": "Relative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other.",
          "default": "1000",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "deltarpm_metadata_percentage": {
          "aliases": [],
          "description": "When the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over C(100), so C(200) means that the metadata is required to be half the size of the packages. Use C(0) to turn off this check, and always download metadata.",
          "default": "100",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "deltarpm_percentage": {
          "aliases": [],
          "description": "When the relative size of delta vs pkg is larger than this, delta is not used. Use C(0) to turn off delta rpm processing. Local repositories (with file:// I(baseurl)) have delta rpms turned off by default.",
          "default": "75",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "description": {
          "aliases": [],
          "description": "A human readable string describing the repository. This option corresponds to the \"name\" property in the repo file.\nThis parameter is only required if I(state) is set to C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "enabled": {
          "aliases": [],
          "description": "This tells yum whether or not use this repository.\nYum default value is C(true).",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "enablegroups": {
          "aliases": [],
          "description": "Determines whether yum will allow the use of package groups for this repository.\nYum default value is C(true).",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "exclude": {
          "aliases": [],
          "description": "List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.\nThe list can also be a regular YAML array.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "failovermethod": {
          "aliases": [],
          "description": "C(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.\nC(priority) starts from the first I(baseurl) listed and reads through them sequentially.",
          "default": "roundrobin",
          "type": "str",
          "required": false,
          "choices": [
            "roundrobin",
            "priority"
          ],
          "suboptions": {}
        },
        "file": {
          "aliases": [],
          "description": "File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "gpgcakey": {
          "aliases": [],
          "description": "A URL pointing to the ASCII-armored CA key file for the repository.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "gpgcheck": {
          "aliases": [],
          "description": "Tells yum whether or not it should perform a GPG signature check on packages.\nNo default setting. If the value is not set, the system setting from C(/etc/yum.conf) or system default of C(no) will be used.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "gpgkey": {
          "aliases": [],
          "description": "A URL pointing to the ASCII-armored GPG key file for the repository.\nIt can also be a list of multiple URLs.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "group": {
          "aliases": [],
          "description": "Name of the group that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "http_caching": {
          "aliases": [],
          "description": "Determines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.\nC(all) means that all HTTP downloads should be cached.\nC(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).\nC(none) means that no HTTP downloads should be cached.",
          "default": "all",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "packages",
            "none"
          ],
          "suboptions": {}
        },
        "include": {
          "aliases": [],
          "description": "Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "includepkgs": {
          "aliases": [],
          "description": "List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.\nThe list can also be a regular YAML array.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "ip_resolve": {
          "aliases": [],
          "description": "Determines how yum resolves host names.\nC(4) or C(IPv4) - resolve to IPv4 addresses only.\nC(6) or C(IPv6) - resolve to IPv6 addresses only.",
          "default": "whatever",
          "type": "str",
          "required": false,
          "choices": [
            "4",
            "6",
            "IPv4",
            "IPv6",
            "whatever"
          ],
          "suboptions": {}
        },
        "keepalive": {
          "aliases": [],
          "description": "This tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "keepcache": {
          "aliases": [],
          "description": "Either C(1) or C(0). Determines whether or not yum keeps the cache of headers and packages after successful installation.",
          "default": "1",
          "type": "str",
          "required": false,
          "choices": [
            "0",
            "1"
          ],
          "suboptions": {}
        },
        "metadata_expire": {
          "aliases": [],
          "description": "Time (in seconds) after which the metadata will expire.\nDefault value is 6 hours.",
          "default": "21600",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "metadata_expire_filter": {
          "aliases": [],
          "description": "Filter the I(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from \"I'm about to install/upgrade, so this better be current\" to \"Anything that's available is good enough\".\nC(never) - Nothing is filtered, always obey I(metadata_expire).\nC(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. I(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).\nC(read-only:present) - Commands that are balanced between past and future. Eg. I(yum list yum).\nC(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. I(yum check-update).\nNote that this option does not override \"yum clean expire-cache\".",
          "default": "read-only:present",
          "type": "str",
          "required": false,
          "choices": [
            "never",
            "read-only:past",
            "read-only:present",
            "read-only:future"
          ],
          "suboptions": {}
        },
        "metalink": {
          "aliases": [],
          "description": "Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).\nThis, the I(baseurl) or I(mirrorlist) parameters are required if I(state) is set to C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mirrorlist": {
          "aliases": [],
          "description": "Specifies a URL to a file containing a list of baseurls.\nThis, the I(baseurl) or I(metalink) parameters are required if I(state) is set to C(present).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mirrorlist_expire": {
          "aliases": [],
          "description": "Time (in seconds) after which the mirrorlist locally cached will expire.\nDefault value is 6 hours.",
          "default": "21600",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "mode": {
          "aliases": [],
          "description": "The permissions the resulting filesystem object should have.\nFor those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.\nGiving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.\nAs of Ansible 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).\nIf C(mode) is not specified and the destination filesystem object B(does not) exist, the default C(umask) on the system will be used when setting the mode for the newly created filesystem object.\nIf C(mode) is not specified and the destination filesystem object B(does) exist, the mode of the existing filesystem object will be used.\nSpecifying C(mode) is the best way to ensure filesystem objects are created with the correct permissions. See CVE-2020-1736 for further details.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "module_hotfixes": {
          "aliases": [],
          "description": "Disable module RPM filtering and make all RPMs from the repository available. The default is C(None).",
          "type": "bool",
          "required": false,
          "version_added": "2.11",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Unique repository ID. This option builds the section name of the repository in the repo file.\nThis parameter is only required if I(state) is set to C(present) or C(absent).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "owner": {
          "aliases": [],
          "description": "Name of the user that should own the filesystem object, as would be fed to I(chown).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "Password to use with the username for basic authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "priority": {
          "aliases": [],
          "description": "Enforce ordered protection of repositories. The value is an integer from 1 to 99.\nThis option only works if the YUM Priorities plugin is installed.",
          "default": "99",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "protect": {
          "aliases": [],
          "description": "Protect packages from updates from other repositories.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "proxy": {
          "aliases": [],
          "description": "URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_password": {
          "aliases": [],
          "description": "Password for this proxy.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_username": {
          "aliases": [],
          "description": "Username to use for proxy.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "repo_gpgcheck": {
          "aliases": [],
          "description": "This tells yum whether or not it should perform a GPG signature check on the repodata from this repository.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "reposdir": {
          "aliases": [],
          "description": "Directory where the C(.repo) files will be stored.",
          "default": "/etc/yum.repos.d",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "retries": {
          "aliases": [],
          "description": "Set the number of times any attempt to retrieve a file should retry before returning an error. Setting this to C(0) makes yum try forever.",
          "default": "10",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "s3_enabled": {
          "aliases": [],
          "description": "Enables support for S3 repositories.\nThis option only works if the YUM S3 plugin is installed.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "selevel": {
          "aliases": [],
          "description": "The level part of the SELinux filesystem object context.\nThis is the MLS/MCS attribute, sometimes known as the C(range).\nWhen set to C(_default), it will use the C(level) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "serole": {
          "aliases": [],
          "description": "The role part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(role) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "setype": {
          "aliases": [],
          "description": "The type part of the SELinux filesystem object context.\nWhen set to C(_default), it will use the C(type) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "seuser": {
          "aliases": [],
          "description": "The user part of the SELinux filesystem object context.\nBy default it uses the C(system) policy, where applicable.\nWhen set to C(_default), it will use the C(user) portion of the policy if available.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "skip_if_unavailable": {
          "aliases": [],
          "description": "If set to C(yes) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ssl_check_cert_permissions": {
          "aliases": [],
          "description": "Whether yum should check the permissions on the paths for the certificates on the repository (both remote and local).\nIf we can't read any of the files then yum will force I(skip_if_unavailable) to be C(yes). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "sslcacert": {
          "aliases": [
            "ca_cert"
          ],
          "description": "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sslclientcert": {
          "aliases": [
            "client_cert"
          ],
          "description": "Path to the SSL client certificate yum should use to connect to repos/remote sites.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sslclientkey": {
          "aliases": [
            "client_key"
          ],
          "description": "Path to the SSL client key yum should use to connect to repos/remote sites.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sslverify": {
          "aliases": [
            "validate_certs"
          ],
          "description": "Defines whether yum should verify SSL certificates/hosts at all.",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "State of the repo file.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "throttle": {
          "aliases": [],
          "description": "Enable bandwidth throttling for downloads.\nThis option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "Number of seconds to wait for a connection before timing out.",
          "default": "30",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "ui_repoid_vars": {
          "aliases": [],
          "description": "When a repository id is displayed, append these yum variables to the string if they are used in the I(baseurl)/etc. Variables are appended in the order listed (and found).",
          "default": "releasever basearch",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "unsafe_writes": {
          "aliases": [],
          "description": "Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object.\nBy default this module uses atomic operations to prevent data corruption or inconsistent reads from the target filesystem objecs, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted filesystem objects, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.\nThis option allows Ansible to fall back to unsafe methods of updating filesystem objects when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).\nIMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "2.2",
          "suboptions": {}
        },
        "username": {
          "aliases": [],
          "description": "Username to use for basic authentication to a repo or really any url.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Add or remove YUM repositories",
      "version_added": "2.1"
    },
    "examples": "\n- name: Add repository\n  yum_repository:\n    name: epel\n    description: EPEL YUM repo\n    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/\n\n- name: Add multiple repositories into the same file (1/2)\n  yum_repository:\n    name: epel\n    description: EPEL YUM repo\n    file: external_repos\n    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/\n    gpgcheck: no\n\n- name: Add multiple repositories into the same file (2/2)\n  yum_repository:\n    name: rpmforge\n    description: RPMforge YUM repo\n    file: external_repos\n    baseurl: http://apt.sw.be/redhat/el7/en/$basearch/rpmforge\n    mirrorlist: http://mirrorlist.repoforge.org/el7/mirrors-rpmforge\n    enabled: no\n\n# Handler showing how to clean yum metadata cache\n- name: yum-clean-metadata\n  command: yum clean metadata\n  args:\n    warn: no\n\n# Example removing a repository and cleaning up metadata cache\n- name: Remove repository (and clean up left-over metadata)\n  yum_repository:\n    name: epel\n    state: absent\n  notify: yum-clean-metadata\n\n- name: Remove repository from a specific repo file\n  yum_repository:\n    name: epel\n    file: external_repos\n    state: absent\n"
  }
}