{
  "community.rabbitmq.rabbitmq_binding": {
    "doc": {
      "description": "This module uses rabbitMQ REST APIs to create / delete bindings.",
      "has_action": false,
      "options": {
        "arguments": {
          "aliases": [],
          "description": "extra arguments for exchange. If defined this argument is a key/value dictionary",
          "default": "{}",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "ca_cert": {
          "aliases": [
            "cacert"
          ],
          "description": "CA certificate to verify SSL connection to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [
            "cert"
          ],
          "description": "Client certificate to send on SSL connections to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_key": {
          "aliases": [
            "key"
          ],
          "description": "Private key matching the client certificate.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "destination": {
          "aliases": [
            "dst",
            "dest"
          ],
          "description": "destination exchange or queue for the binding.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "destination_type": {
          "aliases": [
            "type",
            "dest_type"
          ],
          "description": "Either queue or exchange.",
          "type": "str",
          "required": true,
          "choices": [
            "queue",
            "exchange"
          ],
          "suboptions": {}
        },
        "login_host": {
          "aliases": [],
          "description": "RabbitMQ host for connection.",
          "default": "localhost",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_password": {
          "aliases": [],
          "description": "RabbitMQ password for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_port": {
          "aliases": [],
          "description": "RabbitMQ management API port.",
          "default": "15672",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_protocol": {
          "aliases": [],
          "description": "RabbitMQ management API protocol.",
          "default": "http",
          "type": "str",
          "required": false,
          "choices": [
            "http",
            "https"
          ],
          "suboptions": {}
        },
        "login_user": {
          "aliases": [],
          "description": "RabbitMQ user for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "src",
            "source"
          ],
          "description": "source exchange to create binding on.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "routing_key": {
          "aliases": [],
          "description": "routing key for the binding.",
          "default": "#",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the bindings should be present or absent.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "RabbitMQ virtual host.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "requests >= 1.0.0"
      ],
      "short_description": "Manage rabbitMQ bindings"
    },
    "examples": "\n# Bind myQueue to directExchange with routing key info\n- community.rabbitmq.rabbitmq_binding:\n    name: directExchange\n    destination: myQueue\n    type: queue\n    routing_key: info\n\n# Bind directExchange to topicExchange with routing key *.info\n- community.rabbitmq.rabbitmq_binding:\n    name: topicExchange\n    destination: topicExchange\n    type: exchange\n    routing_key: '*.info'\n"
  },
  "community.rabbitmq.rabbitmq_exchange": {
    "doc": {
      "description": "This module uses rabbitMQ Rest API to create/delete exchanges",
      "has_action": false,
      "options": {
        "arguments": {
          "aliases": [],
          "description": "extra arguments for exchange. If defined this argument is a key/value dictionary",
          "default": "{}",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "auto_delete": {
          "aliases": [],
          "description": "if the exchange should delete itself after all queues/exchanges unbound from it",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "ca_cert": {
          "aliases": [
            "cacert"
          ],
          "description": "CA certificate to verify SSL connection to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [
            "cert"
          ],
          "description": "Client certificate to send on SSL connections to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_key": {
          "aliases": [
            "key"
          ],
          "description": "Private key matching the client certificate.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "durable": {
          "aliases": [],
          "description": "whether exchange is durable or not",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "exchange_type": {
          "aliases": [
            "type"
          ],
          "description": "type for the exchange",
          "default": "direct",
          "type": "str",
          "required": false,
          "choices": [
            "fanout",
            "direct",
            "headers",
            "topic",
            "x-delayed-message"
          ],
          "suboptions": {}
        },
        "internal": {
          "aliases": [],
          "description": "exchange is available only for other exchanges",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "login_host": {
          "aliases": [],
          "description": "RabbitMQ host for connection.",
          "default": "localhost",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_password": {
          "aliases": [],
          "description": "RabbitMQ password for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_port": {
          "aliases": [],
          "description": "RabbitMQ management API port.",
          "default": "15672",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_protocol": {
          "aliases": [],
          "description": "RabbitMQ management API protocol.",
          "default": "http",
          "type": "str",
          "required": false,
          "choices": [
            "http",
            "https"
          ],
          "suboptions": {}
        },
        "login_user": {
          "aliases": [],
          "description": "RabbitMQ user for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the exchange to create",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the exchange should be present or absent",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "RabbitMQ virtual host.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "requests >= 1.0.0"
      ],
      "short_description": "Manage rabbitMQ exchanges"
    },
    "examples": "\n# Create direct exchange\n- community.rabbitmq.rabbitmq_exchange:\n    name: directExchange\n\n# Create topic exchange on vhost\n- community.rabbitmq.rabbitmq_exchange:\n    name: topicExchange\n    type: topic\n    vhost: myVhost\n"
  },
  "community.rabbitmq.rabbitmq_feature_flag": {
    "doc": {
      "description": "Allows to enable specified feature flag.",
      "has_action": false,
      "options": {
        "name": {
          "aliases": [],
          "description": "Feature flag name.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "Erlang node name of the target rabbit node.",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Enables feature flag",
      "version_added": "1.1.0"
    },
    "examples": "\n- name: Enable the 'maintenance_mode_status' feature flag on 'rabbit@node-1'\n  community.rabbitmq.rabbitmq_feature_flag:\n    name: maintenance_mode_status\n    node: rabbit@node-1\n"
  },
  "community.rabbitmq.rabbitmq_global_parameter": {
    "doc": {
      "description": "Manage dynamic, cluster-wide global parameters for RabbitMQ",
      "has_action": false,
      "options": {
        "name": {
          "aliases": [],
          "description": "Name of the global parameter being set",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "erlang node name of the rabbit we wish to configure",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify if global parameter is to be added or removed",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "value": {
          "aliases": [],
          "description": "Value of the global parameter, as a JSON term",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage RabbitMQ global parameters"
    },
    "examples": "\n# Set the global parameter 'cluster_name' to a value of 'mq-cluster' (in quotes)\n- community.rabbitmq.rabbitmq_global_parameter:\n    name: cluster_name\n    value: \"{{ 'mq-cluster' | to_json }}\"\n    state: present\n"
  },
  "community.rabbitmq.rabbitmq_parameter": {
    "doc": {
      "description": "Manage dynamic, cluster-wide parameters for RabbitMQ",
      "has_action": false,
      "options": {
        "component": {
          "aliases": [],
          "description": "Name of the component of which the parameter is being set",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the parameter being set",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "erlang node name of the rabbit we wish to configure",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify if parameter is to be added or removed",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "value": {
          "aliases": [],
          "description": "Value of the parameter, as a JSON term",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "vhost to apply access privileges.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage RabbitMQ parameters"
    },
    "examples": "\n# Set the federation parameter 'local_username' to a value of 'guest' (in quotes)\n- community.rabbitmq.rabbitmq_parameter:\n    component: federation\n    name: local-username\n    value: '\"guest\"'\n    state: present\n"
  },
  "community.rabbitmq.rabbitmq_plugin": {
    "doc": {
      "description": "This module can be used to enable or disable RabbitMQ plugins.",
      "has_action": false,
      "options": {
        "broker_state": {
          "aliases": [],
          "description": "Specify whether the broker should be online or offline for the plugin change.",
          "default": "online",
          "type": "str",
          "required": false,
          "choices": [
            "online",
            "offline"
          ],
          "suboptions": {}
        },
        "names": {
          "aliases": [
            "name"
          ],
          "description": "Comma-separated list of plugin names. Also, accepts plugin name.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "new_only": {
          "aliases": [],
          "description": "Only enable missing plugins.\nDoes not disable plugins that are not in the names list.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "prefix": {
          "aliases": [],
          "description": "Specify a custom install prefix to a Rabbit.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify if plugins are to be enabled or disabled.",
          "default": "enabled",
          "type": "str",
          "required": false,
          "choices": [
            "enabled",
            "disabled"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Manage RabbitMQ plugins"
    },
    "examples": "\n- name: Enables the rabbitmq_management plugin\n  community.rabbitmq.rabbitmq_plugin:\n    names: rabbitmq_management\n    state: enabled\n\n- name: Enable multiple rabbitmq plugins\n  community.rabbitmq.rabbitmq_plugin:\n    names: rabbitmq_management,rabbitmq_management_visualiser\n    state: enabled\n\n- name: Disable plugin\n  community.rabbitmq.rabbitmq_plugin:\n    names: rabbitmq_management\n    state: disabled\n\n- name: Enable every plugin in list with existing plugins\n  community.rabbitmq.rabbitmq_plugin:\n    names: rabbitmq_management,rabbitmq_management_visualiser,rabbitmq_shovel,rabbitmq_shovel_management\n    state: enabled\n    new_only: 'yes'\n\n- name: Enables the rabbitmq_peer_discovery_aws plugin without requiring a broker connection.\n  community.rabbitmq.rabbitmq_plugin:\n    names: rabbitmq_peer_discovery_aws_plugin\n    state: enabled\n    broker_state: offline\n"
  },
  "community.rabbitmq.rabbitmq_policy": {
    "doc": {
      "description": "Manage the state of a policy in RabbitMQ.",
      "has_action": false,
      "options": {
        "apply_to": {
          "aliases": [],
          "description": "What the policy applies to. Requires RabbitMQ 3.2.0 or later.",
          "default": "all",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "exchanges",
            "queues"
          ],
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of the policy to manage.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "Erlang node name of the rabbit we wish to configure.",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "pattern": {
          "aliases": [],
          "description": "A regex of queues to apply the policy to. Required when C(state=present). This option is no longer required as of Ansible 2.9.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "priority": {
          "aliases": [],
          "description": "The priority of the policy.",
          "default": "0",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The state of the policy.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "tags": {
          "aliases": [],
          "description": "A dict or string describing the policy. Required when C(state=present). This option is no longer required as of Ansible 2.9.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "The name of the vhost to apply to.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage the state of policies in RabbitMQ"
    },
    "examples": "\n- name: ensure the default vhost contains the HA policy via a dict\n  community.rabbitmq.rabbitmq_policy:\n    name: HA\n    pattern: .*\n  args:\n    tags:\n      ha-mode: all\n\n- name: ensure the default vhost contains the HA policy\n  community.rabbitmq.rabbitmq_policy:\n    name: HA\n    pattern: .*\n    tags:\n      ha-mode: all\n"
  },
  "community.rabbitmq.rabbitmq_publish": {
    "doc": {
      "description": "Publish a message on a RabbitMQ queue using a blocking connection.",
      "has_action": false,
      "notes": "This module requires the pika python library U(https://pika.readthedocs.io/).\nPika is a pure-Python implementation of the AMQP 0-9-1 protocol that tries to stay fairly independent of the underlying network support library.\nThis module is tested against RabbitMQ. Other AMQP 0.9.1 protocol based servers may work but not tested/guaranteed.\nThe certificate authentication was tested with certificates created via U(https://www.rabbitmq.com/ssl.html#automated-certificate-generation) and RabbitMQ configuration variables C(ssl_options.verify = verify_peer) & C(ssl_options.fail_if_no_peer_cert = true).",
      "options": {
        "auto_delete": {
          "aliases": [],
          "description": "Set the queue to auto delete.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "body": {
          "aliases": [],
          "description": "The body of the message.\nA C(body) cannot be provided if a C(src) is specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "cafile": {
          "aliases": [],
          "description": "CA file used during connection to the RabbitMQ server over SSL.\nIf this option is specified, also I(certfile) and I(keyfile) must be specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "certfile": {
          "aliases": [],
          "description": "Client certificate to establish SSL connection.\nIf this option is specified, also I(cafile) and I(keyfile) must be specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "content_type": {
          "aliases": [],
          "description": "The content type of the body.",
          "default": "text/plain",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "durable": {
          "aliases": [],
          "description": "Set the queue to be durable.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "exchange": {
          "aliases": [],
          "description": "The exchange to publish a message to.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "exclusive": {
          "aliases": [],
          "description": "Set the queue to be exclusive.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "A dictionary of headers to post with the message.",
          "default": "{}",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "host": {
          "aliases": [],
          "description": "The RabbitMQ server hostname or IP.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "keyfile": {
          "aliases": [],
          "description": "Client key to establish SSL connection.\nIf this option is specified, also I(cafile) and I(certfile) must be specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "The RabbitMQ password.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "port": {
          "aliases": [],
          "description": "The RabbitMQ server port.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "proto": {
          "aliases": [],
          "description": "The protocol to use.",
          "type": "str",
          "required": false,
          "choices": [
            "amqps",
            "amqp"
          ],
          "suboptions": {}
        },
        "queue": {
          "aliases": [],
          "description": "The queue to publish a message to.  If no queue is specified, RabbitMQ will return a random queue name.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "routing_key": {
          "aliases": [],
          "description": "The routing key.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [
            "file"
          ],
          "description": "A file to upload to the queue.  Automatic mime type detection is attempted if content_type is not defined (left as default).\nA C(src) cannot be provided if a C(body) is specified.\nThe filename is added to the headers of the posted message to RabbitMQ. Key being the C(filename), value is the filename.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "An URL connection string to connect to the RabbitMQ server.\nI(url) and I(host)/I(port)/I(user)/I(pass)/I(vhost) are mutually exclusive, use either or but not both.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "username": {
          "aliases": [],
          "description": "The RabbitMQ username.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "The virtual host to target.\nIf default vhost is required, use C('%2F').",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "pika"
      ],
      "short_description": "Publish a message to a RabbitMQ queue."
    },
    "examples": "\n- name: Publish a message to a queue with headers\n  community.rabbitmq.rabbitmq_publish:\n    url: \"amqp://guest:guest@192.168.0.32:5672/%2F\"\n    queue: 'test'\n    body: \"Hello world from ansible module rabbitmq_publish\"\n    content_type: \"text/plain\"\n    headers:\n      myHeader: myHeaderValue\n\n\n- name: Publish a file to a queue\n  community.rabbitmq.rabbitmq_publish:\n    url: \"amqp://guest:guest@192.168.0.32:5672/%2F\"\n    queue: 'images'\n    file: 'path/to/logo.gif'\n\n- name: RabbitMQ auto generated queue\n  community.rabbitmq.rabbitmq_publish:\n    url: \"amqp://guest:guest@192.168.0.32:5672/%2F\"\n    body: \"Hello world random queue from ansible module rabbitmq_publish\"\n    content_type: \"text/plain\"\n\n- name: Publish with certs\n  community.rabbitmq.rabbitmq_publish:\n    url: \"amqps://guest:guest@192.168.0.32:5671/%2F\"\n    body: \"Hello test queue from ansible module rabbitmq_publish via SSL certs\"\n    queue: 'test'\n    content_type: \"text/plain\"\n    cafile: 'ca_certificate.pem'\n    certfile: 'client_certificate.pem'\n    keyfile: 'client_key.pem'\n\n"
  },
  "community.rabbitmq.rabbitmq_queue": {
    "doc": {
      "description": "This module uses rabbitMQ Rest API to create/delete queues.\nDue to limitations in the API, it cannot modify existing queues.",
      "has_action": false,
      "options": {
        "arguments": {
          "aliases": [],
          "description": "extra arguments for queue. If defined this argument is a key/value dictionary\nArguments here take precedence over parameters. If both are defined, the argument will be used.",
          "default": "{}",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "auto_delete": {
          "aliases": [],
          "description": "if the queue should delete itself after all queues/queues unbound from it",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "auto_expires": {
          "aliases": [],
          "description": "How long a queue can be unused before it is automatically deleted (milliseconds)",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "ca_cert": {
          "aliases": [
            "cacert"
          ],
          "description": "CA certificate to verify SSL connection to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [
            "cert"
          ],
          "description": "Client certificate to send on SSL connections to management API.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_key": {
          "aliases": [
            "key"
          ],
          "description": "Private key matching the client certificate.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "dead_letter_exchange": {
          "aliases": [],
          "description": "Optional name of an exchange to which messages will be republished if they\nare rejected or expire",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "dead_letter_routing_key": {
          "aliases": [],
          "description": "Optional replacement routing key to use when a message is dead-lettered.\nOriginal routing key will be used if unset",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "durable": {
          "aliases": [],
          "description": "whether queue is durable or not",
          "default": "yes",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "login_host": {
          "aliases": [],
          "description": "RabbitMQ host for connection.",
          "default": "localhost",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_password": {
          "aliases": [],
          "description": "RabbitMQ password for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_port": {
          "aliases": [],
          "description": "RabbitMQ management API port.",
          "default": "15672",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "login_protocol": {
          "aliases": [],
          "description": "RabbitMQ management API protocol.",
          "default": "http",
          "type": "str",
          "required": false,
          "choices": [
            "http",
            "https"
          ],
          "suboptions": {}
        },
        "login_user": {
          "aliases": [],
          "description": "RabbitMQ user for connection.",
          "default": "guest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "max_length": {
          "aliases": [],
          "description": "How many messages can the queue contain before it starts rejecting",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "max_priority": {
          "aliases": [],
          "description": "Maximum number of priority levels for the queue to support.\nIf not set, the queue will not support message priorities.\nLarger numbers indicate higher priority.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "message_ttl": {
          "aliases": [],
          "description": "How long a message can live in queue before it is discarded (milliseconds)",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the queue",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the queue should be present or absent",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "RabbitMQ virtual host.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "requirements": [
        "requests >= 1.0.0"
      ],
      "short_description": "Manage rabbitMQ queues"
    },
    "examples": "\n# Create a queue\n- community.rabbitmq.rabbitmq_queue:\n    name: myQueue\n\n# Create a queue on remote host\n- community.rabbitmq.rabbitmq_queue:\n    name: myRemoteQueue\n    login_user: user\n    login_password: secret\n    login_host: remote.example.org\n"
  },
  "community.rabbitmq.rabbitmq_upgrade": {
    "doc": {
      "description": "Allows to execute rabbitmq-upgrade commands",
      "has_action": false,
      "options": {
        "action": {
          "aliases": [],
          "description": "Specify action to be executed.",
          "type": "str",
          "required": true,
          "choices": [
            "await_online_quorum_plus_one",
            "await_online_synchronized_mirror",
            "post_upgrade",
            "drain",
            "revive"
          ],
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "Erlang node name of the target rabbit node.",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Execute rabbitmq-upgrade commands",
      "version_added": "1.1.0"
    },
    "examples": "\n- name: Drain 'rabbit@node-1' node (in other words, put it into maintenance mode)\n  community.rabbitmq.rabbitmq_upgrade:\n    action: drain\n    node: rabbit@node-1\n"
  },
  "community.rabbitmq.rabbitmq_user": {
    "doc": {
      "description": "Add or remove users to RabbitMQ and assign permissions",
      "has_action": false,
      "options": {
        "configure_priv": {
          "aliases": [],
          "description": "Regular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used.",
          "default": "^$",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Deletes and recreates the user.",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "erlang node name of the rabbit we wish to configure",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "Password of user to add.\nTo change the password of an existing user, you must also specify C(update_password=always).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "permissions": {
          "aliases": [],
          "description": "a list of dicts, each dict contains vhost, configure_priv, write_priv, and read_priv, and represents a permission rule for that vhost.\nThis option should be preferable when you care about all permissions of the user.\nYou should use vhost, configure_priv, write_priv, and read_priv options instead if you care about permissions for just some vhosts.",
          "default": "[]",
          "type": "list",
          "required": false,
          "elements": "dict",
          "suboptions": {}
        },
        "read_priv": {
          "aliases": [],
          "description": "Regular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used.",
          "default": "^$",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify if user is to be added or removed",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "tags": {
          "aliases": [],
          "description": "User tags specified as comma delimited",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "update_password": {
          "aliases": [],
          "description": "C(on_create) will only set the password for newly created users.  C(always) will update passwords if they differ.",
          "default": "on_create",
          "type": "str",
          "required": false,
          "choices": [
            "on_create",
            "always"
          ],
          "suboptions": {}
        },
        "user": {
          "aliases": [
            "username",
            "name"
          ],
          "description": "Name of user to add",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "vhost to apply access privileges.\nThis option will be ignored when permissions option is used.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "write_priv": {
          "aliases": [],
          "description": "Regular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used.",
          "default": "^$",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage RabbitMQ users"
    },
    "examples": "\n# Add user to server and assign full access control on / vhost.\n# The user might have permission rules for other vhost but you don't care.\n- community.rabbitmq.rabbitmq_user:\n    user: joe\n    password: changeme\n    vhost: /\n    configure_priv: .*\n    read_priv: .*\n    write_priv: .*\n    state: present\n\n# Add user to server and assign full access control on / vhost.\n# The user doesn't have permission rules for other vhosts\n- community.rabbitmq.rabbitmq_user:\n    user: joe\n    password: changeme\n    permissions:\n      - vhost: /\n        configure_priv: .*\n        read_priv: .*\n        write_priv: .*\n    state: present\n"
  },
  "community.rabbitmq.rabbitmq_user_limits": {
    "doc": {
      "description": "Manage the state of user limits in RabbitMQ. Supported since RabbitMQ version 3.8.10.",
      "has_action": false,
      "notes": "Supports C(check_mode).",
      "options": {
        "max_channels": {
          "aliases": [],
          "description": "Max number of channels.\nNegative value means \"no limit\".\nIgnored when the I(state) is C(absent).",
          "default": "-1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "max_connections": {
          "aliases": [],
          "description": "Max number of concurrent client connections.\nNegative value means \"no limit\".\nIgnored when the I(state) is C(absent).",
          "default": "-1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "Name of the RabbitMQ Erlang node to manage.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify whether the limits are to be set or cleared.\nIf set to C(absent), the limits of both I(max_connections) and I(max_channels) will be cleared.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "user": {
          "aliases": [
            "username",
            "name"
          ],
          "description": "Name of user to manage limits for.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Manage RabbitMQ user limits",
      "version_added": "1.1.0"
    },
    "examples": "\n- name: Limit both of the max number of connections and channels on the user 'guest'.\n  community.rabbitmq.rabbitmq_user_limits:\n    user: guest\n    max_connections: 64\n    max_channels: 256\n    state: present\n\n# This task implicitly clears the max number of channels limit using default value: -1.\n- name: Limit the max number of connections on the user 'guest'.\n  community.rabbitmq.rabbitmq_user_limits:\n    user: guest\n    max_connections: 64\n    state: present\n\n- name: Clear the limits on the user 'guest'.\n  community.rabbitmq.rabbitmq_user_limits:\n    user: guest\n    state: absent\n"
  },
  "community.rabbitmq.rabbitmq_vhost": {
    "doc": {
      "description": "Manage the state of a virtual host in RabbitMQ",
      "has_action": false,
      "options": {
        "name": {
          "aliases": [
            "vhost"
          ],
          "description": "The name of the vhost to manage",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "erlang node name of the rabbit we wish to configure",
          "default": "rabbit",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The state of vhost",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "tracing": {
          "aliases": [
            "trace"
          ],
          "description": "Enable/disable tracing for a vhost",
          "default": "no",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage the state of a virtual host in RabbitMQ"
    },
    "examples": "\n# Ensure that the vhost /test exists.\n- community.rabbitmq.rabbitmq_vhost:\n    name: /test\n    state: present\n"
  },
  "community.rabbitmq.rabbitmq_vhost_limits": {
    "doc": {
      "description": "This module sets/clears certain limits on a virtual host.\nThe configurable limits are I(max_connections) and I(max-queues).",
      "has_action": false,
      "options": {
        "max_connections": {
          "aliases": [],
          "description": "Max number of concurrent client connections.\nNegative value means \"no limit\".\nIgnored when the I(state) is C(absent).",
          "default": "-1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "max_queues": {
          "aliases": [],
          "description": "Max number of queues.\nNegative value means \"no limit\".\nIgnored when the I(state) is C(absent).",
          "default": "-1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "node": {
          "aliases": [],
          "description": "Name of the RabbitMQ Erlang node to manage.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify whether the limits are to be set or cleared.\nIf set to C(absent), the limits of both I(max_connections) and I(max-queues) will be cleared.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "present",
            "absent"
          ],
          "suboptions": {}
        },
        "vhost": {
          "aliases": [],
          "description": "Name of the virtual host to manage.",
          "default": "/",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage the state of virtual host limits in RabbitMQ"
    },
    "examples": "\n# Limit both of the max number of connections and queues on the vhost '/'.\n- community.rabbitmq.rabbitmq_vhost_limits:\n    vhost: /\n    max_connections: 64\n    max_queues: 256\n    state: present\n\n# Limit the max number of connections on the vhost '/'.\n# This task implicitly clears the max number of queues limit using default value: -1.\n- community.rabbitmq.rabbitmq_vhost_limits:\n    vhost: /\n    max_connections: 64\n    state: present\n\n# Clear the limits on the vhost '/'.\n- community.rabbitmq.rabbitmq_vhost_limits:\n    vhost: /\n    state: absent\n"
  }
}