{
  "ansible.windows.win_acl": {
    "doc": {
      "description": "Add or remove rights/permissions for a given user or group for the specified file, folder, registry key or AppPool identifies.",
      "has_action": false,
      "notes": "If adding ACL's for AppPool identities, the Windows Feature \"Web-Scripting-Tools\" must be enabled.",
      "options": {
        "inherit": {
          "aliases": [],
          "description": "Inherit flags on the ACL rules.\nCan be specified as a comma separated list, e.g. C(ContainerInherit), C(ObjectInherit).\nFor more information on the choices see MSDN InheritanceFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.inheritanceflags.aspx).\nDefaults to C(ContainerInherit, ObjectInherit) for Directories.",
          "type": "str",
          "required": false,
          "choices": [
            "ContainerInherit",
            "ObjectInherit"
          ],
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The path to the file or directory.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "propagation": {
          "aliases": [],
          "description": "Propagation flag on the ACL rules.\nFor more information on the choices see MSDN PropagationFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.propagationflags.aspx).",
          "default": "None",
          "type": "str",
          "required": false,
          "choices": [
            "InheritOnly",
            "None",
            "NoPropagateInherit"
          ],
          "suboptions": {}
        },
        "rights": {
          "aliases": [],
          "description": "The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).\nIf C(path) is a file or directory, rights can be any right under MSDN FileSystemRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.filesystemrights.aspx).\nIf C(path) is a registry key, rights can be any right under MSDN RegistryRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.registryrights.aspx).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify whether to add C(present) or remove C(absent) the specified access rule.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [],
          "description": "Specify whether to allow or deny the rights specified.",
          "type": "str",
          "required": true,
          "choices": [
            "allow",
            "deny"
          ],
          "suboptions": {}
        },
        "user": {
          "aliases": [],
          "description": "User or Group to add specified rights to act on src file/folder or registry key.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Set file/directory/registry permissions for a system user or group"
    },
    "examples": "\n- name: Restrict write and execute access to User Fed-Phil\n  ansible.windows.win_acl:\n    user: Fed-Phil\n    path: C:\\Important\\Executable.exe\n    type: deny\n    rights: ExecuteFile,Write\n\n- name: Add IIS_IUSRS allow rights\n  ansible.windows.win_acl:\n    path: C:\\inetpub\\wwwroot\\MySite\n    user: IIS_IUSRS\n    rights: FullControl\n    type: allow\n    state: present\n    inherit: ContainerInherit, ObjectInherit\n    propagation: 'None'\n\n- name: Set registry key right\n  ansible.windows.win_acl:\n    path: HKCU:\\Bovine\\Key\n    user: BUILTIN\\Users\n    rights: EnumerateSubKeys\n    type: allow\n    state: present\n    inherit: ContainerInherit, ObjectInherit\n    propagation: 'None'\n\n- name: Remove FullControl AccessRule for IIS_IUSRS\n  ansible.windows.win_acl:\n    path: C:\\inetpub\\wwwroot\\MySite\n    user: IIS_IUSRS\n    rights: FullControl\n    type: allow\n    state: absent\n    inherit: ContainerInherit, ObjectInherit\n    propagation: 'None'\n\n- name: Deny Intern\n  ansible.windows.win_acl:\n    path: C:\\Administrator\\Documents\n    user: Intern\n    rights: Read,Write,Modify,FullControl,Delete\n    type: deny\n    state: present\n"
  },
  "ansible.windows.win_acl_inheritance": {
    "doc": {
      "description": "Change ACL (Access Control List) inheritance and optionally copy inherited ACE's (Access Control Entry) to dedicated ACE's or vice versa.",
      "has_action": false,
      "options": {
        "path": {
          "aliases": [],
          "description": "Path to be used for changing inheritance",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "reorganize": {
          "aliases": [],
          "description": "For P(state) = I(absent), indicates if the inherited ACE's should be copied from the parent directory. This is necessary (in combination with removal) for a simple ACL instead of using multiple ACE deny entries.\nFor P(state) = I(present), indicates if the inherited ACE's should be deduplicated compared to the parent directory. This removes complexity of the ACL structure.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify whether to enable I(present) or disable I(absent) ACL inheritance.",
          "default": "absent",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Change ACL inheritance"
    },
    "examples": "\n- name: Disable inherited ACE's\n  ansible.windows.win_acl_inheritance:\n    path: C:\\apache\n    state: absent\n\n- name: Disable and copy inherited ACE's\n  ansible.windows.win_acl_inheritance:\n    path: C:\\apache\n    state: absent\n    reorganize: yes\n\n- name: Enable and remove dedicated ACE's\n  ansible.windows.win_acl_inheritance:\n    path: C:\\apache\n    state: present\n    reorganize: yes\n"
  },
  "ansible.windows.win_certificate_store": {
    "doc": {
      "description": "Used to import/export and remove certificates and keys from the local certificate store.\nThis module is not used to create certificates and will only manage existing certs as a file or in the store.\nIt can be used to import PEM, DER, P7B, PKCS12 (PFX) certificates and export PEM, DER and PKCS12 certificates.",
      "has_action": false,
      "notes": "Some actions on PKCS12 certificates and keys may fail with the error C(the specified network password is not correct), either use CredSSP or Kerberos with credential delegation, or use C(become) to bypass these restrictions.\nThe certificates must be located on the Windows host to be set with I(path).\nWhen importing a certificate for usage in IIS, it is generally required to use the C(machine) key_storage option, as both C(default) and C(user) will make the private key unreadable to IIS APPPOOL identities and prevent binding the certificate to the https endpoint.",
      "options": {
        "file_type": {
          "aliases": [],
          "description": "The file type to export the certificate as when C(state=exported).\nC(der) is a binary ASN.1 encoded file.\nC(pem) is a base64 encoded file of a der file in the OpenSSL form.\nC(pkcs12) (also known as pfx) is a binary container that contains both the certificate and private key unlike the other options.\nWhen C(pkcs12) is set and the private key is not exportable or accessible by the current user, it will throw an exception.",
          "default": "der",
          "type": "str",
          "required": false,
          "choices": [
            "der",
            "pem",
            "pkcs12"
          ],
          "suboptions": {}
        },
        "key_exportable": {
          "aliases": [],
          "description": "Whether to allow the private key to be exported.\nIf C(no), then this module and other process will only be able to export the certificate and the private key cannot be exported.\nUsed when C(state=present) only.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "key_storage": {
          "aliases": [],
          "description": "Specifies where Windows will store the private key when it is imported.\nWhen set to C(default), the default option as set by Windows is used, typically C(user).\nWhen set to C(machine), the key is stored in a path accessible by various users.\nWhen set to C(user), the key is stored in a path only accessible by the current user.\nUsed when C(state=present) only and cannot be changed once imported.\nSee U(https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509keystorageflags.aspx) for more details.",
          "default": "default",
          "type": "str",
          "required": false,
          "choices": [
            "default",
            "machine",
            "user"
          ],
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "The password of the pkcs12 certificate key.\nThis is used when reading a pkcs12 certificate file or the password to set when C(state=exported) and C(file_type=pkcs12).\nIf the pkcs12 file has no password set or no password should be set on the exported file, do not set this option.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The path to a certificate file.\nThis is required when I(state) is C(present) or C(exported).\nWhen I(state) is C(absent) and I(thumbprint) is not specified, the thumbprint is derived from the certificate at this path.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "If C(present), will ensure that the certificate at I(path) is imported into the certificate store specified.\nIf C(absent), will ensure that the certificate specified by I(thumbprint) or the thumbprint of the cert at I(path) is removed from the store specified.\nIf C(exported), will ensure the file at I(path) is a certificate specified by I(thumbprint).\nWhen exporting a certificate, if I(path) is a directory then the module will fail, otherwise the file will be replaced if needed.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "exported",
            "present"
          ],
          "suboptions": {}
        },
        "store_location": {
          "aliases": [],
          "description": "The store location to use when importing a certificate or searching for a certificate.\nCan be set to C(CurrentUser) or C(LocalMachine) when C(store_type=system).\nDefaults to C(LocalMachine) when C(store_type=system).\nMust be set to any service name when C(store_type=service).",
          "default": "LocalMachine",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "store_name": {
          "aliases": [],
          "description": "The store name to use when importing a certificate or searching for a certificate.\nC(AddressBook): The X.509 certificate store for other users\nC(AuthRoot): The X.509 certificate store for third-party certificate authorities (CAs)\nC(CertificateAuthority): The X.509 certificate store for intermediate certificate authorities (CAs)\nC(Disallowed): The X.509 certificate store for revoked certificates\nC(My): The X.509 certificate store for personal certificates\nC(Root): The X.509 certificate store for trusted root certificate authorities (CAs)\nC(TrustedPeople): The X.509 certificate store for directly trusted people and resources\nC(TrustedPublisher): The X.509 certificate store for directly trusted publishers",
          "default": "My",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "store_type": {
          "aliases": [],
          "description": "The store type to manage.\nUse C(system) to manage locations in the system store, C(LocalMachine) and C(CurrentUser).\nUse C(service) to manage the store of a service account specified by I(store_location).",
          "default": "system",
          "type": "str",
          "required": false,
          "choices": [
            "system",
            "service"
          ],
          "version_added": "1.5.0",
          "suboptions": {}
        },
        "thumbprint": {
          "aliases": [],
          "description": "The thumbprint as a hex string to either export or remove.\nSee the examples for how to specify the thumbprint.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manages the certificate store"
    },
    "examples": "\n- name: Import a certificate\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pem\n    state: present\n\n- name: Import pfx certificate that is password protected\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pfx\n    state: present\n    password: VeryStrongPasswordHere!\n  become: yes\n  become_method: runas\n\n- name: Import pfx certificate without password and set private key as un-exportable\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pfx\n    state: present\n    key_exportable: no\n  # usually you don't set this here but it is for illustrative purposes\n  vars:\n    ansible_winrm_transport: credssp\n\n- name: Remove a certificate based on file thumbprint\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pem\n    state: absent\n\n- name: Remove a certificate based on thumbprint\n  ansible.windows.win_certificate_store:\n    thumbprint: BD7AF104CF1872BDB518D95C9534EA941665FD27\n    state: absent\n\n- name: Remove certificate based on thumbprint is CurrentUser/TrustedPublishers store\n  ansible.windows.win_certificate_store:\n    thumbprint: BD7AF104CF1872BDB518D95C9534EA941665FD27\n    state: absent\n    store_location: CurrentUser\n    store_name: TrustedPublisher\n\n- name: Export certificate as der encoded file\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.cer\n    state: exported\n    file_type: der\n\n- name: Export certificate and key as pfx encoded file\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pfx\n    state: exported\n    file_type: pkcs12\n    password: AnotherStrongPass!\n  become: yes\n  become_method: runas\n  become_user: SYSTEM\n\n- name: Import certificate be used by IIS\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pfx\n    file_type: pkcs12\n    password: StrongPassword!\n    store_location: LocalMachine\n    key_storage: machine\n    state: present\n  become: yes\n  become_method: runas\n  become_user: SYSTEM\n\n- name: Import certificate to be used for LDAPS\n  ansible.windows.win_certificate_store:\n    path: C:\\Temp\\cert.pfx\n    password: StrongPassword!\n    store_type: service\n    store_location: NTDS\n    key_exportable: no\n    key_storage: machine\n    state: present\n"
  },
  "ansible.windows.win_command": {
    "doc": {
      "description": "The C(win_command) module takes the command name followed by a list of space-delimited arguments.\nThe given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($env:HOME) and operations like C(\"<\"), C(\">\"), C(\"|\"), and C(\";\") will not work (use the M(ansible.windows.win_shell) module if you need these features).\nFor non-Windows targets, use the M(ansible.builtin.command) module instead.",
      "has_action": false,
      "notes": "If you want to run a command through a shell (say you are using C(<), C(>), C(|), etc), you actually want the M(ansible.windows.win_shell) module instead. The M(ansible.windows.win_command) module is much more secure as it's not affected by the user's environment.\nC(creates), C(removes), and C(chdir) can be specified after the command. For instance, if you only want to run a command if a certain file does not exist, use this.",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "Set the specified path as the current working directory before executing a command.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "The C(win_command) module takes a free form command to run.\nThere is no parameter actually named 'free form'. See the examples!",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "output_encoding_override": {
          "aliases": [],
          "description": "This option overrides the encoding of stdout/stderr output.\nYou can use this option when you need to run a command which ignore the console's codepage.\nYou should only need to use this option in very rare circumstances.\nThis value can be any valid encoding C(Name) based on the output of C([System.Text.Encoding]::GetEncodings()). See U(https://docs.microsoft.com/dotnet/api/system.text.encoding.getencodings).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "stdin": {
          "aliases": [],
          "description": "Set the stdin of the command directly to the specified value.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Executes a command on a remote Windows node"
    },
    "examples": "\n- name: Save the result of 'whoami' in 'whoami_out'\n  ansible.windows.win_command: whoami\n  register: whoami_out\n\n- name: Run command that only runs if folder exists and runs from a specific folder\n  ansible.windows.win_command: wbadmin -backupTarget:C:\\backup\\\n  args:\n    chdir: C:\\somedir\\\n    creates: C:\\backup\\\n\n- name: Run an executable and send data to the stdin for the executable\n  ansible.windows.win_command: powershell.exe -\n  args:\n    stdin: Write-Host test\n"
  },
  "ansible.windows.win_copy": {
    "doc": {
      "description": "The C(win_copy) module copies a file on the local box to remote windows locations.\nFor non-Windows targets, use the M(ansible.builtin.copy) module instead.",
      "has_action": true,
      "notes": "Currently win_copy does not support copying symbolic links from both local to remote and remote to remote.\nIt is recommended that backslashes C(\\) are used instead of C(/) when dealing with remote paths.\nBecause win_copy runs over WinRM, it is not a very efficient transfer mechanism. If sending large files consider hosting them on a web service and using M(ansible.windows.win_get_url) instead.",
      "options": {
        "backup": {
          "aliases": [],
          "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.\nNo backup is taken when C(remote_src=False) and multiple files are being copied.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "content": {
          "aliases": [],
          "description": "When used instead of C(src), sets the contents of a file directly to the specified value.\nThis is for simple values, for anything complex or with formatting please switch to the M(ansible.windows.win_template) module.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "decrypt": {
          "aliases": [],
          "description": "This option controls the autodecryption of source files using vault.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Remote absolute path where the file should be copied to.\nIf C(src) is a directory, this must be a directory too.\nUse \\ for path separators or \\\\ when in \"double quotes\".\nIf C(dest) ends with \\ then source or the contents of source will be copied to the directory without renaming.\nIf C(dest) is a nonexistent path, it will only be created if C(dest) ends with \"/\" or \"\\\", or C(src) is a directory.\nIf C(src) and C(dest) are files and if the parent directory of C(dest) doesn't exist, then the task will fail.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "If set to C(yes), the file will only be transferred if the content is different than destination.\nIf set to C(no), the file will only be transferred if the destination does not exist.\nIf set to C(no), no checksuming of the content is performed which can help improve performance on larger files.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "local_follow": {
          "aliases": [],
          "description": "This flag indicates that filesystem links in the source tree, if they exist, should be followed.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "remote_src": {
          "aliases": [],
          "description": "If C(no), it will search for src at originating/controller machine.\nIf C(yes), it will go to the remote/target machine for the src.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Local path to a file to copy to the remote server; can be absolute or relative.\nIf path is a directory, it is copied (including the source folder name) recursively to C(dest).\nIf path is a directory and ends with \"/\", only the inside contents of that directory are copied to the destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied.\nIf path is a file and dest ends with \"\\\", the file is copied to the folder with the same filename.\nRequired unless using C(content).",
          "type": "path",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Copies files to remote locations on windows hosts"
    },
    "examples": "\n- name: Copy a single file\n  ansible.windows.win_copy:\n    src: /srv/myfiles/foo.conf\n    dest: C:\\Temp\\renamed-foo.conf\n\n- name: Copy a single file, but keep a backup\n  ansible.windows.win_copy:\n    src: /srv/myfiles/foo.conf\n    dest: C:\\Temp\\renamed-foo.conf\n    backup: yes\n\n- name: Copy a single file keeping the filename\n  ansible.windows.win_copy:\n    src: /src/myfiles/foo.conf\n    dest: C:\\Temp\\\n\n- name: Copy folder to C:\\Temp (results in C:\\Temp\\temp_files)\n  ansible.windows.win_copy:\n    src: files/temp_files\n    dest: C:\\Temp\n\n- name: Copy folder contents recursively\n  ansible.windows.win_copy:\n    src: files/temp_files/\n    dest: C:\\Temp\n\n- name: Copy a single file where the source is on the remote host\n  ansible.windows.win_copy:\n    src: C:\\Temp\\foo.txt\n    dest: C:\\ansible\\foo.txt\n    remote_src: yes\n\n- name: Copy a folder recursively where the source is on the remote host\n  ansible.windows.win_copy:\n    src: C:\\Temp\n    dest: C:\\ansible\n    remote_src: yes\n\n- name: Set the contents of a file\n  ansible.windows.win_copy:\n    content: abc123\n    dest: C:\\Temp\\foo.txt\n\n- name: Copy a single file as another user\n  ansible.windows.win_copy:\n    src: NuGet.config\n    dest: '%AppData%\\NuGet\\NuGet.config'\n  vars:\n    ansible_become_user: user\n    ansible_become_password: pass\n    # The tmp dir must be set when using win_copy as another user\n    # This ensures the become user will have permissions for the operation\n    # Make sure to specify a folder both the ansible_user and the become_user have access to (i.e not %TEMP% which is user specific and requires Admin)\n    ansible_remote_tmp: 'c:\\tmp'\n"
  },
  "ansible.windows.win_dns_client": {
    "doc": {
      "description": "The M(ansible.windows.win_dns_client) module configures the DNS client on Windows network adapters.",
      "has_action": false,
      "options": {
        "adapter_names": {
          "aliases": [],
          "description": "Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value).\nThe adapter name used is the connection caption in the Network Control Panel or the InterfaceAlias of C(Get-DnsClientServerAddress).",
          "type": "list",
          "required": true,
          "suboptions": {}
        },
        "dns_servers": {
          "aliases": [
            "ipv4_addresses",
            "ip_addresses",
            "addresses"
          ],
          "description": "Single or ordered list of DNS servers (IPv4 and IPv6 addresses) to configure for lookup.\nAn empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.\nIPv6 DNS servers can only be set on Windows Server 2012 or newer, older hosts can only set IPv4 addresses.",
          "type": "list",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Configures DNS lookup on Windows hosts"
    },
    "examples": "\n- name: Set a single address on the adapter named Ethernet\n  ansible.windows.win_dns_client:\n    adapter_names: Ethernet\n    dns_servers: 192.168.34.5\n\n- name: Set multiple lookup addresses on all visible adapters (usually physical adapters that are in the Up state), with debug logging to a file\n  ansible.windows.win_dns_client:\n    adapter_names: '*'\n    dns_servers:\n    - 192.168.34.5\n    - 192.168.34.6\n    log_path: C:\\dns_log.txt\n\n- name: Set IPv6 DNS servers on the adapter named Ethernet\n  ansible.windows.win_dns_client:\n    adapter_names: Ethernet\n    dns_servers:\n    - '2001:db8::2'\n    - '2001:db8::3'\n\n- name: Configure all adapters whose names begin with Ethernet to use DHCP-assigned DNS values\n  ansible.windows.win_dns_client:\n    adapter_names: 'Ethernet*'\n    dns_servers: []\n"
  },
  "ansible.windows.win_domain": {
    "doc": {
      "description": "Ensure that the domain named by C(dns_domain_name) exists and is reachable.\nIf the domain is not reachable, the domain is created in a new forest on the target Windows Server 2012R2+ host.\nThis module may require subsequent use of the M(ansible.windows.win_reboot) action if changes are made.",
      "has_action": false,
      "options": {
        "create_dns_delegation": {
          "aliases": [],
          "description": "Whether to create a DNS delegation that references the new DNS server that you install along with the domain controller.\nValid for Active Directory-integrated DNS only.\nThe default is computed automatically based on the environment.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "database_path": {
          "aliases": [],
          "description": "The path to a directory on a fixed disk of the Windows host where the domain database will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\NTDS).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "dns_domain_name": {
          "aliases": [],
          "description": "The DNS name of the domain which should exist and be reachable or reside on the target Windows host.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "domain_mode": {
          "aliases": [],
          "description": "Specifies the domain functional level of the first domain in the creation of a new forest.\nThe domain functional level cannot be lower than the forest functional level, but it can be higher.\nThe default is automatically computed and set.",
          "type": "str",
          "required": false,
          "choices": [
            "Win2003",
            "Win2008",
            "Win2008R2",
            "Win2012",
            "Win2012R2",
            "WinThreshold"
          ],
          "suboptions": {}
        },
        "domain_netbios_name": {
          "aliases": [],
          "description": "The NetBIOS name for the root domain in the new forest.\nFor NetBIOS names to be valid for use with this parameter they must be single label names of 15 characters or less, if not it will fail.\nIf this parameter is not set, then the default is automatically computed from the value of the I(domain_name) parameter.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "forest_mode": {
          "aliases": [],
          "description": "Specifies the forest functional level for the new forest.\nThe default forest functional level in Windows Server is typically the same as the version you are running.",
          "type": "str",
          "required": false,
          "choices": [
            "Win2003",
            "Win2008",
            "Win2008R2",
            "Win2012",
            "Win2012R2",
            "WinThreshold"
          ],
          "suboptions": {}
        },
        "install_dns": {
          "aliases": [],
          "description": "Whether to install the DNS service when creating the domain controller.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "log_path": {
          "aliases": [],
          "description": "Specifies the fully qualified, non-UNC path to a directory on a fixed disk of the local computer where the log file for this operation is written.\nIf not set then the default path is C(%SYSTEMROOT%\\NTDS).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "safe_mode_password": {
          "aliases": [],
          "description": "Safe mode password for the domain controller.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "sysvol_path": {
          "aliases": [],
          "description": "The path to a directory on a fixed disk of the Windows host where the Sysvol file will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\SYSVOL).",
          "type": "path",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Ensures the existence of a Windows domain"
    },
    "examples": "\n- name: Create new domain in a new forest on the target host\n  ansible.windows.win_domain:\n    dns_domain_name: ansible.vagrant\n    safe_mode_password: password123!\n\n- name: Create new Windows domain in a new forest with specific parameters\n  ansible.windows.win_domain:\n    create_dns_delegation: no\n    database_path: C:\\Windows\\NTDS\n    dns_domain_name: ansible.vagrant\n    domain_mode: Win2012R2\n    domain_netbios_name: ANSIBLE\n    forest_mode: Win2012R2\n    safe_mode_password: password123!\n    sysvol_path: C:\\Windows\\SYSVOL\n  register: domain_install\n"
  },
  "ansible.windows.win_domain_controller": {
    "doc": {
      "description": "Ensure that a Windows Server 2012+ host is configured as a domain controller or demoted to member server.\nThis module may require subsequent use of the M(ansible.windows.win_reboot) action if changes are made.",
      "has_action": false,
      "options": {
        "database_path": {
          "aliases": [],
          "description": "The path to a directory on a fixed disk of the Windows host where the domain database will be created..\nIf not set then the default path is C(%SYSTEMROOT%\\NTDS).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "dns_domain_name": {
          "aliases": [],
          "description": "When C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "domain_admin_password": {
          "aliases": [],
          "description": "Password for the specified C(domain_admin_user).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "domain_admin_user": {
          "aliases": [],
          "description": "Username of a domain admin for the target domain (necessary to promote or demote a domain controller).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "domain_log_path": {
          "aliases": [],
          "description": "Specified the fully qualified, non-UNC path to a directory on a fixed disk of the local computer that will contain the domain log files.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "install_dns": {
          "aliases": [],
          "description": "Whether to install the DNS service when creating the domain controller.\nIf not specified then the C(-InstallDns) option is not supplied to C(Install-ADDSDomainController) command, see U(https://docs.microsoft.com/en-us/powershell/module/addsdeployment/install-addsdomaincontroller).",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "install_media_path": {
          "aliases": [],
          "description": "The path to a directory on a fixed disk of the Windows host where the Install From Media C(IFC) data will be used.\nSee the L(Install using IFM guide,https://social.technet.microsoft.com/wiki/contents/articles/8630.active-directory-step-by-step-guide-to-install-an-additional-domain-controller-using-ifm.aspx) for more information.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "local_admin_password": {
          "aliases": [],
          "description": "Password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server)).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "log_path": {
          "aliases": [],
          "description": "The path to log any debug information when running the module.\nThis option is deprecated and should not be used, it will be removed on the major release after C(2022-07-01).\nThis does not relate to the C(-LogPath) paramter of the install controller cmdlet.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "read_only": {
          "aliases": [],
          "description": "Whether to install the domain controller as a read only replica for an existing domain.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "safe_mode_password": {
          "aliases": [],
          "description": "Safe mode password for the domain controller (required when C(state) is C(domain_controller)).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "site_name": {
          "aliases": [],
          "description": "Specifies the name of an existing site where you can place the new domain controller.\nThis option is required when I(read_only) is C(yes).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the target host should be a domain controller or a member server.",
          "type": "str",
          "required": true,
          "choices": [
            "domain_controller",
            "member_server"
          ],
          "suboptions": {}
        },
        "sysvol_path": {
          "aliases": [],
          "description": "The path to a directory on a fixed disk of the Windows host where the Sysvol folder will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\SYSVOL).",
          "type": "path",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage domain controller/member server state for a Windows host"
    },
    "examples": "\n- name: Ensure a server is a domain controller\n  ansible.windows.win_domain_controller:\n    dns_domain_name: ansible.vagrant\n    domain_admin_user: testguy@ansible.vagrant\n    domain_admin_password: password123!\n    safe_mode_password: password123!\n    state: domain_controller\n\n# note that without an action wrapper, in the case where a DC is demoted,\n# the task will fail with a 401 Unauthorized, because the domain credential\n# becomes invalid to fetch the final output over WinRM. This requires win_async\n# with credential switching (or other clever credential-switching\n# mechanism to get the output and trigger the required reboot)\n- name: Ensure a server is not a domain controller\n  ansible.windows.win_domain_controller:\n    domain_admin_user: testguy@ansible.vagrant\n    domain_admin_password: password123!\n    local_admin_password: password123!\n    state: member_server\n\n- name: Promote server as a read only domain controller\n  ansible.windows.win_domain_controller:\n    dns_domain_name: ansible.vagrant\n    domain_admin_user: testguy@ansible.vagrant\n    domain_admin_password: password123!\n    safe_mode_password: password123!\n    state: domain_controller\n    read_only: yes\n    site_name: London\n\n- name: Promote server with custom paths\n  ansible.windows.win_domain_controller:\n    dns_domain_name: ansible.vagrant\n    domain_admin_user: testguy@ansible.vagrant\n    domain_admin_password: password123!\n    safe_mode_password: password123!\n    state: domain_controller\n    sysvol_path: D:\\SYSVOL\n    database_path: D:\\NTDS\n    domain_log_path: D:\\NTDS\n  register: dc_promotion\n\n- name: Reboot after promotion\n  ansible.windows.win_reboot:\n  when: dc_promotion.reboot_required\n"
  },
  "ansible.windows.win_domain_membership": {
    "doc": {
      "description": "Manages domain membership or workgroup membership for a Windows host. Also supports hostname changes.\nThis module may require subsequent use of the M(ansible.windows.win_reboot) action if changes are made.",
      "has_action": false,
      "options": {
        "dns_domain_name": {
          "aliases": [],
          "description": "When C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "domain_admin_password": {
          "aliases": [],
          "description": "Password for the specified C(domain_admin_user).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "domain_admin_user": {
          "aliases": [],
          "description": "Username of a domain admin for the target domain (required to join or leave the domain).",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "domain_ou_path": {
          "aliases": [],
          "description": "The desired OU path for adding the computer object.\nThis is only used when adding the target host to a domain, if it is already a member then it is ignored.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "hostname": {
          "aliases": [],
          "description": "The desired hostname for the Windows host.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the target host should be a member of a domain or workgroup.",
          "type": "str",
          "required": false,
          "choices": [
            "domain",
            "workgroup"
          ],
          "suboptions": {}
        },
        "workgroup_name": {
          "aliases": [],
          "description": "When C(state) is C(workgroup), the name of the workgroup that the Windows host should be in.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage domain/workgroup membership for a Windows host"
    },
    "examples": "\n\n# host should be a member of domain ansible.vagrant; module will ensure the hostname is mydomainclient\n# and will use the passed credentials to join domain if necessary.\n# Ansible connection should use local credentials if possible.\n# If a reboot is required, the second task will trigger one and wait until the host is available.\n- hosts: winclient\n  gather_facts: no\n  tasks:\n  - ansible.windows.win_domain_membership:\n      dns_domain_name: ansible.vagrant\n      hostname: mydomainclient\n      domain_admin_user: testguy@ansible.vagrant\n      domain_admin_password: password123!\n      domain_ou_path: \"OU=Windows,OU=Servers,DC=ansible,DC=vagrant\"\n      state: domain\n    register: domain_state\n\n  - ansible.windows.win_reboot:\n    when: domain_state.reboot_required\n\n\n\n# Host should be in workgroup mywg- module will use the passed credentials to clean-unjoin domain if possible.\n# Ansible connection should use local credentials if possible.\n# The domain admin credentials can be sourced from a vault-encrypted variable\n- hosts: winclient\n  gather_facts: no\n  tasks:\n  - ansible.windows.win_domain_membership:\n      workgroup_name: mywg\n      domain_admin_user: '{{ win_domain_admin_user }}'\n      domain_admin_password: '{{ win_domain_admin_password }}'\n      state: workgroup\n"
  },
  "ansible.windows.win_dsc": {
    "doc": {
      "description": "Configures a resource using PowerShell DSC.\nRequires PowerShell version 5.0 or newer.\nMost of the options for this module are dynamic and will vary depending on the DSC Resource specified in I(resource_name).",
      "has_action": false,
      "notes": "By default there are a few builtin resources that come with PowerShell 5.0, See U(https://docs.microsoft.com/en-us/powershell/scripting/dsc/resources/resources) for more information on these resources.\nCustom DSC resources can be installed with M(community.windows.win_psmodule) using the I(name) option.\nThe DSC engine run's each task as the SYSTEM account, any resources that need to be accessed with a different account need to have C(PsDscRunAsCredential) set.\nTo see the valid options for a DSC resource, run the module with C(-vvv) to show the possible module invocation. Default values are not shown in this output but are applied within the DSC engine.\nThe DSC engine requires the HTTP WSMan listener to be online and its port configured as the default listener for HTTP. This is set up by default but if a custom HTTP port is used or only a HTTPS listener is present then the module will fail. See the examples for a way to check this out in PowerShell.\nThe Local Configuration Manager C(LCM) on the targeted host in question should be disabled to avoid any conflicts with resources being applied by this module. See U(https://devblogs.microsoft.com/powershell/invoking-powershell-dsc-resources-directly/) for more information on hwo to disable C(LCM).",
      "options": {
        "free_form": {
          "aliases": [],
          "description": "The M(ansible.windows.win_dsc) module takes in multiple free form options based on the DSC resource being invoked by I(resource_name).\nThere is no option actually named C(free_form) so see the examples.\nThis module will try and convert the option to the correct type required by the DSC resource and throw a warning if it fails.\nIf the type of the DSC resource option is a C(CimInstance) or C(CimInstance[]), this means the value should be a dictionary or list of dictionaries based on the values required by that option.\nIf the type of the DSC resource option is a C(PSCredential) then there needs to be 2 options set in the Ansible task definition suffixed with C(_username) and C(_password).\nIf the type of the DSC resource option is an array, then a list should be provided but a comma separated string also work. Use a list where possible as no escaping is required and it works with more complex types list C(CimInstance[]).\nIf the type of the DSC resource option is a C(DateTime), you should use a string in the form of an ISO 8901 string to ensure the exact date is used.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "module_version": {
          "aliases": [],
          "description": "Can be used to configure the exact version of the DSC resource to be invoked.\nUseful if the target node has multiple versions installed of the module containing the DSC resource.\nIf not specified, the module will follow standard PowerShell convention and use the highest version available.",
          "default": "latest",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "resource_name": {
          "aliases": [],
          "description": "The name of the DSC Resource to use.\nMust be accessible to PowerShell using any of the default paths.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Invokes a PowerShell DSC configuration"
    },
    "examples": "\n- name: Verify the WSMan HTTP listener is active and configured correctly\n  ansible.windows.win_shell: |\n    $port = (Get-Item -LiteralPath WSMan:\\localhost\\Client\\DefaultPorts\\HTTP).Value\n    $onlinePorts = @(Get-ChildItem -LiteralPath WSMan:\\localhost\\Listener |\n        Where-Object { 'Transport=HTTP' -in $_.Keys } |\n        Get-ChildItem |\n        Where-Object Name -eq Port |\n        Select-Object -ExpandProperty Value)\n\n    if ($port -notin $onlinePorts) {\n        \"The default client port $port is not set up as a WSMan HTTP listener, win_dsc will not work.\"\n    }\n\n- name: Extract zip file\n  ansible.windows.win_dsc:\n    resource_name: Archive\n    Ensure: Present\n    Path: C:\\Temp\\zipfile.zip\n    Destination: C:\\Temp\\Temp2\n\n- name: Install a Windows feature with the WindowsFeature resource\n  ansible.windows.win_dsc:\n    resource_name: WindowsFeature\n    Name: telnet-client\n\n- name: Edit HKCU reg key under specific user\n  ansible.windows.win_dsc:\n    resource_name: Registry\n    Ensure: Present\n    Key: HKEY_CURRENT_USER\\ExampleKey\n    ValueName: TestValue\n    ValueData: TestData\n    PsDscRunAsCredential_username: '{{ansible_user}}'\n    PsDscRunAsCredential_password: '{{ansible_password}}'\n  no_log: true\n\n- name: Create file with multiple attributes\n  ansible.windows.win_dsc:\n    resource_name: File\n    DestinationPath: C:\\ansible\\dsc\n    Attributes: # can also be a comma separated string, e.g. 'Hidden, System'\n    - Hidden\n    - System\n    Ensure: Present\n    Type: Directory\n\n- name: Call DSC resource with DateTime option\n  ansible.windows.win_dsc:\n    resource_name: DateTimeResource\n    DateTimeOption: '2019-02-22T13:57:31.2311892+00:00'\n\n# more complex example using custom DSC resource and dict values\n- name: Setup the xWebAdministration module\n  ansible.windows.win_psmodule:\n    name: xWebAdministration\n    state: present\n\n- name: Create IIS Website with Binding and Authentication options\n  ansible.windows.win_dsc:\n    resource_name: xWebsite\n    Ensure: Present\n    Name: DSC Website\n    State: Started\n    PhysicalPath: C:\\inetpub\\wwwroot\n    BindingInfo: # Example of a CimInstance[] DSC parameter (list of dicts)\n    - Protocol: https\n      Port: 1234\n      CertificateStoreName: MY\n      CertificateThumbprint: C676A89018C4D5902353545343634F35E6B3A659\n      HostName: DSCTest\n      IPAddress: '*'\n      SSLFlags: '1'\n    - Protocol: http\n      Port: 4321\n      IPAddress: '*'\n    AuthenticationInfo: # Example of a CimInstance DSC parameter (dict)\n      Anonymous: no\n      Basic: true\n      Digest: false\n      Windows: yes\n"
  },
  "ansible.windows.win_environment": {
    "doc": {
      "description": "Uses .net Environment to set or remove environment variables and can set at User, Machine or Process level.\nUser level environment variables will be set, but not available until the user has logged off and on again.",
      "has_action": false,
      "notes": "This module is best-suited for setting the entire value of an environment variable. For safe element-based management of path-like environment vars, use the M(ansible.windows.win_path) module.\nThis module does not broadcast change events. This means that the minority of windows applications which can have their environment changed without restarting will not be notified and therefore will need restarting to pick up new environment settings. User level environment variables will require the user to log out and in again before they become available.\nIn the return, C(before_value) and C(value) will be set to the last values when using I(variables). It's best to use C(values) in that case if you need to find a specific variable's before and after values.",
      "options": {
        "level": {
          "aliases": [],
          "description": "The level at which to set the environment variable.\nUse C(machine) to set for all users.\nUse C(user) to set for the current user that ansible is connected as.\nUse C(process) to set for the current process.  Probably not that useful.",
          "type": "str",
          "required": true,
          "choices": [
            "machine",
            "process",
            "user"
          ],
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of the environment variable. Required when I(state=absent).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Set to C(present) to ensure environment variable is set.\nSet to C(absent) to ensure it is removed.\nWhen using I(variables), do not set this option.",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "value": {
          "aliases": [],
          "description": "The value to store in the environment variable.\nMust be set when I(state=present) and cannot be an empty string.\nShould be omitted for I(state=absent) and I(variables).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "variables": {
          "aliases": [],
          "description": "A dictionary where multiple environment variables can be defined at once.\nNot valid when I(state) is set. Variables with a value will be set (C(present)) and variables with an empty value will be unset (C(absent)).\nI(level) applies to all vars defined this way.",
          "type": "dict",
          "required": false,
          "version_added": "1.3.0",
          "suboptions": {}
        }
      },
      "short_description": "Modify environment variables on windows hosts"
    },
    "examples": "\n- name: Set an environment variable for all users\n  ansible.windows.win_environment:\n    state: present\n    name: TestVariable\n    value: Test value\n    level: machine\n\n- name: Remove an environment variable for the current user\n  ansible.windows.win_environment:\n    state: absent\n    name: TestVariable\n    level: user\n\n- name: Set several variables at once\n  ansible.windows.win_environment:\n    level: machine\n    variables:\n      TestVariable: Test value\n      CUSTOM_APP_VAR: 'Very important value'\n      ANOTHER_VAR: '{{ my_ansible_var }}'\n\n- name: Set and remove multiple variables at once\n  ansible.windows.win_environment:\n    level: user\n    variables:\n      TestVariable: Test value\n      CUSTOM_APP_VAR: 'Very important value'\n      ANOTHER_VAR: '{{ my_ansible_var }}'\n      UNWANTED_VAR: ''  # < this will be removed\n"
  },
  "ansible.windows.win_feature": {
    "doc": {
      "description": "Installs or uninstalls Windows Roles or Features on Windows Server.\nThis module uses the Add/Remove-WindowsFeature Cmdlets on Windows 2008 R2 and Install/Uninstall-WindowsFeature Cmdlets on Windows 2012, which are not available on client os machines.",
      "has_action": false,
      "options": {
        "include_management_tools": {
          "aliases": [],
          "description": "Adds the corresponding management tools to the specified feature.\nNot supported in Windows 2008 R2 and will be ignored.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "include_sub_features": {
          "aliases": [],
          "description": "Adds all subfeatures of the specified feature.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Names of roles or features to install as a single feature or a comma-separated list of features.\nTo list all available features use the PowerShell command C(Get-WindowsFeature).",
          "type": "list",
          "required": true,
          "suboptions": {}
        },
        "source": {
          "aliases": [],
          "description": "Specify a source to install the feature from.\nNot supported in Windows 2008 R2 and will be ignored.\nCan either be C({driveletter}:\\sources\\sxs) or C(\\\\{IP}\\share\\sources\\sxs).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "State of the features or roles on the system.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Installs and uninstalls Windows Features on Windows Server"
    },
    "examples": "\n- name: Install IIS (Web-Server only)\n  ansible.windows.win_feature:\n    name: Web-Server\n    state: present\n\n- name: Install IIS (Web-Server and Web-Common-Http)\n  ansible.windows.win_feature:\n    name:\n    - Web-Server\n    - Web-Common-Http\n    state: present\n\n- name: Install NET-Framework-Core from file\n  ansible.windows.win_feature:\n    name: NET-Framework-Core\n    source: C:\\Temp\\iso\\sources\\sxs\n    state: present\n\n- name: Install IIS Web-Server with sub features and management tools\n  ansible.windows.win_feature:\n    name: Web-Server\n    state: present\n    include_sub_features: yes\n    include_management_tools: yes\n  register: win_feature\n\n- name: Reboot if installing Web-Server feature requires it\n  ansible.windows.win_reboot:\n  when: win_feature.reboot_required\n"
  },
  "ansible.windows.win_file": {
    "doc": {
      "description": "Creates (empty) files, updates file modification stamps of existing files, and can create or remove directories.\nUnlike M(ansible.builtin.file), does not modify ownership, permissions or manipulate links.\nFor non-Windows targets, use the M(ansible.builtin.file) module instead.",
      "has_action": false,
      "options": {
        "path": {
          "aliases": [
            "dest",
            "name"
          ],
          "description": "Path to the file being managed.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "If C(directory), all immediate subdirectories will be created if they do not exist.\nIf C(file), the file will NOT be created if it does not exist, see the M(ansible.windows.win_copy) or M(ansible.windows.win_template) module if you want that behavior.\nIf C(absent), directories will be recursively deleted, and files will be removed.\nIf C(touch), an empty file will be created if the C(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way C(touch) works from the command line).",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "directory",
            "file",
            "touch"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Creates, touches or removes files or directories"
    },
    "examples": "\n- name: Touch a file (creates if not present, updates modification time if present)\n  ansible.windows.win_file:\n    path: C:\\Temp\\foo.conf\n    state: touch\n\n- name: Remove a file, if present\n  ansible.windows.win_file:\n    path: C:\\Temp\\foo.conf\n    state: absent\n\n- name: Create directory structure\n  ansible.windows.win_file:\n    path: C:\\Temp\\folder\\subfolder\n    state: directory\n\n- name: Remove directory structure\n  ansible.windows.win_file:\n    path: C:\\Temp\n    state: absent\n"
  },
  "ansible.windows.win_find": {
    "doc": {
      "description": "Return a list of files based on specified criteria.\nMultiple criteria are AND'd together.\nFor non-Windows targets, use the M(ansible.builtin.find) module instead.",
      "has_action": false,
      "notes": "When scanning directories with a large number of files containing lots of data it is recommended to set C(get_checksum=false). This will speed up the time it takes to scan the folders as getting a checksum needs to read the contents of every file it returns.",
      "options": {
        "age": {
          "aliases": [],
          "description": "Select files or folders whose age is equal to or greater than the specified time.\nUse a negative age to find files equal to or less than the specified time.\nYou can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., \"2s\", \"10d\", 1w\").",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "age_stamp": {
          "aliases": [],
          "description": "Choose the file property against which we compare C(age).\nThe default attribute we compare with is the last modification time.",
          "default": "mtime",
          "type": "str",
          "required": false,
          "choices": [
            "atime",
            "ctime",
            "mtime"
          ],
          "suboptions": {}
        },
        "checksum_algorithm": {
          "aliases": [],
          "description": "Algorithm to determine the checksum of a file.\nWill throw an error if the host is unable to use specified algorithm.",
          "default": "sha1",
          "type": "str",
          "required": false,
          "choices": [
            "md5",
            "sha1",
            "sha256",
            "sha384",
            "sha512"
          ],
          "suboptions": {}
        },
        "file_type": {
          "aliases": [],
          "description": "Type of file to search for.",
          "default": "file",
          "type": "str",
          "required": false,
          "choices": [
            "directory",
            "file"
          ],
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "Set this to C(yes) to follow symlinks in the path.\nThis needs to be used in conjunction with C(recurse).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "get_checksum": {
          "aliases": [],
          "description": "Whether to return a checksum of the file in the return info (default sha1), use C(checksum_algorithm) to change from the default.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "hidden": {
          "aliases": [],
          "description": "Set this to include hidden files or folders.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "paths": {
          "aliases": [],
          "description": "List of paths of directories to search for files or folders in.\nThis can be supplied as a single path or a list of paths.",
          "type": "list",
          "required": true,
          "elements": "str",
          "suboptions": {}
        },
        "patterns": {
          "aliases": [
            "regex",
            "regexp"
          ],
          "description": "One or more (powershell or regex) patterns to compare filenames with.\nThe type of pattern matching is controlled by C(use_regex) option.\nThe patterns restrict the list of files or folders to be returned based on the filenames.\nFor a file to be matched it only has to match with one pattern in a list provided.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "recurse": {
          "aliases": [],
          "description": "Will recursively descend into the directory looking for files or folders.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "size": {
          "aliases": [],
          "description": "Select files or folders whose size is equal to or greater than the specified size.\nUse a negative value to find files equal to or less than the specified size.\nYou can specify the size with a suffix of the byte type i.e. kilo = k, mega = m...\nSize is not evaluated for symbolic links.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_regex": {
          "aliases": [],
          "description": "Will set patterns to run as a regex check if set to C(yes).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Return a list of files based on specific criteria"
    },
    "examples": "\n- name: Find files in path\n  ansible.windows.win_find:\n    paths: D:\\Temp\n\n- name: Find hidden files in path\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    hidden: yes\n\n- name: Find files in multiple paths\n  ansible.windows.win_find:\n    paths:\n    - C:\\Temp\n    - D:\\Temp\n\n- name: Find files in directory while searching recursively\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    recurse: yes\n\n- name: Find files in directory while following symlinks\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    recurse: yes\n    follow: yes\n\n- name: Find files with .log and .out extension using powershell wildcards\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    patterns: [ '*.log', '*.out' ]\n\n- name: Find files in path based on regex pattern\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    patterns: out_\\d{8}-\\d{6}.log\n\n- name: Find files older than 1 day\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    age: 86400\n\n- name: Find files older than 1 day based on create time\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    age: 86400\n    age_stamp: ctime\n\n- name: Find files older than 1 day with unit syntax\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    age: 1d\n\n- name: Find files newer than 1 hour\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    age: -3600\n\n- name: Find files newer than 1 hour with unit syntax\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    age: -1h\n\n- name: Find files larger than 1MB\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    size: 1048576\n\n- name: Find files larger than 1GB with unit syntax\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    size: 1g\n\n- name: Find files smaller than 1MB\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    size: -1048576\n\n- name: Find files smaller than 1GB with unit syntax\n  ansible.windows.win_find:\n    paths: D:\\Temp\n    size: -1g\n\n- name: Find folders/symlinks in multiple paths\n  ansible.windows.win_find:\n    paths:\n    - C:\\Temp\n    - D:\\Temp\n    file_type: directory\n\n- name: Find files and return SHA256 checksum of files found\n  ansible.windows.win_find:\n    paths: C:\\Temp\n    get_checksum: yes\n    checksum_algorithm: sha256\n\n- name: Find files and do not return the checksum\n  ansible.windows.win_find:\n    paths: C:\\Temp\n    get_checksum: no\n"
  },
  "ansible.windows.win_get_url": {
    "doc": {
      "description": "Downloads files from HTTP, HTTPS, or FTP to the remote server.\nThe remote server I(must) have direct access to the remote resource.\nFor non-Windows targets, use the M(ansible.builtin.get_url) module instead.",
      "has_action": false,
      "notes": "If your URL includes an escaped slash character (%2F) this module will convert it to a real slash. This is a result of the behaviour of the System.Uri class as described in L(the documentation,https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/network/schemesettings-element-uri-settings#remarks).",
      "options": {
        "checksum": {
          "aliases": [],
          "description": "If a I(checksum) is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully.\nThis option cannot be set with I(checksum_url).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "checksum_algorithm": {
          "aliases": [],
          "description": "Specifies the hashing algorithm used when calculating the checksum of the remote and destination file.",
          "default": "sha1",
          "type": "str",
          "required": false,
          "choices": [
            "md5",
            "sha1",
            "sha256",
            "sha384",
            "sha512"
          ],
          "suboptions": {}
        },
        "checksum_url": {
          "aliases": [],
          "description": "Specifies a URL that contains the checksum values for the resource at I(url).\nLike C(checksum), this is used to verify the integrity of the remote transfer.\nThis option cannot be set with I(checksum).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [],
          "description": "The path to the client certificate (.pfx) that is used for X509 authentication. This path can either be the path to the C(pfx) on the filesystem or the PowerShell certificate path C(Cert:\\CurrentUser\\My\\<thumbprint>).\nThe WinRM connection must be authenticated with C(CredSSP) or C(become) is used on the task if the certificate file is not password protected.\nOther authentication types can set I(client_cert_password) when the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "client_cert_password": {
          "aliases": [],
          "description": "The password for I(client_cert) if the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "The location to save the file at the URL.\nBe sure to include a filename and extension as appropriate.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "follow_redirects": {
          "aliases": [],
          "description": "Whether or the module should follow redirects.\nC(all) will follow all redirect.\nC(none) will not follow any redirect.\nC(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a C(GET) or C(HEAD) on the URI to which it is being redirected.\nWhen following a redirected URL, the C(Authorization) header and any credentials set will be dropped and not redirected.",
          "default": "safe",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "none",
            "safe"
          ],
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "If C(yes), will download the file every time and replace the file if the contents change. If C(no), will only download the file if it does not exist or the remote file has been modified more recently than the local file.\nThis works by sending an http HEAD request to retrieve last modified time of the requested resource, so for this to work, the remote web server must support HEAD requests.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "force_basic_auth": {
          "aliases": [],
          "description": "By default the authentication header is only sent when a webservice responses to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail.\nThis option forces the sending of the Basic authentication header upon the original request.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "Extra headers to set on the request.\nThis should be a dictionary where the key is the header name and the value is the value for that header.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "http_agent": {
          "aliases": [],
          "description": "Header to identify as, generally appears in web server logs.\nThis is set to the C(User-Agent) header on a HTTP request.",
          "default": "ansible-httpget",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "maximum_redirection": {
          "aliases": [],
          "description": "Specify how many times the module will redirect a connection to an alternative URI before the connection fails.\nIf set to C(0) or I(follow_redirects) is set to C(none), or C(safe) when not doing a C(GET) or C(HEAD) it prevents all redirection.",
          "default": "50",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "proxy_password": {
          "aliases": [],
          "description": "The password for I(proxy_username).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_url": {
          "aliases": [],
          "description": "An explicit proxy to use for the request.\nBy default, the request will use the IE defined proxy unless I(use_proxy) is set to C(no).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a proxy host protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nProxies that use C(Basic) auth will still require explicit credentials through the I(proxy_username) and I(proxy_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no proxy authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "proxy_username": {
          "aliases": [],
          "description": "The username to use for proxy authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "The full URL of a file to download.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "url_method": {
          "aliases": [
            "method"
          ],
          "description": "The HTTP Method of the request.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_password": {
          "aliases": [
            "password"
          ],
          "description": "The password for I(url_username).\nThe alias I(password) is deprecated and will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_timeout": {
          "aliases": [
            "timeout"
          ],
          "description": "Specifies how long the request can be pending before it times out (in seconds).\nSet to C(0) to specify an infinite timeout.",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "url_username": {
          "aliases": [
            "user",
            "username"
          ],
          "description": "The username to use for authentication.\nThe alias I(user) and I(username) is deprecated and will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a server protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nSites that use C(Basic) auth will still require explicit credentials through the I(url_username) and I(url_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "use_proxy": {
          "aliases": [],
          "description": "If C(no), it will not use the proxy defined in IE for the current user.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Downloads file from HTTP, HTTPS, or FTP to node"
    },
    "examples": "\n- name: Download earthrise.jpg to specified path\n  ansible.windows.win_get_url:\n    url: http://www.example.com/earthrise.jpg\n    dest: C:\\Users\\RandomUser\\earthrise.jpg\n\n- name: Download earthrise.jpg to specified path only if modified\n  ansible.windows.win_get_url:\n    url: http://www.example.com/earthrise.jpg\n    dest: C:\\Users\\RandomUser\\earthrise.jpg\n    force: no\n\n- name: Download earthrise.jpg to specified path through a proxy server.\n  ansible.windows.win_get_url:\n    url: http://www.example.com/earthrise.jpg\n    dest: C:\\Users\\RandomUser\\earthrise.jpg\n    proxy_url: http://10.0.0.1:8080\n    proxy_username: username\n    proxy_password: password\n\n- name: Download file from FTP with authentication\n  ansible.windows.win_get_url:\n    url: ftp://server/file.txt\n    dest: '%TEMP%\\ftp-file.txt'\n    url_username: ftp-user\n    url_password: ftp-password\n\n- name: Download src with sha256 checksum url\n  ansible.windows.win_get_url:\n    url: http://www.example.com/earthrise.jpg\n    dest: C:\\temp\\earthrise.jpg\n    checksum_url: http://www.example.com/sha256sum.txt\n    checksum_algorithm: sha256\n    force: True\n\n- name: Download src with sha256 checksum url\n  ansible.windows.win_get_url:\n    url: http://www.example.com/earthrise.jpg\n    dest: C:\\temp\\earthrise.jpg\n    checksum: a97e6837f60cec6da4491bab387296bbcd72bdba\n    checksum_algorithm: sha1\n    force: True\n"
  },
  "ansible.windows.win_group": {
    "doc": {
      "description": "Add and remove local groups.\nFor non-Windows targets, please use the M(ansible.builtin.group) module instead.",
      "has_action": false,
      "options": {
        "description": {
          "aliases": [],
          "description": "Description of the group.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the group.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Create or remove the group.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Add and remove local groups"
    },
    "examples": "\n- name: Create a new group\n  ansible.windows.win_group:\n    name: deploy\n    description: Deploy Group\n    state: present\n\n- name: Remove a group\n  ansible.windows.win_group:\n    name: deploy\n    state: absent\n"
  },
  "ansible.windows.win_group_membership": {
    "doc": {
      "description": "Allows the addition and removal of local, service and domain users, and domain groups from a local group.",
      "has_action": false,
      "options": {
        "members": {
          "aliases": [],
          "description": "A list of members to ensure are present/absent from the group.\nAccepts local users as .\\username, and SERVERNAME\\username.\nAccepts domain users and groups as DOMAIN\\username and username@DOMAIN.\nAccepts service users as NT AUTHORITY\\username.\nAccepts all local, domain and service user types as username, favoring domain lookups when in a domain.",
          "type": "list",
          "required": true,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the local group to manage membership on.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Desired state of the members in the group.\nWhen C(state) is C(pure), only the members specified will exist, and all other existing members not specified are removed.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present",
            "pure"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Manage Windows local group membership"
    },
    "examples": "\n- name: Add a local and domain user to a local group\n  ansible.windows.win_group_membership:\n    name: Remote Desktop Users\n    members:\n      - NewLocalAdmin\n      - DOMAIN\\TestUser\n    state: present\n\n- name: Remove a domain group and service user from a local group\n  ansible.windows.win_group_membership:\n    name: Backup Operators\n    members:\n      - DOMAIN\\TestGroup\n      - NT AUTHORITY\\SYSTEM\n    state: absent\n\n- name: Ensure only a domain user exists in a local group\n  ansible.windows.win_group_membership:\n    name: Remote Desktop Users\n    members:\n      - DOMAIN\\TestUser\n    state: pure\n"
  },
  "ansible.windows.win_hostname": {
    "doc": {
      "description": "Manages local Windows computer name.\nA reboot is required for the computer name to take effect.",
      "has_action": false,
      "options": {
        "name": {
          "aliases": [],
          "description": "The hostname to set for the computer.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Manages local Windows computer name"
    },
    "examples": "\n- name: Change the hostname to sample-hostname\n  ansible.windows.win_hostname:\n    name: sample-hostname\n  register: res\n\n- name: Reboot\n  ansible.windows.win_reboot:\n  when: res.reboot_required\n"
  },
  "ansible.windows.win_optional_feature": {
    "doc": {
      "description": "Install or uninstall optional Windows features on non-Server Windows.\nThis module uses the C(Enable-WindowsOptionalFeature) and C(Disable-WindowsOptionalFeature) cmdlets.",
      "has_action": false,
      "options": {
        "include_parent": {
          "aliases": [],
          "description": "Whether to enable the parent feature and the parent's dependencies.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name(s) of the feature to install.\nThis relates to C(FeatureName) in the Powershell cmdlet.\nTo list all available features use the PowerShell command C(Get-WindowsOptionalFeature).",
          "type": "list",
          "required": true,
          "elements": "str",
          "suboptions": {}
        },
        "source": {
          "aliases": [],
          "description": "Specify a source to install the feature from.\nCan either be C({driveletter}:\\sources\\sxs) or C(\\\\{IP}\\share\\sources\\sxs).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to ensure the feature is absent or present on the system.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Manage optional Windows features"
    },
    "examples": "\n- name: Install .Net 3.5\n  ansible.windows.win_optional_feature:\n    name: NetFx3\n    state: present\n\n- name: Install .Net 3.5 from source\n  ansible.windows.win_optional_feature:\n    name: NetFx3\n    source: \\\\share01\\win10\\sources\\sxs\n    state: present\n\n- name: Install Microsoft Subsystem for Linux\n  ansible.windows.win_optional_feature:\n    name: Microsoft-Windows-Subsystem-Linux\n    state: present\n  register: wsl_status\n\n- name: Reboot if installing Linux Subsytem as feature requires it\n  ansible.windows.win_reboot:\n  when: wsl_status.reboot_required\n\n- name: Install multiple features in one task\n  ansible.windows.win_optional_feature:\n    name:\n    - NetFx3\n    - Microsoft-Windows-Subsystem-Linux\n    state: present\n"
  },
  "ansible.windows.win_owner": {
    "doc": {
      "description": "Set owner of files or directories.",
      "has_action": false,
      "options": {
        "path": {
          "aliases": [],
          "description": "Path to be used for changing owner.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "recurse": {
          "aliases": [],
          "description": "Indicates if the owner should be changed recursively.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "user": {
          "aliases": [],
          "description": "Name to be used for changing owner.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Set owner"
    },
    "examples": "\n- name: Change owner of path\n  ansible.windows.win_owner:\n    path: C:\\apache\n    user: apache\n    recurse: yes\n\n- name: Set the owner of root directory\n  ansible.windows.win_owner:\n    path: C:\\apache\n    user: SYSTEM\n    recurse: no\n"
  },
  "ansible.windows.win_package": {
    "doc": {
      "description": "Installs or uninstalls software packages for Windows.\nSupports C(.exe), C(.msi), C(.msp), C(.appx), C(.appxbundle), C(.msix), and C(.msixbundle).\nThese packages can be sourced from the local file system, network file share or a url.\nSee I(provider) for more info on each package type that is supported.",
      "has_action": false,
      "notes": "When C(state=absent) and the product is an exe, the path may be different from what was used to install the package originally. If path is not set then the path used will be what is set under C(QuietUninstallString) or C(UninstallString) in the registry for that I(product_id).\nBy default all msi installs and uninstalls will be run with the arguments C(/log, /qn, /norestart).\nAll the installation checks under C(product_id) and C(creates_*) add together, if one fails then the program is considered to be absent.",
      "options": {
        "arguments": {
          "aliases": [],
          "description": "Any arguments the installer needs to either install or uninstall the package.\nIf the package is an MSI do not supply the C(/qn), C(/log) or C(/norestart) arguments.\nThis is only used for the C(msi), C(msp), and C(registry) providers.\nCan be a list of arguments and the module will escape the arguments as necessary, it is recommended to use a string when dealing with MSI packages due to the unique escaping issues with msiexec.\nWhen using a list of arguments each item in the list is considered to be a single argument. As such, if an argument in the list contains a space then Ansible will quote this to ensure that this is seen by Windows as a single argument. Should this behaviour not be what is required, the argument should be split into two separate list items. See the examples section for more detail.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "chdir": {
          "aliases": [],
          "description": "Set the specified path as the current working directory before installing or uninstalling a package.\nThis is only used for the C(msi), C(msp), and C(registry) providers.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [],
          "description": "The path to the client certificate (.pfx) that is used for X509 authentication. This path can either be the path to the C(pfx) on the filesystem or the PowerShell certificate path C(Cert:\\CurrentUser\\My\\<thumbprint>).\nThe WinRM connection must be authenticated with C(CredSSP) or C(become) is used on the task if the certificate file is not password protected.\nOther authentication types can set I(client_cert_password) when the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "client_cert_password": {
          "aliases": [],
          "description": "The password for I(client_cert) if the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates_path": {
          "aliases": [],
          "description": "Will check the existence of the path specified and use the result to determine whether the package is already installed.\nYou can use this in conjunction with C(product_id) and other C(creates_*).",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "creates_service": {
          "aliases": [],
          "description": "Will check the existing of the service specified and use the result to determine whether the package is already installed.\nYou can use this in conjunction with C(product_id) and other C(creates_*).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates_version": {
          "aliases": [],
          "description": "Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.\nC(creates_path) MUST be set and is a file.\nYou can use this in conjunction with C(product_id) and other C(creates_*).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "expected_return_code": {
          "aliases": [],
          "description": "One or more return codes from the package installation that indicates success.\nThe return codes are read as a signed integer, any values greater than 2147483647 need to be represented as the signed equivalent, i.e. C(4294967295) is C(-1).\nTo convert a unsigned number to the signed equivalent you can run \"[Int32](\"0x{0:X}\" -f ([UInt32]3221225477))\".\nA return code of C(3010) usually means that a reboot is required, the C(reboot_required) return value is set if the return code is C(3010).\nThis is only used for the C(msi), C(msp), and C(registry) providers.",
          "default": "[0, 3010]",
          "type": "list",
          "required": false,
          "elements": "int",
          "suboptions": {}
        },
        "follow_redirects": {
          "aliases": [],
          "description": "Whether or the module should follow redirects.\nC(all) will follow all redirect.\nC(none) will not follow any redirect.\nC(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a C(GET) or C(HEAD) on the URI to which it is being redirected.\nWhen following a redirected URL, the C(Authorization) header and any credentials set will be dropped and not redirected.",
          "default": "safe",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "none",
            "safe"
          ],
          "suboptions": {}
        },
        "force_basic_auth": {
          "aliases": [],
          "description": "By default the authentication header is only sent when a webservice responses to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail.\nThis option forces the sending of the Basic authentication header upon the original request.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "Extra headers to set on the request.\nThis should be a dictionary where the key is the header name and the value is the value for that header.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "http_agent": {
          "aliases": [],
          "description": "Header to identify as, generally appears in web server logs.\nThis is set to the C(User-Agent) header on a HTTP request.",
          "default": "ansible-httpget",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "log_path": {
          "aliases": [],
          "description": "Specifies the path to a log file that is persisted after a package is installed or uninstalled.\nThis is only used for the C(msi) or C(msp) provider.\nWhen omitted, a temporary log file is used instead for those providers.\nThis is only valid for MSI files, use C(arguments) for the C(registry) provider.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "maximum_redirection": {
          "aliases": [],
          "description": "Specify how many times the module will redirect a connection to an alternative URI before the connection fails.\nIf set to C(0) or I(follow_redirects) is set to C(none), or C(safe) when not doing a C(GET) or C(HEAD) it prevents all redirection.",
          "default": "50",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "password": {
          "aliases": [
            "user_password"
          ],
          "description": "The password for C(user_name), must be set when C(user_name) is.\nThis option is deprecated in favour of using become, see examples for more information. Will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Location of the package to be installed or uninstalled.\nThis package can either be on the local file system, network share or a url.\nWhen C(state=present), C(product_id) is not set and the path is a URL, this file will always be downloaded to a temporary directory for idempotency checks, otherwise the file will only be downloaded if the package has not been installed based on the C(product_id) checks.\nIf C(state=present) then this value MUST be set.\nIf C(state=absent) then this value does not need to be set if C(product_id) is.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "product_id": {
          "aliases": [
            "productid"
          ],
          "description": "The product id of the installed packaged.\nThis is used for checking whether the product is already installed and getting the uninstall information if C(state=absent).\nFor msi packages, this is the C(ProductCode) (GUID) of the package. This can be found under the same registry paths as the C(registry) provider.\nFor msp packages, this is the C(PatchCode) (GUID) of the package which can found under the C(Details -> Revision number) of the file's properties.\nFor msix packages, this is the C(Name) or C(PackageFullName) of the package found under the C(Get-AppxPackage) cmdlet.\nFor registry (exe) packages, this is the registry key name under the registry paths specified in I(provider).\nThis value is ignored if C(path) is set to a local accesible file path and the package is not an C(exe).\nThis SHOULD be set when the package is an C(exe), or the path is a url or a network share and credential delegation is not being used. The C(creates_*) options can be used instead but is not recommended.\nThe alias I(productid) is deprecated and will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "provider": {
          "aliases": [],
          "description": "Set the package provider to use when searching for a package.\nThe C(auto) provider will select the proper provider if I(path) otherwise it scans all the other providers based on the I(product_id).\nThe C(msi) provider scans for MSI packages installed on a machine wide and current user context based on the C(ProductCode) of the MSI.\nThe C(msix) provider is used to install C(.appx), C(.msix), C(.appxbundle), or C(.msixbundle) packages. These packages are only installed or removed on the current use. The host must be set to allow sideloaded apps or in developer mode. See the examples for how to enable this. If a package is already installed but C(path) points to an updated package, this will be installed over the top of the existing one.\nThe C(msp) provider scans for all MSP patches installed on a machine wide and current user context based on the C(PatchCode) of the MSP. A C(msp) will be applied or removed on all C(msi) products that it applies to and is installed. If the patch is obsoleted or superseded then no action will be taken.\nThe C(registry) provider is used for traditional C(exe) installers and uses the following registry path to determine if a product was installed; C(HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall), C(HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall), C(HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall), and C(HKCU:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall).",
          "default": "auto",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "msi",
            "msix",
            "msp",
            "registry"
          ],
          "suboptions": {}
        },
        "proxy_password": {
          "aliases": [],
          "description": "The password for I(proxy_username).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_url": {
          "aliases": [],
          "description": "An explicit proxy to use for the request.\nBy default, the request will use the IE defined proxy unless I(use_proxy) is set to C(no).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a proxy host protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nProxies that use C(Basic) auth will still require explicit credentials through the I(proxy_username) and I(proxy_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no proxy authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "proxy_username": {
          "aliases": [],
          "description": "The username to use for proxy authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [
            "ensure"
          ],
          "description": "Whether to install or uninstall the package.\nThe module uses I(product_id) to determine whether the package is installed or not.\nFor all providers but C(auto), the I(path) can be used for idempotency checks if it is locally accesible filesystem path.\nThe alias I(ensure) is deprecated and will be removed on the major release after C(2022-07-01).",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "url_method": {
          "aliases": [],
          "description": "The HTTP Method of the request.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_password": {
          "aliases": [],
          "description": "The password for I(url_username).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_timeout": {
          "aliases": [],
          "description": "Specifies how long the request can be pending before it times out (in seconds).\nSet to C(0) to specify an infinite timeout.",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "url_username": {
          "aliases": [],
          "description": "The username to use for authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a server protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nSites that use C(Basic) auth will still require explicit credentials through the I(url_username) and I(url_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "use_proxy": {
          "aliases": [],
          "description": "If C(no), it will not use the proxy defined in IE for the current user.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "username": {
          "aliases": [
            "user_name"
          ],
          "description": "Username of an account with access to the package if it is located on a file share.\nThis is only needed if the WinRM transport is over an auth method that does not support credential delegation like Basic or NTLM or become is not used.\nThis option is deprecated in favour of using become, see examples for more information. Will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "wait_for_children": {
          "aliases": [],
          "description": "The module will wait for the process it spawns to finish but any processes spawned in that child process as ignored.\nSet to C(yes) to wait for all descendent processes to finish before the module returns.\nThis is useful if the install/uninstaller is just a wrapper which then calls the actual installer as its own child process. When this option is C(yes) then the module will wait for both processes to finish before returning.\nThis should not be required for most installers and setting to C(yes) could result in the module not returning until the process it is waiting for has been stopped manually.\nRequires Windows Server 2012 or Windows 8 or newer to use.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.3.0",
          "suboptions": {}
        }
      },
      "short_description": "Installs/uninstalls an installable package"
    },
    "examples": "\n- name: Install the Visual C thingy\n  ansible.windows.win_package:\n    path: http://download.microsoft.com/download/1/6/B/16B06F60-3B20-4FF2-B699-5E9B7962F9AE/VSU_4/vcredist_x64.exe\n    product_id: '{CF2BEA3C-26EA-32F8-AA9B-331F7E34BA97}'\n    arguments: /install /passive /norestart\n\n- name: Install Visual C thingy with list of arguments instead of a string\n  ansible.windows.win_package:\n    path: http://download.microsoft.com/download/1/6/B/16B06F60-3B20-4FF2-B699-5E9B7962F9AE/VSU_4/vcredist_x64.exe\n    product_id: '{CF2BEA3C-26EA-32F8-AA9B-331F7E34BA97}'\n    arguments:\n    - /install\n    - /passive\n    - /norestart\n\n- name: Install MSBuild thingy with arguments split to prevent quotes\n  ansible.windows.win_package:\n    path: https://download.visualstudio.microsoft.com/download/pr/9665567e-f580-4acd-85f2-bc94a1db745f/vs_BuildTools.exe\n    product_id: '{D1437F51-786A-4F57-A99C-F8E94FBA1BD8}'\n    arguments:\n    - --norestart\n    - --passive\n    - --wait\n    - --add\n    - Microsoft.Net.Component.4.6.1.TargetingPack\n    - --add\n    - Microsoft.Net.Component.4.6.TargetingPack\n\n- name: Install Remote Desktop Connection Manager from msi with a permanent log\n  ansible.windows.win_package:\n    path: https://download.microsoft.com/download/A/F/0/AF0071F3-B198-4A35-AA90-C68D103BDCCF/rdcman.msi\n    product_id: '{0240359E-6A4C-4884-9E94-B397A02D893C}'\n    state: present\n    log_path: D:\\logs\\vcredist_x64-exe-{{lookup('pipe', 'date +%Y%m%dT%H%M%S')}}.log\n\n- name: Uninstall Remote Desktop Connection Manager\n  ansible.windows.win_package:\n    product_id: '{0240359E-6A4C-4884-9E94-B397A02D893C}'\n    state: absent\n\n- name: Install Remote Desktop Connection Manager locally omitting the product_id\n  ansible.windows.win_package:\n    path: C:\\temp\\rdcman.msi\n    state: present\n\n- name: Uninstall Remote Desktop Connection Manager from local MSI omitting the product_id\n  ansible.windows.win_package:\n    path: C:\\temp\\rdcman.msi\n    state: absent\n\n# 7-Zip exe doesn't use a guid for the Product ID\n- name: Install 7zip from a network share with specific credentials\n  ansible.windows.win_package:\n    path: \\\\domain\\programs\\7z.exe\n    product_id: 7-Zip\n    arguments: /S\n    state: present\n  become: yes\n  become_method: runas\n  become_flags: logon_type=new_credential logon_flags=netcredentials_only\n  vars:\n    ansible_become_user: DOMAIN\\User\n    ansible_become_password: Password\n\n- name: Install 7zip and use a file version for the installation check\n  ansible.windows.win_package:\n    path: C:\\temp\\7z.exe\n    creates_path: C:\\Program Files\\7-Zip\\7z.exe\n    creates_version: 16.04\n    state: present\n\n- name: Uninstall 7zip from the exe\n  ansible.windows.win_package:\n    path: C:\\Program Files\\7-Zip\\Uninstall.exe\n    product_id: 7-Zip\n    arguments: /S\n    state: absent\n\n- name: Uninstall 7zip without specifying the path\n  ansible.windows.win_package:\n    product_id: 7-Zip\n    arguments: /S\n    state: absent\n\n- name: Install application and override expected return codes\n  ansible.windows.win_package:\n    path: https://download.microsoft.com/download/1/6/7/167F0D79-9317-48AE-AEDB-17120579F8E2/NDP451-KB2858728-x86-x64-AllOS-ENU.exe\n    product_id: '{7DEBE4EB-6B40-3766-BB35-5CBBC385DA37}'\n    arguments: '/q /norestart'\n    state: present\n    expected_return_code: [0, 666, 3010]\n\n- name: Install a .msp patch\n  ansible.windows.win_package:\n    path: C:\\Patches\\Product.msp\n    state: present\n\n- name: Remove a .msp patch\n  ansible.windows.win_package:\n    product_id: '{AC76BA86-A440-FFFF-A440-0C13154E5D00}'\n    state: absent\n\n- name: Enable installation of 3rd party MSIX packages\n  ansible.windows.win_regedit:\n    path: HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock\n    name: AllowAllTrustedApps\n    data: 1\n    type: dword\n    state: present\n\n- name: Install an MSIX package for the current user\n  ansible.windows.win_package:\n    path: C:\\Installers\\Calculator.msix  # Can be .appx, .msixbundle, or .appxbundle\n    state: present\n\n- name: Uninstall an MSIX package using the product_id\n  ansible.windows.win_package:\n    product_id: InputApp\n    state: absent\n"
  },
  "ansible.windows.win_path": {
    "doc": {
      "description": "Allows element-based ordering, addition, and removal of Windows path environment variables.",
      "has_action": false,
      "notes": "This module is for modifying individual elements of path-like environment variables. For general-purpose management of other environment vars, use the M(ansible.windows.win_environment) module.\nThis module does not broadcast change events. This means that the minority of windows applications which can have their environment changed without restarting will not be notified and therefore will need restarting to pick up new environment settings.\nUser level environment variables will require an interactive user to log out and in again before they become available.",
      "options": {
        "elements": {
          "aliases": [],
          "description": "A single path element, or a list of path elements (ie, directories) to add or remove.\nWhen multiple elements are included in the list (and C(state) is C(present)), the elements are guaranteed to appear in the same relative order in the resultant path value.\nVariable expansions (eg, C(%VARNAME%)) are allowed, and are stored unexpanded in the target path element.\nAny existing path elements not mentioned in C(elements) are always preserved in their current order.\nNew path elements are appended to the path, and existing path elements may be moved closer to the end to satisfy the requested ordering.\nPaths are compared in a case-insensitive fashion, and trailing backslashes are ignored for comparison purposes. However, note that trailing backslashes in YAML require quotes.",
          "type": "list",
          "required": true,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Target path environment variable name.",
          "default": "PATH",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "scope": {
          "aliases": [],
          "description": "The level at which the environment variable specified by C(name) should be managed (either for the current user or global machine scope).",
          "default": "machine",
          "type": "str",
          "required": false,
          "choices": [
            "machine",
            "user"
          ],
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether the path elements specified in C(elements) should be present or absent.",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Manage Windows path environment variables"
    },
    "examples": "\n- name: Ensure that system32 and Powershell are present on the global system path, and in the specified order\n  ansible.windows.win_path:\n    elements:\n    - '%SystemRoot%\\system32'\n    - '%SystemRoot%\\system32\\WindowsPowerShell\\v1.0'\n\n- name: Ensure that C:\\Program Files\\MyJavaThing is not on the current user's CLASSPATH\n  ansible.windows.win_path:\n    name: CLASSPATH\n    elements: C:\\Program Files\\MyJavaThing\n    scope: user\n    state: absent\n"
  },
  "ansible.windows.win_ping": {
    "doc": {
      "description": "Checks management connectivity of a windows host.\nThis is NOT ICMP ping, this is just a trivial test module.\nFor non-Windows targets, use the M(ansible.builtin.ping) module instead.",
      "has_action": false,
      "options": {
        "data": {
          "aliases": [],
          "description": "Alternate data to return instead of 'pong'.\nIf this parameter is set to C(crash), the module will cause an exception.",
          "default": "pong",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "A windows version of the classic ping module"
    },
    "examples": "\n# Test connectivity to a windows host\n# ansible winserver -m ansible.windows.win_ping\n\n- name: Example from an Ansible Playbook\n  ansible.windows.win_ping:\n\n- name: Induce an exception to see what happens\n  ansible.windows.win_ping:\n    data: crash\n"
  },
  "ansible.windows.win_powershell": {
    "doc": {
      "description": "Runs a PowerShell script and outputs the data in a structured format.\nUse M(ansible.windows.win_command) or M(ansible.windows.win_shell) to run a tranditional PowerShell process with stdout, stderr, and rc results.",
      "has_action": false,
      "notes": "The module is set as failed when a terminating exception is throw, or C(error_action=stop) and a normal error record is raised.\nThe output values are processed using a custom filter and while it mostly matches the C(ConvertTo-Json) result the following value types are different.\nC(DateTime) will be an ISO 8601 string in UTC, C(DateTimeOffset) will have the offset as specified by the value.\nC(Enum) will contain a dictionary with C(Type), C(String), C(Value) being the type name, string representation and raw integer value respectively.\nC(Type) will contain a dictionary with C(Name), C(FullName), C(AssemblyQualifiedName), C(BaseType) being the type name, the type name including the namespace, the full assembly name the type was defined in and the base type it derives from.\nThe script has access to the C($Ansible) variable where it can set C(Result), C(Changed), C(Failed), or access C(Tmpdir).\nC($Ansible.Result) is a value that is returned back to the controller as is.\nC($Ansible.Changed) can be set to C(true) or C(false) to reflect whether the module made a change or not. By default this is set to C(true).\nC($Ansible.Failed) can be set to C(true) if the script wants to return the failure back to the controller.\nC($Ansible.Tmpdir) is the path to a temporary directory to use as a scratch location that is cleaned up after the module has finished.\nC($Ansible.Verbosity) reveals Ansible's verbosity level for this play. Allows the script to set VerbosePreference/DebugPreference based on verbosity. Added in C(1.9.0).\nAny host/console output like C(Write-Host) or C([Console]::WriteLine) is not considered an output object, they are returned as a string in I(host_out) and I(host_err).\nThe module will skip running the script when in check mode unless the script defines C([CmdletBinding(SupportsShouldProcess)]).",
      "options": {
        "arguments": {
          "aliases": [],
          "description": "A list of arguments to pass to I(executable) when running a script in another PowerShell process.\nThese are not arguments to pass to I(script), use I(parameters) for that purpose.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "chdir": {
          "aliases": [],
          "description": "The PowerShell location to set when starting the script.\nThis can be a location in any of the PowerShell providers.\nThe default location is dependent on many factors, if relative paths are used then set this option.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "depth": {
          "aliases": [],
          "description": "How deep the return values are serialized for C(result), C(output), and C(information[x].message_data).\nSetting this to a higher value can dramatically increase the amount of data that needs to be returned.",
          "default": "2",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "error_action": {
          "aliases": [],
          "description": "The C($ErrorActionPreference) to set before executing I(script).\nC(silently_continue) will ignore any errors and exceptions raised.\nC(continue) is the default behaviour in PowerShell, errors are present in the I(error) return value but only terminating exceptions will stop the script from continuing and set it as failed.\nC(stop) will treat errors like exceptions, will stop the script and set it as failed.",
          "default": "continue",
          "type": "str",
          "required": false,
          "choices": [
            "silently_continue",
            "continue",
            "stop"
          ],
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "A custom PowerShell executable to run the script in.\nWhen not defined the script will run in the current module PowerShell interpreter.\nBoth the remote PowerShell and the one specified by I(executable) must be running on PowerShell v5.1 or newer.\nSetting this value may change the values returned in the C(output) return value depending on the underlying .NET type.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "parameters": {
          "aliases": [],
          "description": "Parameters to pass into the script as key value pairs.\nThe key corresponds to the parameter name and the value is the value for that parameter.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "script": {
          "aliases": [],
          "description": "The PowerShell script to run.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Run PowerShell scripts",
      "version_added": "1.5.0"
    },
    "examples": "\n- name: Run basic PowerShell script\n  ansible.windows.win_powershell:\n    script: |\n      echo \"Hello World\"\n\n- name: Run PowerShell script with parameters\n  ansible.windows.win_powershell:\n    script: |\n      [CmdletBinding()]\n      param (\n          [String]\n          $Path,\n\n          [Switch]\n          $Force\n      )\n\n      New-Item -Path $Path -ItemType Direcotry -Force:$Force\n    parameters:\n      Path: C:\\temp\n      Force: true\n\n- name: Run PowerShell script that modifies the module changed result\n  ansible.windows.win_powershell:\n    script: |\n      if (Get-Service -Name test -ErrorAction SilentlyContinue) {\n          Remove-Service -Name test\n      }\n      else {\n          $Ansible.Changed = $false\n      }\n\n- name: Run PowerShell script in PowerShell 7\n  ansible.windows.win_powershell:\n    script: |\n      $PSVersionTable.PSVersion.Major\n    executable: pwsh.exe\n    arguments:\n    - -ExecutionPolicy\n    - ByPass\n  register: pwsh_output\n  failed_when:\n  - pwsh_output.output[0] != 7\n\n- name: Run code in check mode\n  ansible.windows.win_powershell:\n    script: |\n      [CmdletBinding(SupportsShouldProcess)]\n      param ()\n\n      # Use $Ansible to detect check mode\n      if ($Ansible.CheckMode) {\n          echo 'running in check mode'\n      }\n      else {\n          echo 'running in normal mode'\n      }\n\n      # Use builtin ShouldProcess (-WhatIf)\n      if ($PSCmdlet.ShouldProcess('target')) {\n          echo 'also running in normal mode'\n      }\n      else {\n          echo 'also running in check mode'\n      }\n  check_mode: yes\n\n- name: Return a failure back to Ansible\n  ansible.windows.win_powershell:\n    script: |\n      if (Test-Path C:\\bad.file) {\n          $Ansible.Failed = $true\n      }\n\n- name: Define when the script made a change or not\n  ansible.windows.win_powershell:\n    script: |\n      if ((Get-Item WSMan:\\localhost\\Service\\Auth\\Basic).Value -eq 'true') {\n          Set-Item WSMan:\\localhost\\Service\\Auth\\Basic -Value false\n      }\n      else {\n          $Ansible.Changed = $true\n      }\n\n- name: Define when to enable Verbose/Debug output\n  ansible.windows.win_powershell:\n    script: |\n      if ($Ansible.Verbosity -ge 3) {\n          $VerbosePreference = \"Continue\"\n      }\n      if ($Ansible.Verbosity -eq 5) {\n          $DebugPreference = \"Continue\"\n      }\n      Write-Output \"Hello World!\"\n      Write-Verbose \"Hello World!\"\n      Write-Debug \"Hello World!\"\n\n"
  },
  "ansible.windows.win_reboot": {
    "doc": {
      "description": "Reboot a Windows machine, wait for it to go down, come back up, and respond to commands.\nFor non-Windows targets, use the M(ansible.builtin.reboot) module instead.",
      "has_action": true,
      "notes": "If a shutdown was already scheduled on the system, M(ansible.windows.win_reboot) will abort the scheduled shutdown and enforce its own shutdown.\nBeware that when M(ansible.windows.win_reboot) returns, the Windows system may not have settled yet and some base services could be in limbo. This can result in unexpected behavior. Check the examples for ways to mitigate this. This has been slightly mitigated in the C(1.6.0) release of C(ansible.windows) but it is not guranteed to always wait until the logon prompt is shown.\nThe connection user must have the C(SeRemoteShutdownPrivilege) privilege enabled, see U(https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/force-shutdown-from-a-remote-system) for more information.",
      "options": {
        "boot_time_command": {
          "aliases": [],
          "description": "Command to run that returns a unique string indicating the last time the system was booted.\nSetting this to a command that has different output each time it is run will cause the task to fail.",
          "default": "(Get-CimInstance -ClassName Win32_OperatingSystem -Property LastBootUpTime).LastBootUpTime.ToFileTime()",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "connect_timeout": {
          "aliases": [
            "connect_timeout_sec"
          ],
          "description": "Maximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again.",
          "default": "5",
          "type": "float",
          "required": false,
          "suboptions": {}
        },
        "msg": {
          "aliases": [],
          "description": "Message to display to users.",
          "default": "Reboot initiated by Ansible",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "post_reboot_delay": {
          "aliases": [
            "post_reboot_delay_sec"
          ],
          "description": "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.\nThis is useful if you want wait for something to settle despite your connection already working.",
          "default": "0",
          "type": "float",
          "required": false,
          "suboptions": {}
        },
        "pre_reboot_delay": {
          "aliases": [
            "pre_reboot_delay_sec"
          ],
          "description": "Seconds to wait before reboot. Passed as a parameter to the reboot command.",
          "default": "2",
          "type": "float",
          "required": false,
          "suboptions": {}
        },
        "reboot_timeout": {
          "aliases": [
            "reboot_timeout_sec"
          ],
          "description": "Maximum seconds to wait for machine to re-appear on the network and respond to a test command.\nThis timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.",
          "default": "600",
          "type": "float",
          "required": false,
          "suboptions": {}
        },
        "test_command": {
          "aliases": [],
          "description": "Command to expect success for to determine the machine is ready for management.\nBy default this test command is a custom one to detect when the Windows Logon screen is up and ready to accept credentials. Using a custom command will replace this behaviour and just run the command specified.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Reboot a windows machine"
    },
    "examples": "\n- name: Reboot the machine with all defaults\n  ansible.windows.win_reboot:\n\n- name: Reboot a slow machine that might have lots of updates to apply\n  ansible.windows.win_reboot:\n    reboot_timeout: 3600\n\n# Install a Windows feature and reboot if necessary\n- name: Install IIS Web-Server\n  ansible.windows.win_feature:\n    name: Web-Server\n  register: iis_install\n\n- name: Reboot when Web-Server feature requires it\n  ansible.windows.win_reboot:\n  when: iis_install.reboot_required\n\n# One way to ensure the system is reliable, is to set WinRM to a delayed startup\n- name: Ensure WinRM starts when the system has settled and is ready to work reliably\n  ansible.windows.win_service:\n    name: WinRM\n    start_mode: delayed\n\n# Additionally, you can add a delay before running the next task\n- name: Reboot a machine that takes time to settle after being booted\n  ansible.windows.win_reboot:\n    post_reboot_delay: 120\n\n# Or you can make win_reboot validate exactly what you need to work before running the next task\n- name: Validate that the netlogon service has started, before running the next task\n  ansible.windows.win_reboot:\n    test_command: 'exit (Get-Service -Name Netlogon).Status -ne \"Running\"'\n"
  },
  "ansible.windows.win_reg_stat": {
    "doc": {
      "description": "Like M(ansible.windows.win_file), M(ansible.windows.win_reg_stat) will return whether the key/property exists.\nIt also returns the sub keys and properties of the key specified.\nIf specifying a property name through I(property), it will return the information specific for that property.",
      "has_action": false,
      "notes": "The C(properties) return value will contain an empty string key C(\"\") that refers to the key's C(Default) value. If the value has not been set then this key is not returned.",
      "options": {
        "name": {
          "aliases": [
            "entry",
            "value",
            "property"
          ],
          "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.\nSet to an empty string to target the registry key's C((Default)) property value.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "key"
          ],
          "description": "The full registry key path including the hive to search for.",
          "type": "str",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Get information about Windows registry keys"
    },
    "examples": "\n- name: Obtain information about a registry key using short form\n  ansible.windows.win_reg_stat:\n    path: HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n  register: current_version\n\n- name: Obtain information about a registry key property\n  ansible.windows.win_reg_stat:\n    path: HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n    name: CommonFilesDir\n  register: common_files_dir\n\n- name: Obtain the registry key's (Default) property\n  ansible.windows.win_reg_stat:\n    path: HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n    name: ''\n  register: current_version_default\n"
  },
  "ansible.windows.win_regedit": {
    "doc": {
      "description": "Add, modify or remove registry keys and values.\nMore information about the windows registry from Wikipedia U(https://en.wikipedia.org/wiki/Windows_Registry).",
      "has_action": false,
      "notes": "Check-mode C(-C/--check) and diff output C(-D/--diff) are supported, so that you can test every change against the active configuration before applying changes.\nBeware that some registry hives (C(HKEY_USERS) in particular) do not allow to create new registry paths in the root folder.",
      "options": {
        "data": {
          "aliases": [],
          "description": "Value of the registry entry C(name) in C(path).\nIf not specified then the value for the property will be null for the corresponding C(type).\nBinary and None data should be expressed in a yaml byte array or as comma separated hex values.\nAn easy way to generate this is to run C(regedit.exe) and use the I(export) option to save the registry values to a file.\nIn the exported file, binary value will look like C(hex:be,ef,be,ef), the C(hex:) prefix is optional.\nDWORD and QWORD values should either be represented as a decimal number or a hex value.\nMultistring values should be passed in as a list.\nSee the examples for more details on how to format this data.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "delete_key": {
          "aliases": [],
          "description": "When C(state) is 'absent' then this will delete the entire key.\nIf C(no) then it will only clear out the '(Default)' property for that key.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "hive": {
          "aliases": [],
          "description": "A path to a hive key like C:\\Users\\Default\\NTUSER.DAT to load in the registry.\nThis hive is loaded under the HKLM:\\ANSIBLE key which can then be used in I(name) like any other path.\nThis can be used to load the default user profile registry hive or any other hive saved as a file.\nUsing this function requires the user to have the C(SeRestorePrivilege) and C(SeBackupPrivilege) privileges enabled.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [
            "entry",
            "value"
          ],
          "description": "Name of the registry entry in the above C(path) parameters.\nIf not provided, or empty then the '(Default)' property for the key will be used.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "key"
          ],
          "description": "Name of the registry path.\nShould be in one of the following registry hives: HKCC, HKCR, HKCU, HKLM, HKU.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The state of the registry entry.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        },
        "type": {
          "aliases": [
            "datatype"
          ],
          "description": "The registry value data type.",
          "default": "string",
          "type": "str",
          "required": false,
          "choices": [
            "none",
            "binary",
            "dword",
            "expandstring",
            "multistring",
            "string",
            "qword"
          ],
          "suboptions": {}
        }
      },
      "short_description": "Add, change, or remove registry keys and values"
    },
    "examples": "\n- name: Create registry path MyCompany\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n\n- name: Add or update registry path MyCompany, with entry 'hello', and containing 'world'\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: world\n\n- name: Add or update registry path MyCompany, with dword entry 'hello', and containing 1337 as the decimal value\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: 1337\n    type: dword\n\n- name: Add or update registry path MyCompany, with dword entry 'hello', and containing 0xff2500ae as the hex value\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: 0xff2500ae\n    type: dword\n\n- name: Add or update registry path MyCompany, with binary entry 'hello', and containing binary data in hex-string format\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: hex:be,ef,be,ef,be,ef,be,ef,be,ef\n    type: binary\n\n- name: Add or update registry path MyCompany, with binary entry 'hello', and containing binary data in yaml format\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: [0xbe,0xef,0xbe,0xef,0xbe,0xef,0xbe,0xef,0xbe,0xef]\n    type: binary\n\n- name: Add or update registry path MyCompany, with expand string entry 'hello'\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: '%appdata%\\local'\n    type: expandstring\n\n- name: Add or update registry path MyCompany, with multi string entry 'hello'\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    data: ['hello', 'world']\n    type: multistring\n\n- name: Disable keyboard layout hotkey for all users (changes existing)\n  ansible.windows.win_regedit:\n    path: HKU:\\.DEFAULT\\Keyboard Layout\\Toggle\n    name: Layout Hotkey\n    data: 3\n    type: dword\n\n- name: Disable language hotkey for current users (adds new)\n  ansible.windows.win_regedit:\n    path: HKCU:\\Keyboard Layout\\Toggle\n    name: Language Hotkey\n    data: 3\n    type: dword\n\n- name: Remove registry path MyCompany (including all entries it contains)\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    state: absent\n    delete_key: yes\n\n- name: Clear the existing (Default) entry at path MyCompany\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    state: absent\n    delete_key: no\n\n- name: Remove entry 'hello' from registry path MyCompany\n  ansible.windows.win_regedit:\n    path: HKCU:\\Software\\MyCompany\n    name: hello\n    state: absent\n\n- name: Change default mouse trailing settings for new users\n  ansible.windows.win_regedit:\n    path: HKLM:\\ANSIBLE\\Control Panel\\Mouse\n    name: MouseTrails\n    data: 10\n    type: string\n    state: present\n    hive: C:\\Users\\Default\\NTUSER.dat\n"
  },
  "ansible.windows.win_service": {
    "doc": {
      "description": "Manage and query Windows services.\nFor non-Windows targets, use the M(ansible.builtin.service) module instead.",
      "has_action": false,
      "notes": "This module historically returning information about the service in its return values. These should be avoided in favour of the M(ansible.windows.win_service_info) module.\nMost of the options in this module are non-driver services that you can view in SCManager. While you can edit driver services, not all functionality may be available.\nThe user running the module must have the following access rights on the service to be able to use it with this module - C(SERVICE_CHANGE_CONFIG), C(SERVICE_ENUMERATE_DEPENDENTS), C(SERVICE_QUERY_CONFIG), C(SERVICE_QUERY_STATUS).\nChanging the state or removing the service will also require futher rights depending on what needs to be done.",
      "options": {
        "dependencies": {
          "aliases": [],
          "description": "A list of service dependencies to set for this particular service.\nThis should be a list of service names and not the display name of the service.\nThis works by C(dependency_action) to either add/remove or set the services in this list.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "dependency_action": {
          "aliases": [],
          "description": "Used in conjunction with C(dependency) to either add the dependencies to the existing service dependencies.\nRemove the dependencies to the existing dependencies.\nSet the dependencies to only the values in the list replacing the existing dependencies.",
          "default": "set",
          "type": "str",
          "required": false,
          "choices": [
            "add",
            "remove",
            "set"
          ],
          "suboptions": {}
        },
        "description": {
          "aliases": [],
          "description": "The description to set for the service.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "desktop_interact": {
          "aliases": [],
          "description": "Whether to allow the service user to interact with the desktop.\nThis can only be set to C(yes) when using the C(LocalSystem) username.\nThis can only be set to C(yes) when the I(service_type) is C(win32_own_process) or C(win32_share_process).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "display_name": {
          "aliases": [],
          "description": "The display name to set for the service.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "error_control": {
          "aliases": [],
          "description": "The severity of the error and action token if the service fails to start.\nA new service defaults to C(normal).\nC(critical) will log the error and restart the system with the last-known good configuration. If the startup fails on reboot then the system will fail to operate.\nC(ignore) ignores the error.\nC(normal) logs the error in the event log but continues.\nC(severe) is like C(critical) but a failure on the last-known good configuration reboot startup will be ignored.",
          "type": "str",
          "required": false,
          "choices": [
            "critical",
            "ignore",
            "normal",
            "severe"
          ],
          "suboptions": {}
        },
        "failure_actions": {
          "aliases": [],
          "description": "A list of failure actions the service controller should take on each failure of a service.\nThe service manager will run the actions from first to last defined until the service starts. If I(failure_reset_period_sec) has been exceeded then the failure actions will restart from the beginning.\nIf all actions have been performed the the service manager will repeat the last service defined.\nThe existing actions will be replaced with the list defined in the task if there is a mismatch with any of them.\nSet to an empty list to delete all failure actions on a service otherwise an omitted or null value preserves the existing actions on the service.",
          "type": "list",
          "required": false,
          "elements": "dict",
          "suboptions": {
            "delay_ms": {
              "aliases": [
                "delay"
              ],
              "description": "The time to wait, in milliseconds, before performing the specified action.",
              "default": "0",
              "type": "raw",
              "required": false,
              "suboptions": {}
            },
            "type": {
              "aliases": [],
              "description": "The action to be performed.\nC(none) will perform no action, when used this should only be set as the last action.\nC(reboot) will reboot the host, when used this should only be set as the last action as the reboot will reset the action list back to the beginning.\nC(restart) will restart the service.\nC(run_command) will run the command specified by I(failure_command).",
              "type": "str",
              "required": true,
              "choices": [
                "none",
                "reboot",
                "restart",
                "run_command"
              ],
              "suboptions": {}
            }
          }
        },
        "failure_actions_on_non_crash_failure": {
          "aliases": [],
          "description": "Controls whether failure actions will be performed on non crash failures or not.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "failure_command": {
          "aliases": [],
          "description": "The command to run for a C(run_command) failure action.\nSet to an empty string to remove the command.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "failure_reboot_msg": {
          "aliases": [],
          "description": "The message to be broadcast to users logged on the host for a C(reboot) failure action.\nSet to an empty string to remove the message.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "failure_reset_period_sec": {
          "aliases": [
            "failure_reset_period"
          ],
          "description": "The time in seconds after which the failure action list resets back to the start of the list if there are no failures.\nTo set this value, I(failure_actions) must have at least 1 action present.\nSpecify C('0xFFFFFFFF') to set an infinite reset period.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "force_dependent_services": {
          "aliases": [],
          "description": "If C(yes), stopping or restarting a service with dependent services will force the dependent services to stop or restart also.\nIf C(no), stopping or restarting a service with dependent services may fail.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "load_order_group": {
          "aliases": [],
          "description": "The name of the load ordering group of which this service is a member.\nSpecify an empty string to remove the existing load order group of a service.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the service.\nIf only the name parameter is specified, the module will report on whether the service exists or not without making any changes.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "The password to set the service to start as.\nThis and the C(username) argument should be supplied together when using a local or domain account.\nIf omitted then the password will continue to use the existing value password set.\nIf specifying C(LocalSystem), C(NetworkService), C(LocalService), the C(NT SERVICE), or a gMSA this field can be omitted as those accounts have no password.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The path to the executable to set for the service.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "pre_shutdown_timeout_ms": {
          "aliases": [
            "pre_shutdown_timeout"
          ],
          "description": "The time in which the service manager waits after sending a preshutdown notification to the service until it proceeds to continue with the other shutdown actions.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "required_privileges": {
          "aliases": [],
          "description": "A list of privileges the service must have when starting up.\nWhen set the service will only have the privileges specified on its access token.\nThe I(username) of the service must already have the privileges assigned.\nThe existing privileges will be replace with the list defined in the task if there is a mismatch with any of them.\nSet to an empty list to remove all required privileges, otherwise an omitted or null value will keep the existing privileges.\nSee L(privilege text constants,https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) for a list of privilege constants that can be used.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "service_type": {
          "aliases": [],
          "description": "The type of service.\nThe default type of a new service is C(win32_own_process).\nI(desktop_interact) can only be set if the service type is C(win32_own_process) or C(win32_share_process).",
          "type": "str",
          "required": false,
          "choices": [
            "user_own_process",
            "user_share_process",
            "win32_own_process",
            "win32_share_process"
          ],
          "suboptions": {}
        },
        "sid_info": {
          "aliases": [],
          "description": "Used to define the behaviour of the service's access token groups.\nC(none) will not add any groups to the token.\nC(restricted) will add the C(NT SERVICE\\<service name>) SID to the access token's groups and restricted groups.\nC(unrestricted) will add the C(NT SERVICE\\<service name>) SID to the access token's groups.",
          "type": "str",
          "required": false,
          "choices": [
            "none",
            "restricted",
            "unrestricted"
          ],
          "suboptions": {}
        },
        "start_mode": {
          "aliases": [],
          "description": "Set the startup type for the service.\nA newly created service will default to C(auto).",
          "type": "str",
          "required": false,
          "choices": [
            "auto",
            "delayed",
            "disabled",
            "manual"
          ],
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "The desired state of the service.\nC(started)/C(stopped)/C(absent)/C(paused) are idempotent actions that will not run commands unless necessary.\nC(restarted) will always bounce the service.\nOnly services that support the paused state can be paused, you can check the return value C(can_pause_and_continue).\nYou can only pause a service that is already started.\nA newly created service will default to C(stopped).",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "paused",
            "started",
            "stopped",
            "restarted"
          ],
          "suboptions": {}
        },
        "update_password": {
          "aliases": [],
          "description": "When set to C(always) and I(password) is set, the module will always report a change and set the password.\nSet to C(on_create) to only set the password if the module needs to create the service.\nIf I(username) was specified and the service changed to that username then I(password) will also be changed if specified.\nThe current default is C(on_create) but this behaviour may change in the future, it is best to be explicit here.",
          "type": "str",
          "required": false,
          "choices": [
            "always",
            "on_create"
          ],
          "suboptions": {}
        },
        "username": {
          "aliases": [],
          "description": "The username to set the service to start as.\nCan also be set to C(LocalSystem) or C(SYSTEM) to use the SYSTEM account.\nA newly created service will default to C(LocalSystem).\nIf using a custom user account, it must have the C(SeServiceLogonRight) granted to be able to start up. You can use the M(ansible.windows.win_user_right) module to grant this user right for you.\nSet to C(NT SERVICE\\service name) to run as the NT SERVICE account for that service.\nThis can also be a gMSA in the form C(DOMAIN\\gMSA$).",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manage and query Windows services"
    },
    "examples": "\n- name: Restart a service\n  ansible.windows.win_service:\n    name: spooler\n    state: restarted\n\n- name: Set service startup mode to auto and ensure it is started\n  ansible.windows.win_service:\n    name: spooler\n    start_mode: auto\n    state: started\n\n- name: Pause a service\n  ansible.windows.win_service:\n    name: Netlogon\n    state: paused\n\n- name: Ensure that WinRM is started when the system has settled\n  ansible.windows.win_service:\n    name: WinRM\n    start_mode: delayed\n\n# A new service will also default to the following values:\n# - username: LocalSystem\n# - state: stopped\n# - start_mode: auto\n- name: Create a new service\n  ansible.windows.win_service:\n    name: service name\n    path: C:\\temp\\test.exe\n\n- name: Create a new service with extra details\n  ansible.windows.win_service:\n    name: service name\n    path: C:\\temp\\test.exe\n    display_name: Service Name\n    description: A test service description\n\n- name: Remove a service\n  ansible.windows.win_service:\n    name: service name\n    state: absent\n\n# This is required to be set for non-service accounts that need to run as a service\n- name: Grant domain account the SeServiceLogonRight user right\n  ansible.windows.win_user_right:\n    name: SeServiceLogonRight\n    users:\n    - DOMAIN\\User\n    action: add\n\n- name: Set the log on user to a domain account\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: DOMAIN\\User\n    password: Password\n\n- name: Set the log on user to a local account\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: .\\Administrator\n    password: Password\n\n- name: Set the log on user to Local System\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: SYSTEM\n\n- name: Set the log on user to Local System and allow it to interact with the desktop\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: SYSTEM\n    desktop_interact: yes\n\n- name: Set the log on user to Network Service\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: NT AUTHORITY\\NetworkService\n\n- name: Set the log on user to Local Service\n  ansible.windows.win_service:\n    name: service name\n    state: restarted\n    username: NT AUTHORITY\\LocalService\n\n- name: Set the log on user as the services' virtual account\n  ansible.windows.win_service:\n    name: service name\n    username: NT SERVICE\\service name\n\n- name: Set the log on user as a gMSA\n  ansible.windows.win_service:\n    name: service name\n    username: DOMAIN\\gMSA$  # The end $ is important and should be set for all gMSA\n\n- name: Set dependencies to ones only in the list\n  ansible.windows.win_service:\n    name: service name\n    dependencies: [ service1, service2 ]\n\n- name: Add dependencies to existing dependencies\n  ansible.windows.win_service:\n    name: service name\n    dependencies: [ service1, service2 ]\n    dependency_action: add\n\n- name: Remove dependencies from existing dependencies\n  ansible.windows.win_service:\n    name: service name\n    dependencies:\n    - service1\n    - service2\n    dependency_action: remove\n\n- name: Set required privileges for a service\n  ansible.windows.win_service:\n    name: service name\n    username: NT SERVICE\\LocalService\n    required_privileges:\n    - SeBackupPrivilege\n    - SeRestorePrivilege\n\n- name: Remove all required privileges for a service\n  ansible.windows.win_service:\n    name: service name\n    username: NT SERVICE\\LocalService\n    required_privileges: []\n\n- name: Set failure actions for a service with no reset period\n  ansible.windows.win_service:\n    name: service name\n    failure_actions:\n    - type: restart\n    - type: run_command\n      delay_ms: 1000\n    - type: restart\n      delay_ms: 5000\n    - type: reboot\n    failure_command: C:\\Windows\\System32\\cmd.exe /c mkdir C:\\temp\n    failure_reboot_msg: Restarting host because service name has failed\n    failure_reset_period_sec: '0xFFFFFFFF'\n\n- name: Set only 1 failure action without a repeat of the last action\n  ansible.windows.win_service:\n    name: service name\n    failure_actions:\n    - type: restart\n      delay_ms: 5000\n    - type: none\n\n- name: Remove failure action information\n  ansible.windows.win_service:\n    name: service name\n    failure_actions: []\n    failure_command: ''  # removes the existing command\n    failure_reboot_msg: ''  # removes the existing reboot msg\n"
  },
  "ansible.windows.win_service_info": {
    "doc": {
      "description": "Gather information about all or a specific installed Windows service(s).",
      "has_action": false,
      "options": {
        "name": {
          "aliases": [],
          "description": "If specified, this is used to match the C(name) or C(display_name) of the Windows service to get the info for.\nCan be a wildcard to match multiple services but the wildcard will only be matched on the C(name) of the service and not C(display_name).\nIf omitted then all services will returned.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Gather information about Windows services"
    },
    "examples": "\n- name: Get info for all installed services\n  ansible.windows.win_service_info:\n  register: service_info\n\n- name: Get info for a single service\n  ansible.windows.win_service_info:\n    name: WinRM\n  register: service_info\n\n- name: Get info for a service using its display name\n  ansible.windows.win_service_info:\n    name: Windows Remote Management (WS-Management)\n\n- name: Find all services that start with 'win'\n  ansible.windows.win_service_info:\n    name: win*\n"
  },
  "ansible.windows.win_share": {
    "doc": {
      "description": "Add, modify or remove Windows share and set share permissions.",
      "has_action": false,
      "options": {
        "caching_mode": {
          "aliases": [],
          "description": "Set the CachingMode for this share.",
          "default": "Manual",
          "type": "str",
          "required": false,
          "choices": [
            "BranchCache",
            "Documents",
            "Manual",
            "None",
            "Programs",
            "Unknown"
          ],
          "suboptions": {}
        },
        "change": {
          "aliases": [],
          "description": "Specify user list that should get read and write access on share, separated by comma.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "deny": {
          "aliases": [],
          "description": "Specify user list that should get no access, regardless of implied access on share, separated by comma.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "description": {
          "aliases": [],
          "description": "Share description.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "encrypt": {
          "aliases": [],
          "description": "Sets whether to encrypt the traffic to the share or not.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "full": {
          "aliases": [],
          "description": "Specify user list that should get full access on share, separated by comma.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "list": {
          "aliases": [],
          "description": "Specify whether to allow or deny file listing, in case user has no permission on share. Also known as Access-Based Enumeration.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Share name.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "Share directory.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "read": {
          "aliases": [],
          "description": "Specify user list that should get read access on share, separated by comma.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "rule_action": {
          "aliases": [],
          "description": "Whether to add or set (replace) access control entries.",
          "default": "set",
          "type": "str",
          "required": false,
          "choices": [
            "set",
            "add"
          ],
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Specify whether to add C(present) or remove C(absent) the specified share.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present"
          ],
          "suboptions": {}
        }
      },
      "requirements": [
        "As this module used newer cmdlets like New-SmbShare this can only run on Windows 8 / Windows 2012 or newer.",
        "This is due to the reliance on the WMI provider MSFT_SmbShare U(https://msdn.microsoft.com/en-us/library/hh830471) which was only added with these Windows releases."
      ],
      "short_description": "Manage Windows shares"
    },
    "examples": "\n- name: Add secret share\n  ansible.windows.win_share:\n    name: internal\n    description: top secret share\n    path: C:\\shares\\internal\n    list: no\n    full: Administrators,CEO\n    read: HR-Global\n    deny: HR-External\n\n- name: Add public company share\n  ansible.windows.win_share:\n    name: company\n    description: top secret share\n    path: C:\\shares\\company\n    list: yes\n    full: Administrators,CEO\n    read: Global\n\n- name: Remove previously added share\n  ansible.windows.win_share:\n    name: internal\n    state: absent\n"
  },
  "ansible.windows.win_shell": {
    "doc": {
      "description": "The M(ansible.windows.win_shell) module takes the command name followed by a list of space-delimited arguments. It is similar to the M(ansible.windows.win_command) module, but runs the command via a shell (defaults to PowerShell) on the target host.\nFor non-Windows targets, use the M(ansible.builtin.shell) module instead.",
      "has_action": false,
      "notes": "If you want to run an executable securely and predictably, it may be better to use the M(ansible.windows.win_command) module instead. Best practices when writing playbooks will follow the trend of using M(ansible.windows.win_command) unless C(win_shell) is explicitly required. When running ad-hoc commands, use your best judgement.\nWinRM will not return from a command execution until all child processes created have exited. Thus, it is not possible to use M(ansible.windows.win_shell) to spawn long-running child or background processes. Consider creating a Windows service for managing background processes. - Consider using M(ansible.windows.win_powershell) if you want to capture the output from the PowerShell script as structured objects.",
      "options": {
        "chdir": {
          "aliases": [],
          "description": "Set the specified path as the current working directory before executing a command",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "executable": {
          "aliases": [],
          "description": "Change the shell used to execute the command (eg, C(cmd)).\nThe target shell must accept a C(/c) parameter followed by the raw command line to be executed.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "free_form": {
          "aliases": [],
          "description": "The M(ansible.windows.win_shell) module takes a free form command to run.\nThere is no parameter actually named 'free form'. See the examples!",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "no_profile": {
          "aliases": [],
          "description": "Do not load the user profile before running a command. This is only valid when using PowerShell as the executable.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "output_encoding_override": {
          "aliases": [],
          "description": "This option overrides the encoding of stdout/stderr output.\nYou can use this option when you need to run a command which ignore the console's codepage.\nYou should only need to use this option in very rare circumstances.\nThis value can be any valid encoding C(Name) based on the output of C([System.Text.Encoding]::GetEncodings()). See U(https://docs.microsoft.com/dotnet/api/system.text.encoding.getencodings).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "stdin": {
          "aliases": [],
          "description": "Set the stdin of the command directly to the specified value.",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Execute shell commands on target hosts"
    },
    "examples": "\n- name: Execute a command in the remote shell, stdout goes to the specified file on the remote\n  ansible.windows.win_shell: C:\\somescript.ps1 >> C:\\somelog.txt\n\n- name: Change the working directory to somedir/ before executing the command\n  ansible.windows.win_shell: C:\\somescript.ps1 >> C:\\somelog.txt\n  args:\n    chdir: C:\\somedir\n\n- name: Run a command with an idempotent check on what it creates, will only run when somedir/somelog.txt does not exist\n  ansible.windows.win_shell: C:\\somescript.ps1 >> C:\\somelog.txt\n  args:\n    chdir: C:\\somedir\n    creates: C:\\somelog.txt\n\n- name: Run a command under a non-Powershell interpreter (cmd in this case)\n  ansible.windows.win_shell: echo %HOMEDIR%\n  args:\n    executable: cmd\n  register: homedir_out\n\n- name: Run multi-lined shell commands\n  ansible.windows.win_shell: |\n    $value = Test-Path -Path C:\\temp\n    if ($value) {\n        Remove-Item -Path C:\\temp -Force\n    }\n    New-Item -Path C:\\temp -ItemType Directory\n\n- name: Retrieve the input based on stdin\n  ansible.windows.win_shell: '$string = [Console]::In.ReadToEnd(); Write-Output $string.Trim()'\n  args:\n    stdin: Input message\n"
  },
  "ansible.windows.win_stat": {
    "doc": {
      "description": "Returns information about a Windows file.\nFor non-Windows targets, use the M(ansible.builtin.stat) module instead.",
      "has_action": false,
      "options": {
        "checksum_algorithm": {
          "aliases": [],
          "description": "Algorithm to determine checksum of file.\nWill throw an error if the host is unable to use specified algorithm.",
          "default": "sha1",
          "type": "str",
          "required": false,
          "choices": [
            "md5",
            "sha1",
            "sha256",
            "sha384",
            "sha512"
          ],
          "suboptions": {}
        },
        "follow": {
          "aliases": [],
          "description": "Whether to follow symlinks or junction points.\nIn the case of C(path) pointing to another link, then that will be followed until no more links are found.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "get_checksum": {
          "aliases": [],
          "description": "Whether to return a checksum of the file (default sha1)",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [
            "dest",
            "name"
          ],
          "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted.",
          "type": "path",
          "required": true,
          "suboptions": {}
        }
      },
      "short_description": "Get information about Windows files"
    },
    "examples": "\n- name: Obtain information about a file\n  ansible.windows.win_stat:\n    path: C:\\foo.ini\n  register: file_info\n\n- name: Obtain information about a folder\n  ansible.windows.win_stat:\n    path: C:\\bar\n  register: folder_info\n\n- name: Get MD5 checksum of a file\n  ansible.windows.win_stat:\n    path: C:\\foo.ini\n    get_checksum: yes\n    checksum_algorithm: md5\n  register: md5_checksum\n\n- debug:\n    var: md5_checksum.stat.checksum\n\n- name: Get SHA1 checksum of file\n  ansible.windows.win_stat:\n    path: C:\\foo.ini\n    get_checksum: yes\n  register: sha1_checksum\n\n- debug:\n    var: sha1_checksum.stat.checksum\n\n- name: Get SHA256 checksum of file\n  ansible.windows.win_stat:\n    path: C:\\foo.ini\n    get_checksum: yes\n    checksum_algorithm: sha256\n  register: sha256_checksum\n\n- debug:\n    var: sha256_checksum.stat.checksum\n"
  },
  "ansible.windows.win_tempfile": {
    "doc": {
      "description": "Creates temporary files and directories.\nFor non-Windows targets, please use the M(ansible.builtin.tempfile) module instead.",
      "has_action": false,
      "options": {
        "path": {
          "aliases": [
            "dest"
          ],
          "description": "Location where temporary file or directory should be created.\nIf path is not specified default system temporary directory (%TEMP%) will be used.",
          "default": "%TEMP%",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "prefix": {
          "aliases": [],
          "description": "Prefix of file/directory name created by module.",
          "default": "ansible.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Whether to create file or directory.",
          "default": "file",
          "type": "str",
          "required": false,
          "choices": [
            "directory",
            "file"
          ],
          "suboptions": {}
        },
        "suffix": {
          "aliases": [],
          "description": "Suffix of file/directory name created by module.",
          "default": "",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Creates temporary files and directories"
    },
    "examples": "\n- name: Create temporary build directory\n  ansible.windows.win_tempfile:\n    state: directory\n    suffix: build\n\n- name: Create temporary file\n  ansible.windows.win_tempfile:\n    state: file\n    suffix: temp\n"
  },
  "ansible.windows.win_template": {
    "doc": {
      "description": "Templates are processed by the L(Jinja2 templating language,http://jinja.pocoo.org/docs/).\nDocumentation on the template formatting can be found in the L(Template Designer Documentation,http://jinja.pocoo.org/docs/templates/).\nAdditional variables listed below can be used in templates.\nC(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid.\nC(template_host) contains the node name of the template's machine.\nC(template_uid) is the numeric user id of the owner.\nC(template_path) is the path of the template.\nC(template_fullpath) is the absolute path of the template.\nC(template_destpath) is the path of the template on the remote system (added in 2.8).\nC(template_run_date) is the date that the template was rendered.",
      "has_action": true,
      "notes": "Including a string that uses a date in the template will result in the template being marked 'changed' each time.\nAlso, you can override jinja2 settings by adding a special header to template file. i.e. C(#jinja2:variable_start_string:'[%', variable_end_string:'%]', trim_blocks: False) which changes the variable interpolation markers to C([% var %]) instead of C({{ var }}). This is the best way to prevent evaluation of things that look like, but should not be Jinja2.\n\nUsing raw/endraw in Jinja2 will not work as you expect because templates in Ansible are recursively evaluated.\nTo find Byte Order Marks in files, use C(Format-Hex <file> -Count 16) on Windows, and use C(od -a -t x1 -N 16 <file>) on Linux.\nBeware fetching files from windows machines when creating templates because certain tools, such as Powershell ISE, and regedit's export facility add a Byte Order Mark as the first character of the file, which can cause tracebacks.\nYou can use the M(ansible.windows.win_copy) module with the C(content:) option if you prefer the template inline, as part of the playbook.\nFor Linux you can use M(ansible.builtin.template) which uses '\\\\n' as C(newline_sequence) by default.",
      "options": {
        "backup": {
          "aliases": [],
          "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "block_end_string": {
          "aliases": [],
          "description": "The string marking the end of a block.",
          "default": "%}",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "block_start_string": {
          "aliases": [],
          "description": "The string marking the beginning of a block.",
          "default": "{%",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Location to render the template to on the remote machine.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "force": {
          "aliases": [],
          "description": "Determine when the file is being transferred if the destination already exists.\nWhen set to C(yes), replace the remote file when contents are different than the source.\nWhen set to C(no), the file will only be transferred if the destination does not exist.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "lstrip_blocks": {
          "aliases": [],
          "description": "Determine when leading spaces and tabs should be stripped.\nWhen set to C(yes) leading spaces and tabs are stripped from the start of a line to a block.\nThis functionality requires Jinja 2.7 or newer.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "newline_sequence": {
          "aliases": [],
          "description": "Specify the newline sequence to use for templating files.",
          "default": "\\r\\n",
          "type": "str",
          "required": false,
          "choices": [
            "\\n",
            "\\r",
            "\\r\\n"
          ],
          "suboptions": {}
        },
        "output_encoding": {
          "aliases": [],
          "description": "Overrides the encoding used to write the template file defined by C(dest).\nIt defaults to C(utf-8), but any encoding supported by python can be used.\nThe source template file must always be encoded using C(utf-8), for homogeneity.",
          "default": "utf-8",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "src": {
          "aliases": [],
          "description": "Path of a Jinja2 formatted template on the Ansible controller.\nThis can be a relative or an absolute path.\nThe file must be encoded with C(utf-8) but I(output_encoding) can be used to control the encoding of the output template.",
          "type": "path",
          "required": true,
          "suboptions": {}
        },
        "trim_blocks": {
          "aliases": [],
          "description": "Determine when newlines should be removed from blocks.\nWhen set to C(yes) the first newline after a block is removed (block, not variable tag!).",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "variable_end_string": {
          "aliases": [],
          "description": "The string marking the end of a print statement.",
          "default": "}}",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "variable_start_string": {
          "aliases": [],
          "description": "The string marking the beginning of a print statement.",
          "default": "{{",
          "type": "str",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Template a file out to a remote server"
    },
    "examples": "\n- name: Create a file from a Jinja2 template\n  ansible.windows.win_template:\n    src: /mytemplates/file.conf.j2\n    dest: C:\\Temp\\file.conf\n\n- name: Create a Unix-style file from a Jinja2 template\n  ansible.windows.win_template:\n    src: unix/config.conf.j2\n    dest: C:\\share\\unix\\config.conf\n    newline_sequence: '\\n'\n    backup: yes\n"
  },
  "ansible.windows.win_updates": {
    "doc": {
      "description": "Searches, downloads, and installs Windows updates synchronously by automating the Windows Update client.",
      "has_action": true,
      "notes": "M(ansible.windows.win_updates) must be run by a user with membership in the local Administrators group.\nM(ansible.windows.win_updates) will use the default update service configured for the machine (Windows Update, Microsoft Update, WSUS, etc).\nBy default M(ansible.windows.win_updates) does not manage reboots, but will signal when a reboot is required with the I(reboot_required) return value. I(reboot) can be used to reboot the host if required in the one task.\nM(ansible.windows.win_updates) can take a significant amount of time to complete (hours, in some cases). Performance depends on many factors, including OS version, number of updates, system load, and update server load.\nBeware that just after M(ansible.windows.win_updates) reboots the system, the Windows system may not have settled yet and some base services could be in limbo. This can result in unexpected behavior. Check the examples for ways to mitigate this.\nMore information about PowerShell and how it handles RegEx strings can be found at U(https://technet.microsoft.com/en-us/library/2007.11.powershell.aspx).\nThe current module doesn't support Systems Center Configuration Manager (SCCM). See U(https://github.com/ansible-collections/ansible.windows/issues/194)",
      "options": {
        "_output_path": {
          "aliases": [],
          "description": "Internal use only.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "_wait": {
          "aliases": [],
          "description": "Internal use only.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "accept_list": {
          "aliases": [
            "whitelist"
          ],
          "description": "A list of update titles or KB numbers that can be used to specify which updates are to be searched or installed.\nIf an available update does not match one of the entries, then it is skipped and not installed.\nEach entry can either be the KB article or Update title as a regex according to the PowerShell regex rules.\nThe accept list is only validated on updates that were found based on I(category_names). It will not force the module to install an update if it was not in the category specified.\nThe alias C(whitelist) is deprecated and will be removed in a release after C(2023-06-01).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "category_names": {
          "aliases": [],
          "description": "A scalar or list of categories to install updates from. To get the list of categories, run the module with C(state=searched). The category must be the full category string, but is case insensitive.\nSome possible categories are Application, Connectors, Critical Updates, Definition Updates, Developer Kits, Feature Packs, Guidance, Security Updates, Service Packs, Tools, Update Rollups, Updates, and Upgrades.\nSince C(v1.7.0) the value C(*) will match all categories.",
          "default": "['CriticalUpdates', 'SecurityUpdates', 'UpdateRollups']",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "log_path": {
          "aliases": [],
          "description": "If set, C(win_updates) will append update progress to the specified file. The directory must already exist.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "reboot": {
          "aliases": [],
          "description": "Ansible will automatically reboot the remote host if it is required and continue to install updates after the reboot.\nThis can be used instead of using a M(ansible.windows.win_reboot) task after this one and ensures all updates for that category is installed in one go.\nAsync does not work when C(reboot=yes).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "reboot_timeout": {
          "aliases": [],
          "description": "The time in seconds to wait until the host is back online from a reboot.\nThis is only used if C(reboot=yes) and a reboot is required.",
          "default": "1200",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "reject_list": {
          "aliases": [
            "blacklist"
          ],
          "description": "A list of update titles or KB numbers that can be used to specify which updates are to be excluded from installation.\nIf an available update does match one of the entries, then it is skipped and not installed.\nEach entry can either be the KB article or Update title as a regex according to the PowerShell regex rules.\nThe alias C(blacklist) is deprecated and will be removed in a release after C(2023-06-01).",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "server_selection": {
          "aliases": [],
          "description": "Defines the Windows Update source catalog.\nC(default) Use the default search source. For many systems default is set to the Microsoft Windows Update catalog. Systems participating in Windows Server Update Services (WSUS) or similar corporate update server environments may default to those managed update sources instead of the Windows Update catalog.\nC(managed_server) Use a managed server catalog. For environments utilizing Windows Server Update Services (WSUS) or similar corporate update servers, this option selects the defined corporate update source.\nC(windows_update) Use the Microsoft Windows Update catalog.",
          "default": "default",
          "type": "str",
          "required": false,
          "choices": [
            "default",
            "managed_server",
            "windows_update"
          ],
          "suboptions": {}
        },
        "skip_optional": {
          "aliases": [],
          "description": "Skip optional updates where the update has BrowseOnly set by Microsoft.\nMicrosoft documents show that BrowseOnly means that the update should not be installed automatically and appear as optional updates.",
          "default": "False",
          "type": "bool",
          "required": false,
          "version_added": "1.8.0",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "Controls whether found updates are downloaded or installed or listed\nThis module also supports Ansible check mode, which has the same effect as setting state=searched",
          "default": "installed",
          "type": "str",
          "required": false,
          "choices": [
            "installed",
            "searched",
            "downloaded"
          ],
          "suboptions": {}
        },
        "use_scheduled_task": {
          "aliases": [],
          "description": "This option is deprecated and no longer does anything since C(v1.7.0) of this collection.\nThe option will be removed in a release after C(2023-06-01).",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Download and install Windows updates"
    },
    "examples": "\n- name: Install all updates and reboot as many times as needed\n  ansible.windows.win_updates:\n    category_names: '*'\n    reboot: yes\n\n- name: Install all security, critical, and rollup updates without a scheduled task\n  ansible.windows.win_updates:\n    category_names:\n      - SecurityUpdates\n      - CriticalUpdates\n      - UpdateRollups\n\n- name: Search-only, return list of found updates (if any), log to C:\\ansible_wu.txt\n  ansible.windows.win_updates:\n    category_names: SecurityUpdates\n    state: searched\n    log_path: C:\\ansible_wu.txt\n\n- name: Install all security updates with automatic reboots\n  ansible.windows.win_updates:\n    category_names:\n    - SecurityUpdates\n    reboot: yes\n\n- name: Install only particular updates based on the KB numbers\n  ansible.windows.win_updates:\n    category_name:\n    - SecurityUpdates\n    accept_list:\n    - KB4056892\n    - KB4073117\n\n- name: Exclude updates based on the update title\n  ansible.windows.win_updates:\n    category_name:\n    - SecurityUpdates\n    - CriticalUpdates\n    reject_list:\n    - Windows Malicious Software Removal Tool for Windows\n    - \\d{4}-\\d{2} Cumulative Update for Windows Server 2016\n\n# Optionally, you can increase the reboot_timeout to survive long updates during reboot\n- name: Ensure we wait long enough for the updates to be applied during reboot\n  ansible.windows.win_updates:\n    reboot: yes\n    reboot_timeout: 3600\n\n# Search and download Windows updates\n- name: Search and download Windows updates without installing them\n  ansible.windows.win_updates:\n    state: downloaded\n"
  },
  "ansible.windows.win_uri": {
    "doc": {
      "description": "Interacts with FTP, HTTP and HTTPS web services.\nSupports Digest, Basic and WSSE HTTP authentication mechanisms.\nFor non-Windows targets, use the M(ansible.builtin.uri) module instead.",
      "has_action": false,
      "options": {
        "body": {
          "aliases": [],
          "description": "The body of the HTTP request/response to the web service.",
          "type": "raw",
          "required": false,
          "suboptions": {}
        },
        "client_cert": {
          "aliases": [],
          "description": "The path to the client certificate (.pfx) that is used for X509 authentication. This path can either be the path to the C(pfx) on the filesystem or the PowerShell certificate path C(Cert:\\CurrentUser\\My\\<thumbprint>).\nThe WinRM connection must be authenticated with C(CredSSP) or C(become) is used on the task if the certificate file is not password protected.\nOther authentication types can set I(client_cert_password) when the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "client_cert_password": {
          "aliases": [],
          "description": "The password for I(client_cert) if the cert is password protected.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "content_type": {
          "aliases": [],
          "description": "Sets the \"Content-Type\" header.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "creates": {
          "aliases": [],
          "description": "A filename, when it already exists, this step will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "dest": {
          "aliases": [],
          "description": "Output the response body to a file.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "follow_redirects": {
          "aliases": [],
          "description": "Whether or the module should follow redirects.\nC(all) will follow all redirect.\nC(none) will not follow any redirect.\nC(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a C(GET) or C(HEAD) on the URI to which it is being redirected.\nWhen following a redirected URL, the C(Authorization) header and any credentials set will be dropped and not redirected.",
          "default": "safe",
          "type": "str",
          "required": false,
          "choices": [
            "all",
            "none",
            "safe"
          ],
          "suboptions": {}
        },
        "force_basic_auth": {
          "aliases": [],
          "description": "By default the authentication header is only sent when a webservice responses to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail.\nThis option forces the sending of the Basic authentication header upon the original request.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "headers": {
          "aliases": [],
          "description": "Extra headers to set on the request.\nThis should be a dictionary where the key is the header name and the value is the value for that header.",
          "type": "dict",
          "required": false,
          "suboptions": {}
        },
        "http_agent": {
          "aliases": [],
          "description": "Header to identify as, generally appears in web server logs.\nThis is set to the C(User-Agent) header on a HTTP request.",
          "default": "ansible-httpget",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "maximum_redirection": {
          "aliases": [],
          "description": "Specify how many times the module will redirect a connection to an alternative URI before the connection fails.\nIf set to C(0) or I(follow_redirects) is set to C(none), or C(safe) when not doing a C(GET) or C(HEAD) it prevents all redirection.",
          "default": "50",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "proxy_password": {
          "aliases": [],
          "description": "The password for I(proxy_username).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_url": {
          "aliases": [],
          "description": "An explicit proxy to use for the request.\nBy default, the request will use the IE defined proxy unless I(use_proxy) is set to C(no).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "proxy_use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a proxy host protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nProxies that use C(Basic) auth will still require explicit credentials through the I(proxy_username) and I(proxy_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no proxy authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "proxy_username": {
          "aliases": [],
          "description": "The username to use for proxy authentication.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "removes": {
          "aliases": [],
          "description": "A filename, when it does not exist, this step will be skipped.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "return_content": {
          "aliases": [],
          "description": "Whether or not to return the body of the response as a \"content\" key in the dictionary result. If the reported Content-type is \"application/json\", then the JSON is additionally loaded into a key called C(json) in the dictionary results.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "status_code": {
          "aliases": [],
          "description": "A valid, numeric, HTTP status code that signifies success of the request.\nCan also be comma separated list of status codes.",
          "default": "[200]",
          "type": "list",
          "required": false,
          "elements": "int",
          "suboptions": {}
        },
        "url": {
          "aliases": [],
          "description": "Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "url_method": {
          "aliases": [
            "method"
          ],
          "description": "The HTTP Method of the request.",
          "default": "GET",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_password": {
          "aliases": [
            "password"
          ],
          "description": "The password for I(url_username).\nThe alias I(password) is deprecated and will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "url_timeout": {
          "aliases": [
            "timeout"
          ],
          "description": "Specifies how long the request can be pending before it times out (in seconds).\nSet to C(0) to specify an infinite timeout.",
          "default": "30",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "url_username": {
          "aliases": [
            "user",
            "username"
          ],
          "description": "The username to use for authentication.\nThe alias I(user) and I(username) is deprecated and will be removed on the major release after C(2022-07-01).",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "use_default_credential": {
          "aliases": [],
          "description": "Uses the current user's credentials when authenticating with a server protected with C(NTLM), C(Kerberos), or C(Negotiate) authentication.\nSites that use C(Basic) auth will still require explicit credentials through the I(url_username) and I(url_password) options.\nThe module will only have access to the user's credentials if using C(become) with a password, you are connecting with SSH using a password, or connecting with WinRM using C(CredSSP) or C(Kerberos with delegation).\nIf not using C(become) or a different auth method to the ones stated above, there will be no default credentials available and no authentication will occur.",
          "default": "False",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "use_proxy": {
          "aliases": [],
          "description": "If C(no), it will not use the proxy defined in IE for the current user.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "validate_certs": {
          "aliases": [],
          "description": "If C(no), SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates.",
          "default": "True",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Interacts with webservices"
    },
    "examples": "\n- name: Perform a GET and Store Output\n  ansible.windows.win_uri:\n    url: http://example.com/endpoint\n  register: http_output\n\n# Set a HOST header to hit an internal webserver:\n- name: Hit a Specific Host on the Server\n  ansible.windows.win_uri:\n    url: http://example.com/\n    method: GET\n    headers:\n      host: www.somesite.com\n\n- name: Perform a HEAD on an Endpoint\n  ansible.windows.win_uri:\n    url: http://www.example.com/\n    method: HEAD\n\n- name: POST a Body to an Endpoint\n  ansible.windows.win_uri:\n    url: http://www.somesite.com/\n    method: POST\n    body: \"{ 'some': 'json' }\"\n"
  },
  "ansible.windows.win_user": {
    "doc": {
      "description": "Manages local Windows user accounts.\nFor non-Windows targets, use the M(ansible.builtin.user) module instead.",
      "has_action": false,
      "notes": "The return values are based on the user object after the module options have been set. When running in check mode the values will still reflect the existing user settings and not what they would have been changed to.",
      "options": {
        "account_disabled": {
          "aliases": [],
          "description": "C(yes) will disable the user account.\nC(no) will clear the disabled flag.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "account_locked": {
          "aliases": [],
          "description": "Only C(no) can be set and it will unlock the user account if locked.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "description": {
          "aliases": [],
          "description": "Description of the user.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "fullname": {
          "aliases": [],
          "description": "Full name of the user.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "groups": {
          "aliases": [],
          "description": "Adds or removes the user from this comma-separated list of groups, depending on the value of I(groups_action).\nWhen I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.\nSince C(ansible.windows v1.5.0) it is possible to specify a group using it's security identifier.",
          "type": "list",
          "required": false,
          "elements": "str",
          "suboptions": {}
        },
        "groups_action": {
          "aliases": [],
          "description": "If C(add), the user is added to each group in I(groups) where not already a member.\nIf C(replace), the user is added as a member of each group in I(groups) and removed from any other groups.\nIf C(remove), the user is removed from each group in I(groups).",
          "default": "replace",
          "type": "str",
          "required": false,
          "choices": [
            "add",
            "replace",
            "remove"
          ],
          "suboptions": {}
        },
        "home_directory": {
          "aliases": [],
          "description": "The designated home directory of the user.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "login_script": {
          "aliases": [],
          "description": "The login script of the user.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "Name of the user to create, remove or modify.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "password": {
          "aliases": [],
          "description": "Optionally set the user's password to this (plain text) value.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "password_expired": {
          "aliases": [],
          "description": "C(yes) will require the user to change their password at next login.\nC(no) will clear the expired password flag.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "password_never_expires": {
          "aliases": [],
          "description": "C(yes) will set the password to never expire.\nC(no) will allow the password to expire.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        },
        "profile": {
          "aliases": [],
          "description": "The profile path of the user.",
          "type": "str",
          "required": false,
          "version_added": "1.0.0",
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "When C(absent), removes the user account if it exists.\nWhen C(present), creates or updates the user account.\nWhen C(query), retrieves the user account details without making any changes.",
          "default": "present",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "present",
            "query"
          ],
          "suboptions": {}
        },
        "update_password": {
          "aliases": [],
          "description": "C(always) will update passwords if they differ.\nC(on_create) will only set the password for newly created users.",
          "default": "always",
          "type": "str",
          "required": false,
          "choices": [
            "always",
            "on_create"
          ],
          "suboptions": {}
        },
        "user_cannot_change_password": {
          "aliases": [],
          "description": "C(yes) will prevent the user from changing their password.\nC(no) will allow the user to change their password.",
          "type": "bool",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Manages local Windows user accounts"
    },
    "examples": "\n- name: Ensure user bob is present\n  ansible.windows.win_user:\n    name: bob\n    password: B0bP4ssw0rd\n    state: present\n    groups:\n      - Users\n\n- name: Ensure user bob is absent\n  ansible.windows.win_user:\n    name: bob\n    state: absent\n"
  },
  "ansible.windows.win_user_right": {
    "doc": {
      "description": "Add, remove or set User Rights for a group or users or groups.\nYou can set user rights for both local and domain accounts.",
      "has_action": false,
      "notes": "If the server is domain joined this module can change a right but if a GPO governs this right then the changes won't last.",
      "options": {
        "action": {
          "aliases": [],
          "description": "C(add) will add the users/groups to the existing right.\nC(remove) will remove the users/groups from the existing right.\nC(set) will replace the users/groups of the existing right.",
          "default": "set",
          "type": "str",
          "required": false,
          "choices": [
            "add",
            "remove",
            "set"
          ],
          "suboptions": {}
        },
        "name": {
          "aliases": [],
          "description": "The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).\nThe module will return an error if the right is invalid.",
          "type": "str",
          "required": true,
          "suboptions": {}
        },
        "users": {
          "aliases": [],
          "description": "A list of users or groups to add/remove on the User Right.\nThese can be in the form DOMAIN\\user-group, user-group@DOMAIN.COM for domain users/groups.\nFor local users/groups it can be in the form user-group, .\\user-group, SERVERNAME\\user-group where SERVERNAME is the name of the remote server.\nIt is highly recommended to use the C(.\\) or C(SERVERNAME\\) prefix to avoid any ambiguity with domain account names or errors trying to lookup an account on a domain controller.\nYou can also add special local accounts like SYSTEM and others.\nCan be set to an empty list with I(action=set) to remove all accounts from the right.",
          "type": "list",
          "required": true,
          "elements": "str",
          "suboptions": {}
        }
      },
      "short_description": "Manage Windows User Rights"
    },
    "examples": "\n---\n- name: Replace the entries of Deny log on locally\n  ansible.windows.win_user_right:\n    name: SeDenyInteractiveLogonRight\n    users:\n    - Guest\n    - Users\n    action: set\n\n- name: Add account to Log on as a service\n  ansible.windows.win_user_right:\n    name: SeServiceLogonRight\n    users:\n    - .\\Administrator\n    - '{{ansible_hostname}}\\local-user'\n    action: add\n\n- name: Remove accounts who can create Symbolic links\n  ansible.windows.win_user_right:\n    name: SeCreateSymbolicLinkPrivilege\n    users:\n    - SYSTEM\n    - Administrators\n    - DOMAIN\\User\n    - group@DOMAIN.COM\n    action: remove\n\n- name: Remove all accounts who cannot log on remote interactively\n  ansible.windows.win_user_right:\n    name: SeDenyRemoteInteractiveLogonRight\n    users: []\n"
  },
  "ansible.windows.win_wait_for": {
    "doc": {
      "description": "You can wait for a set amount of time C(timeout), this is the default if nothing is specified.\nWaiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.\nYou can wait for a file to exist or not exist on the filesystem.\nThis module can also be used to wait for a regex match string to be present in a file.\nYou can wait for active connections to be closed before continuing on a local port.",
      "has_action": false,
      "options": {
        "connect_timeout": {
          "aliases": [],
          "description": "The maximum number of seconds to wait for a connection to happen before closing and retrying.",
          "default": "5",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "delay": {
          "aliases": [],
          "description": "The number of seconds to wait before starting to poll.",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "exclude_hosts": {
          "aliases": [],
          "description": "The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained).",
          "type": "list",
          "required": false,
          "suboptions": {}
        },
        "host": {
          "aliases": [],
          "description": "A resolvable hostname or IP address to wait for.\nIf C(state=drained) then it will only check for connections on the IP specified, you can use '0.0.0.0' to use all host IPs.",
          "default": "127.0.0.1",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "path": {
          "aliases": [],
          "description": "The path to a file on the filesystem to check.\nIf C(state) is present or started then it will wait until the file exists.\nIf C(state) is absent then it will wait until the file does not exist.",
          "type": "path",
          "required": false,
          "suboptions": {}
        },
        "port": {
          "aliases": [],
          "description": "The port number to poll on C(host).",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "regex": {
          "aliases": [
            "search_regex",
            "regexp"
          ],
          "description": "Can be used to match a string in a file.\nIf C(state) is present or started then it will wait until the regex matches.\nIf C(state) is absent then it will wait until the regex does not match.\nDefaults to a multiline regex.",
          "type": "str",
          "required": false,
          "suboptions": {}
        },
        "sleep": {
          "aliases": [],
          "description": "Number of seconds to sleep between checks.",
          "default": "1",
          "type": "int",
          "required": false,
          "suboptions": {}
        },
        "state": {
          "aliases": [],
          "description": "When checking a port, C(started) will ensure the port is open, C(stopped) will check that is it closed and C(drained) will check for active connections.\nWhen checking for a file or a search string C(present) or C(started) will ensure that the file or string is present, C(absent) will check that the file or search string is absent or removed.",
          "default": "started",
          "type": "str",
          "required": false,
          "choices": [
            "absent",
            "drained",
            "present",
            "started",
            "stopped"
          ],
          "suboptions": {}
        },
        "timeout": {
          "aliases": [],
          "description": "The maximum number of seconds to wait for.",
          "default": "300",
          "type": "int",
          "required": false,
          "suboptions": {}
        }
      },
      "short_description": "Waits for a condition before continuing"
    },
    "examples": "\n- name: Wait 300 seconds for port 8000 to become open on the host, don't start checking for 10 seconds\n  ansible.windows.win_wait_for:\n    port: 8000\n    delay: 10\n\n- name: Wait 150 seconds for port 8000 of any IP to close active connections\n  ansible.windows.win_wait_for:\n    host: 0.0.0.0\n    port: 8000\n    state: drained\n    timeout: 150\n\n- name: Wait for port 8000 of any IP to close active connection, ignoring certain hosts\n  ansible.windows.win_wait_for:\n    host: 0.0.0.0\n    port: 8000\n    state: drained\n    exclude_hosts: ['10.2.1.2', '10.2.1.3']\n\n- name: Wait for file C:\\temp\\log.txt to exist before continuing\n  ansible.windows.win_wait_for:\n    path: C:\\temp\\log.txt\n\n- name: Wait until process complete is in the file before continuing\n  ansible.windows.win_wait_for:\n    path: C:\\temp\\log.txt\n    regex: process complete\n\n- name: Wait until file is removed\n  ansible.windows.win_wait_for:\n    path: C:\\temp\\log.txt\n    state: absent\n\n- name: Wait until port 1234 is offline but try every 10 seconds\n  ansible.windows.win_wait_for:\n    port: 1234\n    state: absent\n    sleep: 10\n"
  },
  "ansible.windows.win_whoami": {
    "doc": {
      "description": "Designed to return the same information as the C(whoami /all) command.\nAlso includes information missing from C(whoami) such as logon metadata like logon rights, id, type.",
      "has_action": false,
      "notes": "If running this module with a non admin user, the logon rights will be an empty list as Administrator rights are required to query LSA for the information.",
      "short_description": "Get information about the current user and process"
    },
    "examples": "\n- name: Get whoami information\n  ansible.windows.win_whoami:\n"
  }
}